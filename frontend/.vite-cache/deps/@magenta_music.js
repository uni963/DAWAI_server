import {
  es6_exports,
  es6_exports8 as es6_exports2
} from "./chunk-72EC6E55.js";
import {
  audioBufferConstructor,
  audioContextConstructor,
  audioWorkletNodeConstructor,
  isAnyAudioContext,
  isAnyAudioNode,
  isAnyAudioParam,
  isAnyOfflineAudioContext,
  isSupported,
  offlineAudioContextConstructor
} from "./chunk-Q64CMPGS.js";
import {
  ENV,
  add,
  addStrict,
  argMax,
  basicLSTMCell,
  batchNorm,
  batchToSpaceND,
  booleanMaskAsync,
  buffer,
  cast,
  clipByValue,
  concat,
  concat1d,
  concat2d,
  concat3d,
  conv1d,
  conv2d,
  cos,
  cumsum,
  depthwiseConv2d,
  dispose,
  dist_exports2 as dist_exports,
  div,
  env,
  equal,
  exp,
  expandDims,
  exports_layers_exports,
  fill,
  gather,
  getBackend,
  greater,
  greaterEqual,
  input,
  io_exports,
  lessEqual,
  linspace,
  loadGraphModel,
  log,
  logicalOr,
  matMul,
  maxPool,
  maximum,
  mean,
  min,
  minimum,
  model,
  mul,
  multiRNNCell,
  multinomial,
  nextFrame,
  oneHot,
  ones,
  outerProduct,
  pad,
  pool,
  pow,
  randomNormal,
  randomUniform,
  ready,
  registerOp,
  reshape,
  reverse,
  round,
  rsqrt,
  scalar,
  separableConv2d,
  sequential,
  sigmoid,
  sin,
  slice,
  slice3d,
  softmax,
  split,
  sqrt,
  square,
  squeeze,
  stack,
  sub,
  subStrict,
  sum,
  tanh,
  tensor,
  tensor1d,
  tensor2d,
  tidy,
  tile,
  train,
  truncatedNormal,
  where,
  zeros,
  zerosLike
} from "./chunk-EQSZBQFM.js";
import {
  __awaiter,
  __decorate
} from "./chunk-E6GWRJA3.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM
} from "./chunk-V4OQ3NZ2.js";

// node_modules/@protobufjs/aspromise/index.js
var require_aspromise = __commonJS({
  "node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
    "use strict";
    module2.exports = asPromise;
    function asPromise(fn, ctx) {
      var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
      while (index < arguments.length)
        params[offset++] = arguments[index++];
      return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err) {
          if (pending) {
            pending = false;
            if (err)
              reject(err);
            else {
              var params2 = new Array(arguments.length - 1), offset2 = 0;
              while (offset2 < params2.length)
                params2[offset2++] = arguments[offset2];
              resolve.apply(null, params2);
            }
          }
        };
        try {
          fn.apply(ctx || null, params);
        } catch (err) {
          if (pending) {
            pending = false;
            reject(err);
          }
        }
      });
    }
  }
});

// node_modules/@protobufjs/base64/index.js
var require_base64 = __commonJS({
  "node_modules/@protobufjs/base64/index.js"(exports2) {
    "use strict";
    var base64 = exports2;
    base64.length = function length(string) {
      var p = string.length;
      if (!p)
        return 0;
      var n = 0;
      while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
      return Math.ceil(string.length * 3) / 4 - n;
    };
    var b64 = new Array(64);
    var s64 = new Array(123);
    for (i = 0; i < 64; )
      s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
    var i;
    base64.encode = function encode(buffer2, start2, end) {
      var parts = null, chunk = [];
      var i2 = 0, j = 0, t;
      while (start2 < end) {
        var b = buffer2[start2++];
        switch (j) {
          case 0:
            chunk[i2++] = b64[b >> 2];
            t = (b & 3) << 4;
            j = 1;
            break;
          case 1:
            chunk[i2++] = b64[t | b >> 4];
            t = (b & 15) << 2;
            j = 2;
            break;
          case 2:
            chunk[i2++] = b64[t | b >> 6];
            chunk[i2++] = b64[b & 63];
            j = 0;
            break;
        }
        if (i2 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i2 = 0;
        }
      }
      if (j) {
        chunk[i2++] = b64[t];
        chunk[i2++] = 61;
        if (j === 1)
          chunk[i2++] = 61;
      }
      if (parts) {
        if (i2)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i2));
    };
    var invalidEncoding = "invalid encoding";
    base64.decode = function decode(string, buffer2, offset) {
      var start2 = offset;
      var j = 0, t;
      for (var i2 = 0; i2 < string.length; ) {
        var c = string.charCodeAt(i2++);
        if (c === 61 && j > 1)
          break;
        if ((c = s64[c]) === void 0)
          throw Error(invalidEncoding);
        switch (j) {
          case 0:
            t = c;
            j = 1;
            break;
          case 1:
            buffer2[offset++] = t << 2 | (c & 48) >> 4;
            t = c;
            j = 2;
            break;
          case 2:
            buffer2[offset++] = (t & 15) << 4 | (c & 60) >> 2;
            t = c;
            j = 3;
            break;
          case 3:
            buffer2[offset++] = (t & 3) << 6 | c;
            j = 0;
            break;
        }
      }
      if (j === 1)
        throw Error(invalidEncoding);
      return offset - start2;
    };
    base64.test = function test(string) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
    };
  }
});

// node_modules/@protobufjs/eventemitter/index.js
var require_eventemitter = __commonJS({
  "node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
    "use strict";
    module2.exports = EventEmitter;
    function EventEmitter() {
      this._listeners = {};
    }
    EventEmitter.prototype.on = function on(evt, fn, ctx) {
      (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn,
        ctx: ctx || this
      });
      return this;
    };
    EventEmitter.prototype.off = function off(evt, fn) {
      if (evt === void 0)
        this._listeners = {};
      else {
        if (fn === void 0)
          this._listeners[evt] = [];
        else {
          var listeners = this._listeners[evt];
          for (var i = 0; i < listeners.length; )
            if (listeners[i].fn === fn)
              listeners.splice(i, 1);
            else
              ++i;
        }
      }
      return this;
    };
    EventEmitter.prototype.emit = function emit(evt) {
      var listeners = this._listeners[evt];
      if (listeners) {
        var args = [], i = 1;
        for (; i < arguments.length; )
          args.push(arguments[i++]);
        for (i = 0; i < listeners.length; )
          listeners[i].fn.apply(listeners[i++].ctx, args);
      }
      return this;
    };
  }
});

// node_modules/@protobufjs/float/index.js
var require_float = __commonJS({
  "node_modules/@protobufjs/float/index.js"(exports2, module2) {
    "use strict";
    module2.exports = factory(factory);
    function factory(exports3) {
      if (typeof Float32Array !== "undefined") (function() {
        var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
        function writeFloat_f32_cpy(val, buf, pos) {
          f32[0] = val;
          buf[pos] = f8b[0];
          buf[pos + 1] = f8b[1];
          buf[pos + 2] = f8b[2];
          buf[pos + 3] = f8b[3];
        }
        function writeFloat_f32_rev(val, buf, pos) {
          f32[0] = val;
          buf[pos] = f8b[3];
          buf[pos + 1] = f8b[2];
          buf[pos + 2] = f8b[1];
          buf[pos + 3] = f8b[0];
        }
        exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
        function readFloat_f32_cpy(buf, pos) {
          f8b[0] = buf[pos];
          f8b[1] = buf[pos + 1];
          f8b[2] = buf[pos + 2];
          f8b[3] = buf[pos + 3];
          return f32[0];
        }
        function readFloat_f32_rev(buf, pos) {
          f8b[3] = buf[pos];
          f8b[2] = buf[pos + 1];
          f8b[1] = buf[pos + 2];
          f8b[0] = buf[pos + 3];
          return f32[0];
        }
        exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
      })();
      else (function() {
        function writeFloat_ieee754(writeUint, val, buf, pos) {
          var sign = val < 0 ? 1 : 0;
          if (sign)
            val = -val;
          if (val === 0)
            writeUint(1 / val > 0 ? (
              /* positive */
              0
            ) : (
              /* negative 0 */
              2147483648
            ), buf, pos);
          else if (isNaN(val))
            writeUint(2143289344, buf, pos);
          else if (val > 34028234663852886e22)
            writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
          else if (val < 11754943508222875e-54)
            writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);
          else {
            var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
            writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
          }
        }
        exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
        function readFloat_ieee754(readUint, buf, pos) {
          var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
          return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }
        exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
      })();
      if (typeof Float64Array !== "undefined") (function() {
        var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
        function writeDouble_f64_cpy(val, buf, pos) {
          f64[0] = val;
          buf[pos] = f8b[0];
          buf[pos + 1] = f8b[1];
          buf[pos + 2] = f8b[2];
          buf[pos + 3] = f8b[3];
          buf[pos + 4] = f8b[4];
          buf[pos + 5] = f8b[5];
          buf[pos + 6] = f8b[6];
          buf[pos + 7] = f8b[7];
        }
        function writeDouble_f64_rev(val, buf, pos) {
          f64[0] = val;
          buf[pos] = f8b[7];
          buf[pos + 1] = f8b[6];
          buf[pos + 2] = f8b[5];
          buf[pos + 3] = f8b[4];
          buf[pos + 4] = f8b[3];
          buf[pos + 5] = f8b[2];
          buf[pos + 6] = f8b[1];
          buf[pos + 7] = f8b[0];
        }
        exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
        function readDouble_f64_cpy(buf, pos) {
          f8b[0] = buf[pos];
          f8b[1] = buf[pos + 1];
          f8b[2] = buf[pos + 2];
          f8b[3] = buf[pos + 3];
          f8b[4] = buf[pos + 4];
          f8b[5] = buf[pos + 5];
          f8b[6] = buf[pos + 6];
          f8b[7] = buf[pos + 7];
          return f64[0];
        }
        function readDouble_f64_rev(buf, pos) {
          f8b[7] = buf[pos];
          f8b[6] = buf[pos + 1];
          f8b[5] = buf[pos + 2];
          f8b[4] = buf[pos + 3];
          f8b[3] = buf[pos + 4];
          f8b[2] = buf[pos + 5];
          f8b[1] = buf[pos + 6];
          f8b[0] = buf[pos + 7];
          return f64[0];
        }
        exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
      })();
      else (function() {
        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
          var sign = val < 0 ? 1 : 0;
          if (sign)
            val = -val;
          if (val === 0) {
            writeUint(0, buf, pos + off0);
            writeUint(1 / val > 0 ? (
              /* positive */
              0
            ) : (
              /* negative 0 */
              2147483648
            ), buf, pos + off1);
          } else if (isNaN(val)) {
            writeUint(0, buf, pos + off0);
            writeUint(2146959360, buf, pos + off1);
          } else if (val > 17976931348623157e292) {
            writeUint(0, buf, pos + off0);
            writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
          } else {
            var mantissa;
            if (val < 22250738585072014e-324) {
              mantissa = val / 5e-324;
              writeUint(mantissa >>> 0, buf, pos + off0);
              writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
            } else {
              var exponent = Math.floor(Math.log(val) / Math.LN2);
              if (exponent === 1024)
                exponent = 1023;
              mantissa = val * Math.pow(2, -exponent);
              writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
              writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
            }
          }
        }
        exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
          var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
          var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
          return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }
        exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
      })();
      return exports3;
    }
    function writeUintLE(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    function writeUintBE(val, buf, pos) {
      buf[pos] = val >>> 24;
      buf[pos + 1] = val >>> 16 & 255;
      buf[pos + 2] = val >>> 8 & 255;
      buf[pos + 3] = val & 255;
    }
    function readUintLE(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
    }
    function readUintBE(buf, pos) {
      return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
    }
  }
});

// node_modules/@protobufjs/inquire/index.js
var require_inquire = __commonJS({
  "node_modules/@protobufjs/inquire/index.js"(exports, module) {
    "use strict";
    module.exports = inquire;
    function inquire(moduleName) {
      try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName);
        if (mod && (mod.length || Object.keys(mod).length))
          return mod;
      } catch (e) {
      }
      return null;
    }
  }
});

// node_modules/@protobufjs/utf8/index.js
var require_utf8 = __commonJS({
  "node_modules/@protobufjs/utf8/index.js"(exports2) {
    "use strict";
    var utf8 = exports2;
    utf8.length = function utf8_length(string) {
      var len = 0, c = 0;
      for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
          len += 1;
        else if (c < 2048)
          len += 2;
        else if ((c & 64512) === 55296 && (string.charCodeAt(i + 1) & 64512) === 56320) {
          ++i;
          len += 4;
        } else
          len += 3;
      }
      return len;
    };
    utf8.read = function utf8_read(buffer2, start2, end) {
      var len = end - start2;
      if (len < 1)
        return "";
      var parts = null, chunk = [], i = 0, t;
      while (start2 < end) {
        t = buffer2[start2++];
        if (t < 128)
          chunk[i++] = t;
        else if (t > 191 && t < 224)
          chunk[i++] = (t & 31) << 6 | buffer2[start2++] & 63;
        else if (t > 239 && t < 365) {
          t = ((t & 7) << 18 | (buffer2[start2++] & 63) << 12 | (buffer2[start2++] & 63) << 6 | buffer2[start2++] & 63) - 65536;
          chunk[i++] = 55296 + (t >> 10);
          chunk[i++] = 56320 + (t & 1023);
        } else
          chunk[i++] = (t & 15) << 12 | (buffer2[start2++] & 63) << 6 | buffer2[start2++] & 63;
        if (i > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i = 0;
        }
      }
      if (parts) {
        if (i)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i));
    };
    utf8.write = function utf8_write(string, buffer2, offset) {
      var start2 = offset, c1, c2;
      for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
          buffer2[offset++] = c1;
        } else if (c1 < 2048) {
          buffer2[offset++] = c1 >> 6 | 192;
          buffer2[offset++] = c1 & 63 | 128;
        } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i + 1)) & 64512) === 56320) {
          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
          ++i;
          buffer2[offset++] = c1 >> 18 | 240;
          buffer2[offset++] = c1 >> 12 & 63 | 128;
          buffer2[offset++] = c1 >> 6 & 63 | 128;
          buffer2[offset++] = c1 & 63 | 128;
        } else {
          buffer2[offset++] = c1 >> 12 | 224;
          buffer2[offset++] = c1 >> 6 & 63 | 128;
          buffer2[offset++] = c1 & 63 | 128;
        }
      }
      return offset - start2;
    };
  }
});

// node_modules/@protobufjs/pool/index.js
var require_pool = __commonJS({
  "node_modules/@protobufjs/pool/index.js"(exports2, module2) {
    "use strict";
    module2.exports = pool2;
    function pool2(alloc, slice2, size) {
      var SIZE = size || 8192;
      var MAX = SIZE >>> 1;
      var slab = null;
      var offset = SIZE;
      return function pool_alloc(size2) {
        if (size2 < 1 || size2 > MAX)
          return alloc(size2);
        if (offset + size2 > SIZE) {
          slab = alloc(SIZE);
          offset = 0;
        }
        var buf = slice2.call(slab, offset, offset += size2);
        if (offset & 7)
          offset = (offset | 7) + 1;
        return buf;
      };
    }
  }
});

// node_modules/protobufjs/src/util/longbits.js
var require_longbits = __commonJS({
  "node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
    "use strict";
    module2.exports = LongBits;
    var util = require_minimal();
    function LongBits(lo, hi) {
      this.lo = lo >>> 0;
      this.hi = hi >>> 0;
    }
    var zero = LongBits.zero = new LongBits(0, 0);
    zero.toNumber = function() {
      return 0;
    };
    zero.zzEncode = zero.zzDecode = function() {
      return this;
    };
    zero.length = function() {
      return 1;
    };
    var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits.fromNumber = function fromNumber(value) {
      if (value === 0)
        return zero;
      var sign = value < 0;
      if (sign)
        value = -value;
      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
      if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295)
            hi = 0;
        }
      }
      return new LongBits(lo, hi);
    };
    LongBits.from = function from(value) {
      if (typeof value === "number")
        return LongBits.fromNumber(value);
      if (util.isString(value)) {
        if (util.Long)
          value = util.Long.fromString(value);
        else
          return LongBits.fromNumber(parseInt(value, 10));
      }
      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
    };
    LongBits.prototype.toNumber = function toNumber(unsigned) {
      if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo)
          hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    };
    LongBits.prototype.toLong = function toLong(unsigned) {
      return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
    };
    var charCodeAt = String.prototype.charCodeAt;
    LongBits.fromHash = function fromHash(hash) {
      if (hash === zeroHash)
        return zero;
      return new LongBits(
        (charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0,
        (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0
      );
    };
    LongBits.prototype.toHash = function toHash() {
      return String.fromCharCode(
        this.lo & 255,
        this.lo >>> 8 & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24,
        this.hi & 255,
        this.hi >>> 8 & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
      );
    };
    LongBits.prototype.zzEncode = function zzEncode() {
      var mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.zzDecode = function zzDecode() {
      var mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.length = function length() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    };
  }
});

// node_modules/protobufjs/src/util/minimal.js
var require_minimal = __commonJS({
  "node_modules/protobufjs/src/util/minimal.js"(exports2) {
    "use strict";
    var util = exports2;
    util.asPromise = require_aspromise();
    util.base64 = require_base64();
    util.EventEmitter = require_eventemitter();
    util.float = require_float();
    util.inquire = require_inquire();
    util.utf8 = require_utf8();
    util.pool = require_pool();
    util.LongBits = require_longbits();
    util.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
    util.global = util.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
    util.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    );
    util.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    );
    util.isInteger = Number.isInteger || /* istanbul ignore next */
    function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    util.isString = function isString2(value) {
      return typeof value === "string" || value instanceof String;
    };
    util.isObject = function isObject2(value) {
      return value && typeof value === "object";
    };
    util.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    util.isSet = function isSet(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    };
    util.Buffer = (function() {
      try {
        var Buffer2 = util.inquire("buffer").Buffer;
        return Buffer2.prototype.utf8Write ? Buffer2 : (
          /* istanbul ignore next */
          null
        );
      } catch (e) {
        return null;
      }
    })();
    util._Buffer_from = null;
    util._Buffer_allocUnsafe = null;
    util.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util.Long = /* istanbul ignore next */
    util.global.dcodeIO && /* istanbul ignore next */
    util.global.dcodeIO.Long || /* istanbul ignore next */
    util.global.Long || util.inquire("long");
    util.key2Re = /^true|false|0|1$/;
    util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util.longToHash = function longToHash(value) {
      return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
    };
    util.longFromHash = function longFromHash(hash, unsigned) {
      var bits = util.LongBits.fromHash(hash);
      if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    };
    function merge(dst, src, ifNotSet) {
      for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === void 0 || !ifNotSet)
          dst[keys[i]] = src[keys[i]];
      return dst;
    }
    util.merge = merge;
    util.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name) {
      function CustomError(message, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge(this, properties);
      }
      (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;
      Object.defineProperty(CustomError.prototype, "name", { get: function() {
        return name;
      } });
      CustomError.prototype.toString = function toString() {
        return this.name + ": " + this.message;
      };
      return CustomError;
    }
    util.newError = newError;
    util.ProtocolError = newError("ProtocolError");
    util.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;
      return function() {
        for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)
          if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)
            return keys[i2];
      };
    };
    util.oneOfSetter = function setOneOf(fieldNames) {
      return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
          if (fieldNames[i] !== name)
            delete this[fieldNames[i]];
      };
    };
    util.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util._configure = function() {
      var Buffer2 = util.Buffer;
      if (!Buffer2) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
      }
      util._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || /* istanbul ignore next */
      function Buffer_from(value, encoding) {
        return new Buffer2(value, encoding);
      };
      util._Buffer_allocUnsafe = Buffer2.allocUnsafe || /* istanbul ignore next */
      function Buffer_allocUnsafe(size) {
        return new Buffer2(size);
      };
    };
  }
});

// node_modules/protobufjs/src/writer.js
var require_writer = __commonJS({
  "node_modules/protobufjs/src/writer.js"(exports2, module2) {
    "use strict";
    module2.exports = Writer;
    var util = require_minimal();
    var BufferWriter;
    var LongBits = util.LongBits;
    var base64 = util.base64;
    var utf8 = util.utf8;
    function Op(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    function noop() {
    }
    function State(writer) {
      this.head = writer.head;
      this.tail = writer.tail;
      this.len = writer.len;
      this.next = writer.states;
    }
    function Writer() {
      this.len = 0;
      this.head = new Op(noop, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    var create = function create2() {
      return util.Buffer ? function create_buffer_setup() {
        return (Writer.create = function create_buffer() {
          return new BufferWriter();
        })();
      } : function create_array() {
        return new Writer();
      };
    };
    Writer.create = create();
    Writer.alloc = function alloc(size) {
      return new util.Array(size);
    };
    if (util.Array !== Array)
      Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
    Writer.prototype._push = function push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    };
    function writeByte(val, buf, pos) {
      buf[pos] = val & 255;
    }
    function writeVarint32(val, buf, pos) {
      while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf[pos] = val;
    }
    function VarintOp(len, val) {
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    VarintOp.prototype = Object.create(Op.prototype);
    VarintOp.prototype.fn = writeVarint32;
    Writer.prototype.uint32 = function write_uint32(value) {
      this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
        value
      )).len;
      return this;
    };
    Writer.prototype.int32 = function write_int32(value) {
      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
    };
    Writer.prototype.sint32 = function write_sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
    };
    function writeVarint64(val, buf, pos) {
      while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf[pos++] = val.lo;
    }
    Writer.prototype.uint64 = function write_uint64(value) {
      var bits = LongBits.from(value);
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.int64 = Writer.prototype.uint64;
    Writer.prototype.sint64 = function write_sint64(value) {
      var bits = LongBits.from(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.bool = function write_bool(value) {
      return this._push(writeByte, 1, value ? 1 : 0);
    };
    function writeFixed32(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    Writer.prototype.fixed32 = function write_fixed32(value) {
      return this._push(writeFixed32, 4, value >>> 0);
    };
    Writer.prototype.sfixed32 = Writer.prototype.fixed32;
    Writer.prototype.fixed64 = function write_fixed64(value) {
      var bits = LongBits.from(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    };
    Writer.prototype.sfixed64 = Writer.prototype.fixed64;
    Writer.prototype.float = function write_float(value) {
      return this._push(util.float.writeFloatLE, 4, value);
    };
    Writer.prototype.double = function write_double(value) {
      return this._push(util.float.writeDoubleLE, 8, value);
    };
    var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
      buf.set(val, pos);
    } : function writeBytes_for(val, buf, pos) {
      for (var i = 0; i < val.length; ++i)
        buf[pos + i] = val[i];
    };
    Writer.prototype.bytes = function write_bytes(value) {
      var len = value.length >>> 0;
      if (!len)
        return this._push(writeByte, 1, 0);
      if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
      }
      return this.uint32(len)._push(writeBytes, len, value);
    };
    Writer.prototype.string = function write_string(value) {
      var len = utf8.length(value);
      return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
    };
    Writer.prototype.fork = function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop, 0, 0);
      this.len = 0;
      return this;
    };
    Writer.prototype.reset = function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len = 0;
      }
      return this;
    };
    Writer.prototype.ldelim = function ldelim() {
      var head = this.head, tail = this.tail, len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    };
    Writer.prototype.finish = function finish() {
      var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
      while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
      }
      return buf;
    };
    Writer._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_;
      Writer.create = create();
      BufferWriter._configure();
    };
  }
});

// node_modules/protobufjs/src/writer_buffer.js
var require_writer_buffer = __commonJS({
  "node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferWriter;
    var Writer = require_writer();
    (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
    var util = require_minimal();
    function BufferWriter() {
      Writer.call(this);
    }
    BufferWriter._configure = function() {
      BufferWriter.alloc = util._Buffer_allocUnsafe;
      BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
        buf.set(val, pos);
      } : function writeBytesBuffer_copy(val, buf, pos) {
        if (val.copy)
          val.copy(buf, pos, 0, val.length);
        else for (var i = 0; i < val.length; )
          buf[pos++] = val[i++];
      };
    };
    BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
      if (util.isString(value))
        value = util._Buffer_from(value, "base64");
      var len = value.length >>> 0;
      this.uint32(len);
      if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
      return this;
    };
    function writeStringBuffer(val, buf, pos) {
      if (val.length < 40)
        util.utf8.write(val, buf, pos);
      else if (buf.utf8Write)
        buf.utf8Write(val, pos);
      else
        buf.write(val, pos);
    }
    BufferWriter.prototype.string = function write_string_buffer(value) {
      var len = util.Buffer.byteLength(value);
      this.uint32(len);
      if (len)
        this._push(writeStringBuffer, len, value);
      return this;
    };
    BufferWriter._configure();
  }
});

// node_modules/protobufjs/src/reader.js
var require_reader = __commonJS({
  "node_modules/protobufjs/src/reader.js"(exports2, module2) {
    "use strict";
    module2.exports = Reader;
    var util = require_minimal();
    var BufferReader;
    var LongBits = util.LongBits;
    var utf8 = util.utf8;
    function indexOutOfRange(reader, writeLength) {
      return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
    }
    function Reader(buffer2) {
      this.buf = buffer2;
      this.pos = 0;
      this.len = buffer2.length;
    }
    var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer2) {
      if (buffer2 instanceof Uint8Array || Array.isArray(buffer2))
        return new Reader(buffer2);
      throw Error("illegal buffer");
    } : function create_array2(buffer2) {
      if (Array.isArray(buffer2))
        return new Reader(buffer2);
      throw Error("illegal buffer");
    };
    var create = function create2() {
      return util.Buffer ? function create_buffer_setup(buffer2) {
        return (Reader.create = function create_buffer(buffer3) {
          return util.Buffer.isBuffer(buffer3) ? new BufferReader(buffer3) : create_array(buffer3);
        })(buffer2);
      } : create_array;
    };
    Reader.create = create();
    Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */
    util.Array.prototype.slice;
    Reader.prototype.uint32 = /* @__PURE__ */ (function read_uint32_setup() {
      var value = 4294967295;
      return function read_uint32() {
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        if ((this.pos += 5) > this.len) {
          this.pos = this.len;
          throw indexOutOfRange(this, 10);
        }
        return value;
      };
    })();
    Reader.prototype.int32 = function read_int32() {
      return this.uint32() | 0;
    };
    Reader.prototype.sint32 = function read_sint32() {
      var value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
    };
    function readLongVarint() {
      var bits = new LongBits(0, 0);
      var i = 0;
      if (this.len - this.pos > 4) {
        for (; i < 4; ++i) {
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
        i = 0;
      } else {
        for (; i < 3; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
      }
      if (this.len - this.pos > 4) {
        for (; i < 5; ++i) {
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      } else {
        for (; i < 5; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      }
      throw Error("invalid varint encoding");
    }
    Reader.prototype.bool = function read_bool() {
      return this.uint32() !== 0;
    };
    function readFixed32_end(buf, end) {
      return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
    }
    Reader.prototype.fixed32 = function read_fixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    };
    Reader.prototype.sfixed32 = function read_sfixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    };
    function readFixed64() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);
      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    Reader.prototype.float = function read_float() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value;
    };
    Reader.prototype.double = function read_double() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value;
    };
    Reader.prototype.bytes = function read_bytes() {
      var length = this.uint32(), start2 = this.pos, end = this.pos + length;
      if (end > this.len)
        throw indexOutOfRange(this, length);
      this.pos += length;
      if (Array.isArray(this.buf))
        return this.buf.slice(start2, end);
      return start2 === end ? new this.buf.constructor(0) : this._slice.call(this.buf, start2, end);
    };
    Reader.prototype.string = function read_string() {
      var bytes = this.bytes();
      return utf8.read(bytes, 0, bytes.length);
    };
    Reader.prototype.skip = function skip(length) {
      if (typeof length === "number") {
        if (this.pos + length > this.len)
          throw indexOutOfRange(this, length);
        this.pos += length;
      } else {
        do {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    };
    Reader.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        /* istanbul ignore next */
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader._configure = function(BufferReader_) {
      BufferReader = BufferReader_;
      Reader.create = create();
      BufferReader._configure();
      var fn = util.Long ? "toLong" : (
        /* istanbul ignore next */
        "toNumber"
      );
      util.merge(Reader.prototype, {
        int64: function read_int64() {
          return readLongVarint.call(this)[fn](false);
        },
        uint64: function read_uint64() {
          return readLongVarint.call(this)[fn](true);
        },
        sint64: function read_sint64() {
          return readLongVarint.call(this).zzDecode()[fn](false);
        },
        fixed64: function read_fixed64() {
          return readFixed64.call(this)[fn](true);
        },
        sfixed64: function read_sfixed64() {
          return readFixed64.call(this)[fn](false);
        }
      });
    };
  }
});

// node_modules/protobufjs/src/reader_buffer.js
var require_reader_buffer = __commonJS({
  "node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferReader;
    var Reader = require_reader();
    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
    var util = require_minimal();
    function BufferReader(buffer2) {
      Reader.call(this, buffer2);
    }
    BufferReader._configure = function() {
      if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
    };
    BufferReader.prototype.string = function read_string_buffer() {
      var len = this.uint32();
      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
    };
    BufferReader._configure();
  }
});

// node_modules/protobufjs/src/rpc/service.js
var require_service = __commonJS({
  "node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
    "use strict";
    module2.exports = Service;
    var util = require_minimal();
    (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
    function Service(rpcImpl, requestDelimited, responseDelimited) {
      if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");
      util.EventEmitter.call(this);
      this.rpcImpl = rpcImpl;
      this.requestDelimited = Boolean(requestDelimited);
      this.responseDelimited = Boolean(responseDelimited);
    }
    Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
      if (!request)
        throw TypeError("request must be specified");
      var self2 = this;
      if (!callback)
        return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
      if (!self2.rpcImpl) {
        setTimeout(function() {
          callback(Error("already ended"));
        }, 0);
        return void 0;
      }
      try {
        return self2.rpcImpl(
          method,
          requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
          function rpcCallback(err, response) {
            if (err) {
              self2.emit("error", err, method);
              return callback(err);
            }
            if (response === null) {
              self2.end(
                /* endedByRPC */
                true
              );
              return void 0;
            }
            if (!(response instanceof responseCtor)) {
              try {
                response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
              } catch (err2) {
                self2.emit("error", err2, method);
                return callback(err2);
              }
            }
            self2.emit("data", response, method);
            return callback(null, response);
          }
        );
      } catch (err) {
        self2.emit("error", err, method);
        setTimeout(function() {
          callback(err);
        }, 0);
        return void 0;
      }
    };
    Service.prototype.end = function end(endedByRPC) {
      if (this.rpcImpl) {
        if (!endedByRPC)
          this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
      }
      return this;
    };
  }
});

// node_modules/protobufjs/src/rpc.js
var require_rpc = __commonJS({
  "node_modules/protobufjs/src/rpc.js"(exports2) {
    "use strict";
    var rpc = exports2;
    rpc.Service = require_service();
  }
});

// node_modules/protobufjs/src/roots.js
var require_roots = __commonJS({
  "node_modules/protobufjs/src/roots.js"(exports2, module2) {
    "use strict";
    module2.exports = {};
  }
});

// node_modules/protobufjs/src/index-minimal.js
var require_index_minimal = __commonJS({
  "node_modules/protobufjs/src/index-minimal.js"(exports2) {
    "use strict";
    var protobuf = exports2;
    protobuf.build = "minimal";
    protobuf.Writer = require_writer();
    protobuf.BufferWriter = require_writer_buffer();
    protobuf.Reader = require_reader();
    protobuf.BufferReader = require_reader_buffer();
    protobuf.util = require_minimal();
    protobuf.rpc = require_rpc();
    protobuf.roots = require_roots();
    protobuf.configure = configure;
    function configure() {
      protobuf.util._configure();
      protobuf.Writer._configure(protobuf.BufferWriter);
      protobuf.Reader._configure(protobuf.BufferReader);
    }
    configure();
  }
});

// node_modules/protobufjs/minimal.js
var require_minimal2 = __commonJS({
  "node_modules/protobufjs/minimal.js"(exports2, module2) {
    "use strict";
    module2.exports = require_index_minimal();
  }
});

// node_modules/@magenta/music/esm/protobuf/proto.js
var require_proto = __commonJS({
  "node_modules/@magenta/music/esm/protobuf/proto.js"(exports2, module2) {
    "use strict";
    var $protobuf = require_minimal2();
    var $Reader = $protobuf.Reader;
    var $Writer = $protobuf.Writer;
    var $util = $protobuf.util;
    var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
    $root.tensorflow = (function() {
      var tensorflow2 = {};
      tensorflow2.magenta = (function() {
        var magenta = {};
        magenta.NoteSequence = (function() {
          function NoteSequence2(properties) {
            this.timeSignatures = [];
            this.keySignatures = [];
            this.tempos = [];
            this.notes = [];
            this.pitchBends = [];
            this.controlChanges = [];
            this.partInfos = [];
            this.textAnnotations = [];
            this.sectionAnnotations = [];
            this.sectionGroups = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          NoteSequence2.prototype.id = "";
          NoteSequence2.prototype.filename = "";
          NoteSequence2.prototype.referenceNumber = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
          NoteSequence2.prototype.collectionName = "";
          NoteSequence2.prototype.ticksPerQuarter = 0;
          NoteSequence2.prototype.timeSignatures = $util.emptyArray;
          NoteSequence2.prototype.keySignatures = $util.emptyArray;
          NoteSequence2.prototype.tempos = $util.emptyArray;
          NoteSequence2.prototype.notes = $util.emptyArray;
          NoteSequence2.prototype.totalTime = 0;
          NoteSequence2.prototype.totalQuantizedSteps = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
          NoteSequence2.prototype.pitchBends = $util.emptyArray;
          NoteSequence2.prototype.controlChanges = $util.emptyArray;
          NoteSequence2.prototype.partInfos = $util.emptyArray;
          NoteSequence2.prototype.sourceInfo = null;
          NoteSequence2.prototype.textAnnotations = $util.emptyArray;
          NoteSequence2.prototype.sectionAnnotations = $util.emptyArray;
          NoteSequence2.prototype.sectionGroups = $util.emptyArray;
          NoteSequence2.prototype.quantizationInfo = null;
          NoteSequence2.prototype.subsequenceInfo = null;
          NoteSequence2.prototype.sequenceMetadata = null;
          NoteSequence2.create = function create(properties) {
            return new NoteSequence2(properties);
          };
          NoteSequence2.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(message.id);
            if (message.filename != null && message.hasOwnProperty("filename"))
              writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).string(message.filename);
            if (message.collectionName != null && message.hasOwnProperty("collectionName"))
              writer.uint32(
                /* id 3, wireType 2 =*/
                26
              ).string(message.collectionName);
            if (message.ticksPerQuarter != null && message.hasOwnProperty("ticksPerQuarter"))
              writer.uint32(
                /* id 4, wireType 0 =*/
                32
              ).int32(message.ticksPerQuarter);
            if (message.timeSignatures != null && message.timeSignatures.length)
              for (var i = 0; i < message.timeSignatures.length; ++i)
                $root.tensorflow.magenta.NoteSequence.TimeSignature.encode(message.timeSignatures[i], writer.uint32(
                  /* id 5, wireType 2 =*/
                  42
                ).fork()).ldelim();
            if (message.keySignatures != null && message.keySignatures.length)
              for (var i = 0; i < message.keySignatures.length; ++i)
                $root.tensorflow.magenta.NoteSequence.KeySignature.encode(message.keySignatures[i], writer.uint32(
                  /* id 6, wireType 2 =*/
                  50
                ).fork()).ldelim();
            if (message.tempos != null && message.tempos.length)
              for (var i = 0; i < message.tempos.length; ++i)
                $root.tensorflow.magenta.NoteSequence.Tempo.encode(message.tempos[i], writer.uint32(
                  /* id 7, wireType 2 =*/
                  58
                ).fork()).ldelim();
            if (message.notes != null && message.notes.length)
              for (var i = 0; i < message.notes.length; ++i)
                $root.tensorflow.magenta.NoteSequence.Note.encode(message.notes[i], writer.uint32(
                  /* id 8, wireType 2 =*/
                  66
                ).fork()).ldelim();
            if (message.totalTime != null && message.hasOwnProperty("totalTime"))
              writer.uint32(
                /* id 9, wireType 1 =*/
                73
              ).double(message.totalTime);
            if (message.pitchBends != null && message.pitchBends.length)
              for (var i = 0; i < message.pitchBends.length; ++i)
                $root.tensorflow.magenta.NoteSequence.PitchBend.encode(message.pitchBends[i], writer.uint32(
                  /* id 10, wireType 2 =*/
                  82
                ).fork()).ldelim();
            if (message.controlChanges != null && message.controlChanges.length)
              for (var i = 0; i < message.controlChanges.length; ++i)
                $root.tensorflow.magenta.NoteSequence.ControlChange.encode(message.controlChanges[i], writer.uint32(
                  /* id 11, wireType 2 =*/
                  90
                ).fork()).ldelim();
            if (message.partInfos != null && message.partInfos.length)
              for (var i = 0; i < message.partInfos.length; ++i)
                $root.tensorflow.magenta.NoteSequence.PartInfo.encode(message.partInfos[i], writer.uint32(
                  /* id 12, wireType 2 =*/
                  98
                ).fork()).ldelim();
            if (message.sourceInfo != null && message.hasOwnProperty("sourceInfo"))
              $root.tensorflow.magenta.NoteSequence.SourceInfo.encode(message.sourceInfo, writer.uint32(
                /* id 13, wireType 2 =*/
                106
              ).fork()).ldelim();
            if (message.textAnnotations != null && message.textAnnotations.length)
              for (var i = 0; i < message.textAnnotations.length; ++i)
                $root.tensorflow.magenta.NoteSequence.TextAnnotation.encode(message.textAnnotations[i], writer.uint32(
                  /* id 14, wireType 2 =*/
                  114
                ).fork()).ldelim();
            if (message.quantizationInfo != null && message.hasOwnProperty("quantizationInfo"))
              $root.tensorflow.magenta.NoteSequence.QuantizationInfo.encode(message.quantizationInfo, writer.uint32(
                /* id 15, wireType 2 =*/
                122
              ).fork()).ldelim();
            if (message.totalQuantizedSteps != null && message.hasOwnProperty("totalQuantizedSteps"))
              writer.uint32(
                /* id 16, wireType 0 =*/
                128
              ).int64(message.totalQuantizedSteps);
            if (message.subsequenceInfo != null && message.hasOwnProperty("subsequenceInfo"))
              $root.tensorflow.magenta.NoteSequence.SubsequenceInfo.encode(message.subsequenceInfo, writer.uint32(
                /* id 17, wireType 2 =*/
                138
              ).fork()).ldelim();
            if (message.referenceNumber != null && message.hasOwnProperty("referenceNumber"))
              writer.uint32(
                /* id 18, wireType 0 =*/
                144
              ).int64(message.referenceNumber);
            if (message.sequenceMetadata != null && message.hasOwnProperty("sequenceMetadata"))
              $root.tensorflow.magenta.SequenceMetadata.encode(message.sequenceMetadata, writer.uint32(
                /* id 19, wireType 2 =*/
                154
              ).fork()).ldelim();
            if (message.sectionAnnotations != null && message.sectionAnnotations.length)
              for (var i = 0; i < message.sectionAnnotations.length; ++i)
                $root.tensorflow.magenta.NoteSequence.SectionAnnotation.encode(message.sectionAnnotations[i], writer.uint32(
                  /* id 20, wireType 2 =*/
                  162
                ).fork()).ldelim();
            if (message.sectionGroups != null && message.sectionGroups.length)
              for (var i = 0; i < message.sectionGroups.length; ++i)
                $root.tensorflow.magenta.NoteSequence.SectionGroup.encode(message.sectionGroups[i], writer.uint32(
                  /* id 21, wireType 2 =*/
                  170
                ).fork()).ldelim();
            return writer;
          };
          NoteSequence2.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          NoteSequence2.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.tensorflow.magenta.NoteSequence();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.id = reader.string();
                  break;
                case 2:
                  message.filename = reader.string();
                  break;
                case 18:
                  message.referenceNumber = $util.Long ? reader.int64().toNumber() : reader.int64();
                  break;
                case 3:
                  message.collectionName = reader.string();
                  break;
                case 4:
                  message.ticksPerQuarter = reader.int32();
                  break;
                case 5:
                  if (!(message.timeSignatures && message.timeSignatures.length))
                    message.timeSignatures = [];
                  message.timeSignatures.push($root.tensorflow.magenta.NoteSequence.TimeSignature.decode(reader, reader.uint32()));
                  break;
                case 6:
                  if (!(message.keySignatures && message.keySignatures.length))
                    message.keySignatures = [];
                  message.keySignatures.push($root.tensorflow.magenta.NoteSequence.KeySignature.decode(reader, reader.uint32()));
                  break;
                case 7:
                  if (!(message.tempos && message.tempos.length))
                    message.tempos = [];
                  message.tempos.push($root.tensorflow.magenta.NoteSequence.Tempo.decode(reader, reader.uint32()));
                  break;
                case 8:
                  if (!(message.notes && message.notes.length))
                    message.notes = [];
                  message.notes.push($root.tensorflow.magenta.NoteSequence.Note.decode(reader, reader.uint32()));
                  break;
                case 9:
                  message.totalTime = reader.double();
                  break;
                case 16:
                  message.totalQuantizedSteps = $util.Long ? reader.int64().toNumber() : reader.int64();
                  break;
                case 10:
                  if (!(message.pitchBends && message.pitchBends.length))
                    message.pitchBends = [];
                  message.pitchBends.push($root.tensorflow.magenta.NoteSequence.PitchBend.decode(reader, reader.uint32()));
                  break;
                case 11:
                  if (!(message.controlChanges && message.controlChanges.length))
                    message.controlChanges = [];
                  message.controlChanges.push($root.tensorflow.magenta.NoteSequence.ControlChange.decode(reader, reader.uint32()));
                  break;
                case 12:
                  if (!(message.partInfos && message.partInfos.length))
                    message.partInfos = [];
                  message.partInfos.push($root.tensorflow.magenta.NoteSequence.PartInfo.decode(reader, reader.uint32()));
                  break;
                case 13:
                  message.sourceInfo = $root.tensorflow.magenta.NoteSequence.SourceInfo.decode(reader, reader.uint32());
                  break;
                case 14:
                  if (!(message.textAnnotations && message.textAnnotations.length))
                    message.textAnnotations = [];
                  message.textAnnotations.push($root.tensorflow.magenta.NoteSequence.TextAnnotation.decode(reader, reader.uint32()));
                  break;
                case 20:
                  if (!(message.sectionAnnotations && message.sectionAnnotations.length))
                    message.sectionAnnotations = [];
                  message.sectionAnnotations.push($root.tensorflow.magenta.NoteSequence.SectionAnnotation.decode(reader, reader.uint32()));
                  break;
                case 21:
                  if (!(message.sectionGroups && message.sectionGroups.length))
                    message.sectionGroups = [];
                  message.sectionGroups.push($root.tensorflow.magenta.NoteSequence.SectionGroup.decode(reader, reader.uint32()));
                  break;
                case 15:
                  message.quantizationInfo = $root.tensorflow.magenta.NoteSequence.QuantizationInfo.decode(reader, reader.uint32());
                  break;
                case 17:
                  message.subsequenceInfo = $root.tensorflow.magenta.NoteSequence.SubsequenceInfo.decode(reader, reader.uint32());
                  break;
                case 19:
                  message.sequenceMetadata = $root.tensorflow.magenta.SequenceMetadata.decode(reader, reader.uint32());
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          NoteSequence2.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          NoteSequence2.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.id != null && message.hasOwnProperty("id")) {
              if (!$util.isString(message.id))
                return "id: string expected";
            }
            if (message.filename != null && message.hasOwnProperty("filename")) {
              if (!$util.isString(message.filename))
                return "filename: string expected";
            }
            if (message.referenceNumber != null && message.hasOwnProperty("referenceNumber")) {
              if (!$util.isInteger(message.referenceNumber) && !(message.referenceNumber && $util.isInteger(message.referenceNumber.low) && $util.isInteger(message.referenceNumber.high)))
                return "referenceNumber: integer|Long expected";
            }
            if (message.collectionName != null && message.hasOwnProperty("collectionName")) {
              if (!$util.isString(message.collectionName))
                return "collectionName: string expected";
            }
            if (message.ticksPerQuarter != null && message.hasOwnProperty("ticksPerQuarter")) {
              if (!$util.isInteger(message.ticksPerQuarter))
                return "ticksPerQuarter: integer expected";
            }
            if (message.timeSignatures != null && message.hasOwnProperty("timeSignatures")) {
              if (!Array.isArray(message.timeSignatures))
                return "timeSignatures: array expected";
              for (var i = 0; i < message.timeSignatures.length; ++i) {
                var error = $root.tensorflow.magenta.NoteSequence.TimeSignature.verify(message.timeSignatures[i]);
                if (error)
                  return "timeSignatures." + error;
              }
            }
            if (message.keySignatures != null && message.hasOwnProperty("keySignatures")) {
              if (!Array.isArray(message.keySignatures))
                return "keySignatures: array expected";
              for (var i = 0; i < message.keySignatures.length; ++i) {
                var error = $root.tensorflow.magenta.NoteSequence.KeySignature.verify(message.keySignatures[i]);
                if (error)
                  return "keySignatures." + error;
              }
            }
            if (message.tempos != null && message.hasOwnProperty("tempos")) {
              if (!Array.isArray(message.tempos))
                return "tempos: array expected";
              for (var i = 0; i < message.tempos.length; ++i) {
                var error = $root.tensorflow.magenta.NoteSequence.Tempo.verify(message.tempos[i]);
                if (error)
                  return "tempos." + error;
              }
            }
            if (message.notes != null && message.hasOwnProperty("notes")) {
              if (!Array.isArray(message.notes))
                return "notes: array expected";
              for (var i = 0; i < message.notes.length; ++i) {
                var error = $root.tensorflow.magenta.NoteSequence.Note.verify(message.notes[i]);
                if (error)
                  return "notes." + error;
              }
            }
            if (message.totalTime != null && message.hasOwnProperty("totalTime")) {
              if (typeof message.totalTime !== "number")
                return "totalTime: number expected";
            }
            if (message.totalQuantizedSteps != null && message.hasOwnProperty("totalQuantizedSteps")) {
              if (!$util.isInteger(message.totalQuantizedSteps) && !(message.totalQuantizedSteps && $util.isInteger(message.totalQuantizedSteps.low) && $util.isInteger(message.totalQuantizedSteps.high)))
                return "totalQuantizedSteps: integer|Long expected";
            }
            if (message.pitchBends != null && message.hasOwnProperty("pitchBends")) {
              if (!Array.isArray(message.pitchBends))
                return "pitchBends: array expected";
              for (var i = 0; i < message.pitchBends.length; ++i) {
                var error = $root.tensorflow.magenta.NoteSequence.PitchBend.verify(message.pitchBends[i]);
                if (error)
                  return "pitchBends." + error;
              }
            }
            if (message.controlChanges != null && message.hasOwnProperty("controlChanges")) {
              if (!Array.isArray(message.controlChanges))
                return "controlChanges: array expected";
              for (var i = 0; i < message.controlChanges.length; ++i) {
                var error = $root.tensorflow.magenta.NoteSequence.ControlChange.verify(message.controlChanges[i]);
                if (error)
                  return "controlChanges." + error;
              }
            }
            if (message.partInfos != null && message.hasOwnProperty("partInfos")) {
              if (!Array.isArray(message.partInfos))
                return "partInfos: array expected";
              for (var i = 0; i < message.partInfos.length; ++i) {
                var error = $root.tensorflow.magenta.NoteSequence.PartInfo.verify(message.partInfos[i]);
                if (error)
                  return "partInfos." + error;
              }
            }
            if (message.sourceInfo != null && message.hasOwnProperty("sourceInfo")) {
              var error = $root.tensorflow.magenta.NoteSequence.SourceInfo.verify(message.sourceInfo);
              if (error)
                return "sourceInfo." + error;
            }
            if (message.textAnnotations != null && message.hasOwnProperty("textAnnotations")) {
              if (!Array.isArray(message.textAnnotations))
                return "textAnnotations: array expected";
              for (var i = 0; i < message.textAnnotations.length; ++i) {
                var error = $root.tensorflow.magenta.NoteSequence.TextAnnotation.verify(message.textAnnotations[i]);
                if (error)
                  return "textAnnotations." + error;
              }
            }
            if (message.sectionAnnotations != null && message.hasOwnProperty("sectionAnnotations")) {
              if (!Array.isArray(message.sectionAnnotations))
                return "sectionAnnotations: array expected";
              for (var i = 0; i < message.sectionAnnotations.length; ++i) {
                var error = $root.tensorflow.magenta.NoteSequence.SectionAnnotation.verify(message.sectionAnnotations[i]);
                if (error)
                  return "sectionAnnotations." + error;
              }
            }
            if (message.sectionGroups != null && message.hasOwnProperty("sectionGroups")) {
              if (!Array.isArray(message.sectionGroups))
                return "sectionGroups: array expected";
              for (var i = 0; i < message.sectionGroups.length; ++i) {
                var error = $root.tensorflow.magenta.NoteSequence.SectionGroup.verify(message.sectionGroups[i]);
                if (error)
                  return "sectionGroups." + error;
              }
            }
            if (message.quantizationInfo != null && message.hasOwnProperty("quantizationInfo")) {
              var error = $root.tensorflow.magenta.NoteSequence.QuantizationInfo.verify(message.quantizationInfo);
              if (error)
                return "quantizationInfo." + error;
            }
            if (message.subsequenceInfo != null && message.hasOwnProperty("subsequenceInfo")) {
              var error = $root.tensorflow.magenta.NoteSequence.SubsequenceInfo.verify(message.subsequenceInfo);
              if (error)
                return "subsequenceInfo." + error;
            }
            if (message.sequenceMetadata != null && message.hasOwnProperty("sequenceMetadata")) {
              var error = $root.tensorflow.magenta.SequenceMetadata.verify(message.sequenceMetadata);
              if (error)
                return "sequenceMetadata." + error;
            }
            return null;
          };
          NoteSequence2.fromObject = function fromObject(object) {
            if (object instanceof $root.tensorflow.magenta.NoteSequence)
              return object;
            var message = new $root.tensorflow.magenta.NoteSequence();
            if (object.id != null)
              message.id = String(object.id);
            if (object.filename != null)
              message.filename = String(object.filename);
            if (object.referenceNumber != null) {
              if ($util.Long)
                (message.referenceNumber = $util.Long.fromValue(object.referenceNumber)).unsigned = false;
              else if (typeof object.referenceNumber === "string")
                message.referenceNumber = parseInt(object.referenceNumber, 10);
              else if (typeof object.referenceNumber === "number")
                message.referenceNumber = object.referenceNumber;
              else if (typeof object.referenceNumber === "object")
                message.referenceNumber = new $util.LongBits(object.referenceNumber.low >>> 0, object.referenceNumber.high >>> 0).toNumber();
            }
            if (object.collectionName != null)
              message.collectionName = String(object.collectionName);
            if (object.ticksPerQuarter != null)
              message.ticksPerQuarter = object.ticksPerQuarter | 0;
            if (object.timeSignatures) {
              if (!Array.isArray(object.timeSignatures))
                throw TypeError(".tensorflow.magenta.NoteSequence.timeSignatures: array expected");
              message.timeSignatures = [];
              for (var i = 0; i < object.timeSignatures.length; ++i) {
                if (typeof object.timeSignatures[i] !== "object")
                  throw TypeError(".tensorflow.magenta.NoteSequence.timeSignatures: object expected");
                message.timeSignatures[i] = $root.tensorflow.magenta.NoteSequence.TimeSignature.fromObject(object.timeSignatures[i]);
              }
            }
            if (object.keySignatures) {
              if (!Array.isArray(object.keySignatures))
                throw TypeError(".tensorflow.magenta.NoteSequence.keySignatures: array expected");
              message.keySignatures = [];
              for (var i = 0; i < object.keySignatures.length; ++i) {
                if (typeof object.keySignatures[i] !== "object")
                  throw TypeError(".tensorflow.magenta.NoteSequence.keySignatures: object expected");
                message.keySignatures[i] = $root.tensorflow.magenta.NoteSequence.KeySignature.fromObject(object.keySignatures[i]);
              }
            }
            if (object.tempos) {
              if (!Array.isArray(object.tempos))
                throw TypeError(".tensorflow.magenta.NoteSequence.tempos: array expected");
              message.tempos = [];
              for (var i = 0; i < object.tempos.length; ++i) {
                if (typeof object.tempos[i] !== "object")
                  throw TypeError(".tensorflow.magenta.NoteSequence.tempos: object expected");
                message.tempos[i] = $root.tensorflow.magenta.NoteSequence.Tempo.fromObject(object.tempos[i]);
              }
            }
            if (object.notes) {
              if (!Array.isArray(object.notes))
                throw TypeError(".tensorflow.magenta.NoteSequence.notes: array expected");
              message.notes = [];
              for (var i = 0; i < object.notes.length; ++i) {
                if (typeof object.notes[i] !== "object")
                  throw TypeError(".tensorflow.magenta.NoteSequence.notes: object expected");
                message.notes[i] = $root.tensorflow.magenta.NoteSequence.Note.fromObject(object.notes[i]);
              }
            }
            if (object.totalTime != null)
              message.totalTime = Number(object.totalTime);
            if (object.totalQuantizedSteps != null) {
              if ($util.Long)
                (message.totalQuantizedSteps = $util.Long.fromValue(object.totalQuantizedSteps)).unsigned = false;
              else if (typeof object.totalQuantizedSteps === "string")
                message.totalQuantizedSteps = parseInt(object.totalQuantizedSteps, 10);
              else if (typeof object.totalQuantizedSteps === "number")
                message.totalQuantizedSteps = object.totalQuantizedSteps;
              else if (typeof object.totalQuantizedSteps === "object")
                message.totalQuantizedSteps = new $util.LongBits(object.totalQuantizedSteps.low >>> 0, object.totalQuantizedSteps.high >>> 0).toNumber();
            }
            if (object.pitchBends) {
              if (!Array.isArray(object.pitchBends))
                throw TypeError(".tensorflow.magenta.NoteSequence.pitchBends: array expected");
              message.pitchBends = [];
              for (var i = 0; i < object.pitchBends.length; ++i) {
                if (typeof object.pitchBends[i] !== "object")
                  throw TypeError(".tensorflow.magenta.NoteSequence.pitchBends: object expected");
                message.pitchBends[i] = $root.tensorflow.magenta.NoteSequence.PitchBend.fromObject(object.pitchBends[i]);
              }
            }
            if (object.controlChanges) {
              if (!Array.isArray(object.controlChanges))
                throw TypeError(".tensorflow.magenta.NoteSequence.controlChanges: array expected");
              message.controlChanges = [];
              for (var i = 0; i < object.controlChanges.length; ++i) {
                if (typeof object.controlChanges[i] !== "object")
                  throw TypeError(".tensorflow.magenta.NoteSequence.controlChanges: object expected");
                message.controlChanges[i] = $root.tensorflow.magenta.NoteSequence.ControlChange.fromObject(object.controlChanges[i]);
              }
            }
            if (object.partInfos) {
              if (!Array.isArray(object.partInfos))
                throw TypeError(".tensorflow.magenta.NoteSequence.partInfos: array expected");
              message.partInfos = [];
              for (var i = 0; i < object.partInfos.length; ++i) {
                if (typeof object.partInfos[i] !== "object")
                  throw TypeError(".tensorflow.magenta.NoteSequence.partInfos: object expected");
                message.partInfos[i] = $root.tensorflow.magenta.NoteSequence.PartInfo.fromObject(object.partInfos[i]);
              }
            }
            if (object.sourceInfo != null) {
              if (typeof object.sourceInfo !== "object")
                throw TypeError(".tensorflow.magenta.NoteSequence.sourceInfo: object expected");
              message.sourceInfo = $root.tensorflow.magenta.NoteSequence.SourceInfo.fromObject(object.sourceInfo);
            }
            if (object.textAnnotations) {
              if (!Array.isArray(object.textAnnotations))
                throw TypeError(".tensorflow.magenta.NoteSequence.textAnnotations: array expected");
              message.textAnnotations = [];
              for (var i = 0; i < object.textAnnotations.length; ++i) {
                if (typeof object.textAnnotations[i] !== "object")
                  throw TypeError(".tensorflow.magenta.NoteSequence.textAnnotations: object expected");
                message.textAnnotations[i] = $root.tensorflow.magenta.NoteSequence.TextAnnotation.fromObject(object.textAnnotations[i]);
              }
            }
            if (object.sectionAnnotations) {
              if (!Array.isArray(object.sectionAnnotations))
                throw TypeError(".tensorflow.magenta.NoteSequence.sectionAnnotations: array expected");
              message.sectionAnnotations = [];
              for (var i = 0; i < object.sectionAnnotations.length; ++i) {
                if (typeof object.sectionAnnotations[i] !== "object")
                  throw TypeError(".tensorflow.magenta.NoteSequence.sectionAnnotations: object expected");
                message.sectionAnnotations[i] = $root.tensorflow.magenta.NoteSequence.SectionAnnotation.fromObject(object.sectionAnnotations[i]);
              }
            }
            if (object.sectionGroups) {
              if (!Array.isArray(object.sectionGroups))
                throw TypeError(".tensorflow.magenta.NoteSequence.sectionGroups: array expected");
              message.sectionGroups = [];
              for (var i = 0; i < object.sectionGroups.length; ++i) {
                if (typeof object.sectionGroups[i] !== "object")
                  throw TypeError(".tensorflow.magenta.NoteSequence.sectionGroups: object expected");
                message.sectionGroups[i] = $root.tensorflow.magenta.NoteSequence.SectionGroup.fromObject(object.sectionGroups[i]);
              }
            }
            if (object.quantizationInfo != null) {
              if (typeof object.quantizationInfo !== "object")
                throw TypeError(".tensorflow.magenta.NoteSequence.quantizationInfo: object expected");
              message.quantizationInfo = $root.tensorflow.magenta.NoteSequence.QuantizationInfo.fromObject(object.quantizationInfo);
            }
            if (object.subsequenceInfo != null) {
              if (typeof object.subsequenceInfo !== "object")
                throw TypeError(".tensorflow.magenta.NoteSequence.subsequenceInfo: object expected");
              message.subsequenceInfo = $root.tensorflow.magenta.NoteSequence.SubsequenceInfo.fromObject(object.subsequenceInfo);
            }
            if (object.sequenceMetadata != null) {
              if (typeof object.sequenceMetadata !== "object")
                throw TypeError(".tensorflow.magenta.NoteSequence.sequenceMetadata: object expected");
              message.sequenceMetadata = $root.tensorflow.magenta.SequenceMetadata.fromObject(object.sequenceMetadata);
            }
            return message;
          };
          NoteSequence2.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults) {
              object.timeSignatures = [];
              object.keySignatures = [];
              object.tempos = [];
              object.notes = [];
              object.pitchBends = [];
              object.controlChanges = [];
              object.partInfos = [];
              object.textAnnotations = [];
              object.sectionAnnotations = [];
              object.sectionGroups = [];
            }
            if (options.defaults) {
              object.id = "";
              object.filename = "";
              object.collectionName = "";
              object.ticksPerQuarter = 0;
              object.totalTime = 0;
              object.sourceInfo = null;
              object.quantizationInfo = null;
              if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.totalQuantizedSteps = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else
                object.totalQuantizedSteps = options.longs === String ? "0" : 0;
              object.subsequenceInfo = null;
              if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.referenceNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else
                object.referenceNumber = options.longs === String ? "0" : 0;
              object.sequenceMetadata = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
              object.id = message.id;
            if (message.filename != null && message.hasOwnProperty("filename"))
              object.filename = message.filename;
            if (message.collectionName != null && message.hasOwnProperty("collectionName"))
              object.collectionName = message.collectionName;
            if (message.ticksPerQuarter != null && message.hasOwnProperty("ticksPerQuarter"))
              object.ticksPerQuarter = message.ticksPerQuarter;
            if (message.timeSignatures && message.timeSignatures.length) {
              object.timeSignatures = [];
              for (var j = 0; j < message.timeSignatures.length; ++j)
                object.timeSignatures[j] = $root.tensorflow.magenta.NoteSequence.TimeSignature.toObject(message.timeSignatures[j], options);
            }
            if (message.keySignatures && message.keySignatures.length) {
              object.keySignatures = [];
              for (var j = 0; j < message.keySignatures.length; ++j)
                object.keySignatures[j] = $root.tensorflow.magenta.NoteSequence.KeySignature.toObject(message.keySignatures[j], options);
            }
            if (message.tempos && message.tempos.length) {
              object.tempos = [];
              for (var j = 0; j < message.tempos.length; ++j)
                object.tempos[j] = $root.tensorflow.magenta.NoteSequence.Tempo.toObject(message.tempos[j], options);
            }
            if (message.notes && message.notes.length) {
              object.notes = [];
              for (var j = 0; j < message.notes.length; ++j)
                object.notes[j] = $root.tensorflow.magenta.NoteSequence.Note.toObject(message.notes[j], options);
            }
            if (message.totalTime != null && message.hasOwnProperty("totalTime"))
              object.totalTime = options.json && !isFinite(message.totalTime) ? String(message.totalTime) : message.totalTime;
            if (message.pitchBends && message.pitchBends.length) {
              object.pitchBends = [];
              for (var j = 0; j < message.pitchBends.length; ++j)
                object.pitchBends[j] = $root.tensorflow.magenta.NoteSequence.PitchBend.toObject(message.pitchBends[j], options);
            }
            if (message.controlChanges && message.controlChanges.length) {
              object.controlChanges = [];
              for (var j = 0; j < message.controlChanges.length; ++j)
                object.controlChanges[j] = $root.tensorflow.magenta.NoteSequence.ControlChange.toObject(message.controlChanges[j], options);
            }
            if (message.partInfos && message.partInfos.length) {
              object.partInfos = [];
              for (var j = 0; j < message.partInfos.length; ++j)
                object.partInfos[j] = $root.tensorflow.magenta.NoteSequence.PartInfo.toObject(message.partInfos[j], options);
            }
            if (message.sourceInfo != null && message.hasOwnProperty("sourceInfo"))
              object.sourceInfo = $root.tensorflow.magenta.NoteSequence.SourceInfo.toObject(message.sourceInfo, options);
            if (message.textAnnotations && message.textAnnotations.length) {
              object.textAnnotations = [];
              for (var j = 0; j < message.textAnnotations.length; ++j)
                object.textAnnotations[j] = $root.tensorflow.magenta.NoteSequence.TextAnnotation.toObject(message.textAnnotations[j], options);
            }
            if (message.quantizationInfo != null && message.hasOwnProperty("quantizationInfo"))
              object.quantizationInfo = $root.tensorflow.magenta.NoteSequence.QuantizationInfo.toObject(message.quantizationInfo, options);
            if (message.totalQuantizedSteps != null && message.hasOwnProperty("totalQuantizedSteps"))
              if (typeof message.totalQuantizedSteps === "number")
                object.totalQuantizedSteps = options.longs === String ? String(message.totalQuantizedSteps) : message.totalQuantizedSteps;
              else
                object.totalQuantizedSteps = options.longs === String ? $util.Long.prototype.toString.call(message.totalQuantizedSteps) : options.longs === Number ? new $util.LongBits(message.totalQuantizedSteps.low >>> 0, message.totalQuantizedSteps.high >>> 0).toNumber() : message.totalQuantizedSteps;
            if (message.subsequenceInfo != null && message.hasOwnProperty("subsequenceInfo"))
              object.subsequenceInfo = $root.tensorflow.magenta.NoteSequence.SubsequenceInfo.toObject(message.subsequenceInfo, options);
            if (message.referenceNumber != null && message.hasOwnProperty("referenceNumber"))
              if (typeof message.referenceNumber === "number")
                object.referenceNumber = options.longs === String ? String(message.referenceNumber) : message.referenceNumber;
              else
                object.referenceNumber = options.longs === String ? $util.Long.prototype.toString.call(message.referenceNumber) : options.longs === Number ? new $util.LongBits(message.referenceNumber.low >>> 0, message.referenceNumber.high >>> 0).toNumber() : message.referenceNumber;
            if (message.sequenceMetadata != null && message.hasOwnProperty("sequenceMetadata"))
              object.sequenceMetadata = $root.tensorflow.magenta.SequenceMetadata.toObject(message.sequenceMetadata, options);
            if (message.sectionAnnotations && message.sectionAnnotations.length) {
              object.sectionAnnotations = [];
              for (var j = 0; j < message.sectionAnnotations.length; ++j)
                object.sectionAnnotations[j] = $root.tensorflow.magenta.NoteSequence.SectionAnnotation.toObject(message.sectionAnnotations[j], options);
            }
            if (message.sectionGroups && message.sectionGroups.length) {
              object.sectionGroups = [];
              for (var j = 0; j < message.sectionGroups.length; ++j)
                object.sectionGroups[j] = $root.tensorflow.magenta.NoteSequence.SectionGroup.toObject(message.sectionGroups[j], options);
            }
            return object;
          };
          NoteSequence2.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          NoteSequence2.Note = (function() {
            function Note(properties) {
              if (properties) {
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            Note.prototype.pitch = 0;
            Note.prototype.pitchName = 0;
            Note.prototype.velocity = 0;
            Note.prototype.startTime = 0;
            Note.prototype.quantizedStartStep = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            Note.prototype.endTime = 0;
            Note.prototype.quantizedEndStep = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            Note.prototype.numerator = 0;
            Note.prototype.denominator = 0;
            Note.prototype.instrument = 0;
            Note.prototype.program = 0;
            Note.prototype.isDrum = false;
            Note.prototype.part = 0;
            Note.prototype.voice = 0;
            Note.create = function create(properties) {
              return new Note(properties);
            };
            Note.encode = function encode(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.pitch != null && message.hasOwnProperty("pitch"))
                writer.uint32(
                  /* id 1, wireType 0 =*/
                  8
                ).int32(message.pitch);
              if (message.velocity != null && message.hasOwnProperty("velocity"))
                writer.uint32(
                  /* id 2, wireType 0 =*/
                  16
                ).int32(message.velocity);
              if (message.startTime != null && message.hasOwnProperty("startTime"))
                writer.uint32(
                  /* id 3, wireType 1 =*/
                  25
                ).double(message.startTime);
              if (message.endTime != null && message.hasOwnProperty("endTime"))
                writer.uint32(
                  /* id 4, wireType 1 =*/
                  33
                ).double(message.endTime);
              if (message.numerator != null && message.hasOwnProperty("numerator"))
                writer.uint32(
                  /* id 5, wireType 0 =*/
                  40
                ).int32(message.numerator);
              if (message.denominator != null && message.hasOwnProperty("denominator"))
                writer.uint32(
                  /* id 6, wireType 0 =*/
                  48
                ).int32(message.denominator);
              if (message.instrument != null && message.hasOwnProperty("instrument"))
                writer.uint32(
                  /* id 7, wireType 0 =*/
                  56
                ).int32(message.instrument);
              if (message.program != null && message.hasOwnProperty("program"))
                writer.uint32(
                  /* id 8, wireType 0 =*/
                  64
                ).int32(message.program);
              if (message.isDrum != null && message.hasOwnProperty("isDrum"))
                writer.uint32(
                  /* id 9, wireType 0 =*/
                  72
                ).bool(message.isDrum);
              if (message.part != null && message.hasOwnProperty("part"))
                writer.uint32(
                  /* id 10, wireType 0 =*/
                  80
                ).int32(message.part);
              if (message.pitchName != null && message.hasOwnProperty("pitchName"))
                writer.uint32(
                  /* id 11, wireType 0 =*/
                  88
                ).int32(message.pitchName);
              if (message.voice != null && message.hasOwnProperty("voice"))
                writer.uint32(
                  /* id 12, wireType 0 =*/
                  96
                ).int32(message.voice);
              if (message.quantizedStartStep != null && message.hasOwnProperty("quantizedStartStep"))
                writer.uint32(
                  /* id 13, wireType 0 =*/
                  104
                ).int64(message.quantizedStartStep);
              if (message.quantizedEndStep != null && message.hasOwnProperty("quantizedEndStep"))
                writer.uint32(
                  /* id 14, wireType 0 =*/
                  112
                ).int64(message.quantizedEndStep);
              return writer;
            };
            Note.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            Note.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.tensorflow.magenta.NoteSequence.Note();
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1:
                    message.pitch = reader.int32();
                    break;
                  case 11:
                    message.pitchName = reader.int32();
                    break;
                  case 2:
                    message.velocity = reader.int32();
                    break;
                  case 3:
                    message.startTime = reader.double();
                    break;
                  case 13:
                    message.quantizedStartStep = $util.Long ? reader.int64().toNumber() : reader.int64();
                    break;
                  case 4:
                    message.endTime = reader.double();
                    break;
                  case 14:
                    message.quantizedEndStep = $util.Long ? reader.int64().toNumber() : reader.int64();
                    break;
                  case 5:
                    message.numerator = reader.int32();
                    break;
                  case 6:
                    message.denominator = reader.int32();
                    break;
                  case 7:
                    message.instrument = reader.int32();
                    break;
                  case 8:
                    message.program = reader.int32();
                    break;
                  case 9:
                    message.isDrum = reader.bool();
                    break;
                  case 10:
                    message.part = reader.int32();
                    break;
                  case 12:
                    message.voice = reader.int32();
                    break;
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            Note.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            Note.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.pitch != null && message.hasOwnProperty("pitch")) {
                if (!$util.isInteger(message.pitch))
                  return "pitch: integer expected";
              }
              if (message.pitchName != null && message.hasOwnProperty("pitchName"))
                switch (message.pitchName) {
                  default:
                    return "pitchName: enum value expected";
                  case 0:
                  case 1:
                  case 2:
                  case 3:
                  case 4:
                  case 5:
                  case 6:
                  case 7:
                  case 8:
                  case 9:
                  case 10:
                  case 11:
                  case 12:
                  case 13:
                  case 14:
                  case 15:
                  case 16:
                  case 17:
                  case 18:
                  case 19:
                  case 20:
                  case 21:
                  case 22:
                  case 23:
                  case 24:
                  case 25:
                  case 26:
                  case 27:
                  case 28:
                  case 29:
                  case 30:
                  case 31:
                  case 32:
                  case 33:
                  case 34:
                  case 35:
                    break;
                }
              if (message.velocity != null && message.hasOwnProperty("velocity")) {
                if (!$util.isInteger(message.velocity))
                  return "velocity: integer expected";
              }
              if (message.startTime != null && message.hasOwnProperty("startTime")) {
                if (typeof message.startTime !== "number")
                  return "startTime: number expected";
              }
              if (message.quantizedStartStep != null && message.hasOwnProperty("quantizedStartStep")) {
                if (!$util.isInteger(message.quantizedStartStep) && !(message.quantizedStartStep && $util.isInteger(message.quantizedStartStep.low) && $util.isInteger(message.quantizedStartStep.high)))
                  return "quantizedStartStep: integer|Long expected";
              }
              if (message.endTime != null && message.hasOwnProperty("endTime")) {
                if (typeof message.endTime !== "number")
                  return "endTime: number expected";
              }
              if (message.quantizedEndStep != null && message.hasOwnProperty("quantizedEndStep")) {
                if (!$util.isInteger(message.quantizedEndStep) && !(message.quantizedEndStep && $util.isInteger(message.quantizedEndStep.low) && $util.isInteger(message.quantizedEndStep.high)))
                  return "quantizedEndStep: integer|Long expected";
              }
              if (message.numerator != null && message.hasOwnProperty("numerator")) {
                if (!$util.isInteger(message.numerator))
                  return "numerator: integer expected";
              }
              if (message.denominator != null && message.hasOwnProperty("denominator")) {
                if (!$util.isInteger(message.denominator))
                  return "denominator: integer expected";
              }
              if (message.instrument != null && message.hasOwnProperty("instrument")) {
                if (!$util.isInteger(message.instrument))
                  return "instrument: integer expected";
              }
              if (message.program != null && message.hasOwnProperty("program")) {
                if (!$util.isInteger(message.program))
                  return "program: integer expected";
              }
              if (message.isDrum != null && message.hasOwnProperty("isDrum")) {
                if (typeof message.isDrum !== "boolean")
                  return "isDrum: boolean expected";
              }
              if (message.part != null && message.hasOwnProperty("part")) {
                if (!$util.isInteger(message.part))
                  return "part: integer expected";
              }
              if (message.voice != null && message.hasOwnProperty("voice")) {
                if (!$util.isInteger(message.voice))
                  return "voice: integer expected";
              }
              return null;
            };
            Note.fromObject = function fromObject(object) {
              if (object instanceof $root.tensorflow.magenta.NoteSequence.Note)
                return object;
              var message = new $root.tensorflow.magenta.NoteSequence.Note();
              if (object.pitch != null)
                message.pitch = object.pitch | 0;
              switch (object.pitchName) {
                case "UNKNOWN_PITCH_NAME":
                case 0:
                  message.pitchName = 0;
                  break;
                case "F_FLAT_FLAT":
                case 1:
                  message.pitchName = 1;
                  break;
                case "C_FLAT_FLAT":
                case 2:
                  message.pitchName = 2;
                  break;
                case "G_FLAT_FLAT":
                case 3:
                  message.pitchName = 3;
                  break;
                case "D_FLAT_FLAT":
                case 4:
                  message.pitchName = 4;
                  break;
                case "A_FLAT_FLAT":
                case 5:
                  message.pitchName = 5;
                  break;
                case "E_FLAT_FLAT":
                case 6:
                  message.pitchName = 6;
                  break;
                case "B_FLAT_FLAT":
                case 7:
                  message.pitchName = 7;
                  break;
                case "F_FLAT":
                case 8:
                  message.pitchName = 8;
                  break;
                case "C_FLAT":
                case 9:
                  message.pitchName = 9;
                  break;
                case "G_FLAT":
                case 10:
                  message.pitchName = 10;
                  break;
                case "D_FLAT":
                case 11:
                  message.pitchName = 11;
                  break;
                case "A_FLAT":
                case 12:
                  message.pitchName = 12;
                  break;
                case "E_FLAT":
                case 13:
                  message.pitchName = 13;
                  break;
                case "B_FLAT":
                case 14:
                  message.pitchName = 14;
                  break;
                case "F":
                case 15:
                  message.pitchName = 15;
                  break;
                case "C":
                case 16:
                  message.pitchName = 16;
                  break;
                case "G":
                case 17:
                  message.pitchName = 17;
                  break;
                case "D":
                case 18:
                  message.pitchName = 18;
                  break;
                case "A":
                case 19:
                  message.pitchName = 19;
                  break;
                case "E":
                case 20:
                  message.pitchName = 20;
                  break;
                case "B":
                case 21:
                  message.pitchName = 21;
                  break;
                case "F_SHARP":
                case 22:
                  message.pitchName = 22;
                  break;
                case "C_SHARP":
                case 23:
                  message.pitchName = 23;
                  break;
                case "G_SHARP":
                case 24:
                  message.pitchName = 24;
                  break;
                case "D_SHARP":
                case 25:
                  message.pitchName = 25;
                  break;
                case "A_SHARP":
                case 26:
                  message.pitchName = 26;
                  break;
                case "E_SHARP":
                case 27:
                  message.pitchName = 27;
                  break;
                case "B_SHARP":
                case 28:
                  message.pitchName = 28;
                  break;
                case "F_SHARP_SHARP":
                case 29:
                  message.pitchName = 29;
                  break;
                case "C_SHARP_SHARP":
                case 30:
                  message.pitchName = 30;
                  break;
                case "G_SHARP_SHARP":
                case 31:
                  message.pitchName = 31;
                  break;
                case "D_SHARP_SHARP":
                case 32:
                  message.pitchName = 32;
                  break;
                case "A_SHARP_SHARP":
                case 33:
                  message.pitchName = 33;
                  break;
                case "E_SHARP_SHARP":
                case 34:
                  message.pitchName = 34;
                  break;
                case "B_SHARP_SHARP":
                case 35:
                  message.pitchName = 35;
                  break;
              }
              if (object.velocity != null)
                message.velocity = object.velocity | 0;
              if (object.startTime != null)
                message.startTime = Number(object.startTime);
              if (object.quantizedStartStep != null) {
                if ($util.Long)
                  (message.quantizedStartStep = $util.Long.fromValue(object.quantizedStartStep)).unsigned = false;
                else if (typeof object.quantizedStartStep === "string")
                  message.quantizedStartStep = parseInt(object.quantizedStartStep, 10);
                else if (typeof object.quantizedStartStep === "number")
                  message.quantizedStartStep = object.quantizedStartStep;
                else if (typeof object.quantizedStartStep === "object")
                  message.quantizedStartStep = new $util.LongBits(object.quantizedStartStep.low >>> 0, object.quantizedStartStep.high >>> 0).toNumber();
              }
              if (object.endTime != null)
                message.endTime = Number(object.endTime);
              if (object.quantizedEndStep != null) {
                if ($util.Long)
                  (message.quantizedEndStep = $util.Long.fromValue(object.quantizedEndStep)).unsigned = false;
                else if (typeof object.quantizedEndStep === "string")
                  message.quantizedEndStep = parseInt(object.quantizedEndStep, 10);
                else if (typeof object.quantizedEndStep === "number")
                  message.quantizedEndStep = object.quantizedEndStep;
                else if (typeof object.quantizedEndStep === "object")
                  message.quantizedEndStep = new $util.LongBits(object.quantizedEndStep.low >>> 0, object.quantizedEndStep.high >>> 0).toNumber();
              }
              if (object.numerator != null)
                message.numerator = object.numerator | 0;
              if (object.denominator != null)
                message.denominator = object.denominator | 0;
              if (object.instrument != null)
                message.instrument = object.instrument | 0;
              if (object.program != null)
                message.program = object.program | 0;
              if (object.isDrum != null)
                message.isDrum = Boolean(object.isDrum);
              if (object.part != null)
                message.part = object.part | 0;
              if (object.voice != null)
                message.voice = object.voice | 0;
              return message;
            };
            Note.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (options.defaults) {
                object.pitch = 0;
                object.velocity = 0;
                object.startTime = 0;
                object.endTime = 0;
                object.numerator = 0;
                object.denominator = 0;
                object.instrument = 0;
                object.program = 0;
                object.isDrum = false;
                object.part = 0;
                object.pitchName = options.enums === String ? "UNKNOWN_PITCH_NAME" : 0;
                object.voice = 0;
                if ($util.Long) {
                  var long = new $util.Long(0, 0, false);
                  object.quantizedStartStep = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                  object.quantizedStartStep = options.longs === String ? "0" : 0;
                if ($util.Long) {
                  var long = new $util.Long(0, 0, false);
                  object.quantizedEndStep = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                  object.quantizedEndStep = options.longs === String ? "0" : 0;
              }
              if (message.pitch != null && message.hasOwnProperty("pitch"))
                object.pitch = message.pitch;
              if (message.velocity != null && message.hasOwnProperty("velocity"))
                object.velocity = message.velocity;
              if (message.startTime != null && message.hasOwnProperty("startTime"))
                object.startTime = options.json && !isFinite(message.startTime) ? String(message.startTime) : message.startTime;
              if (message.endTime != null && message.hasOwnProperty("endTime"))
                object.endTime = options.json && !isFinite(message.endTime) ? String(message.endTime) : message.endTime;
              if (message.numerator != null && message.hasOwnProperty("numerator"))
                object.numerator = message.numerator;
              if (message.denominator != null && message.hasOwnProperty("denominator"))
                object.denominator = message.denominator;
              if (message.instrument != null && message.hasOwnProperty("instrument"))
                object.instrument = message.instrument;
              if (message.program != null && message.hasOwnProperty("program"))
                object.program = message.program;
              if (message.isDrum != null && message.hasOwnProperty("isDrum"))
                object.isDrum = message.isDrum;
              if (message.part != null && message.hasOwnProperty("part"))
                object.part = message.part;
              if (message.pitchName != null && message.hasOwnProperty("pitchName"))
                object.pitchName = options.enums === String ? $root.tensorflow.magenta.NoteSequence.PitchName[message.pitchName] : message.pitchName;
              if (message.voice != null && message.hasOwnProperty("voice"))
                object.voice = message.voice;
              if (message.quantizedStartStep != null && message.hasOwnProperty("quantizedStartStep"))
                if (typeof message.quantizedStartStep === "number")
                  object.quantizedStartStep = options.longs === String ? String(message.quantizedStartStep) : message.quantizedStartStep;
                else
                  object.quantizedStartStep = options.longs === String ? $util.Long.prototype.toString.call(message.quantizedStartStep) : options.longs === Number ? new $util.LongBits(message.quantizedStartStep.low >>> 0, message.quantizedStartStep.high >>> 0).toNumber() : message.quantizedStartStep;
              if (message.quantizedEndStep != null && message.hasOwnProperty("quantizedEndStep"))
                if (typeof message.quantizedEndStep === "number")
                  object.quantizedEndStep = options.longs === String ? String(message.quantizedEndStep) : message.quantizedEndStep;
                else
                  object.quantizedEndStep = options.longs === String ? $util.Long.prototype.toString.call(message.quantizedEndStep) : options.longs === Number ? new $util.LongBits(message.quantizedEndStep.low >>> 0, message.quantizedEndStep.high >>> 0).toNumber() : message.quantizedEndStep;
              return object;
            };
            Note.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return Note;
          })();
          NoteSequence2.PitchName = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_PITCH_NAME"] = 0;
            values[valuesById[1] = "F_FLAT_FLAT"] = 1;
            values[valuesById[2] = "C_FLAT_FLAT"] = 2;
            values[valuesById[3] = "G_FLAT_FLAT"] = 3;
            values[valuesById[4] = "D_FLAT_FLAT"] = 4;
            values[valuesById[5] = "A_FLAT_FLAT"] = 5;
            values[valuesById[6] = "E_FLAT_FLAT"] = 6;
            values[valuesById[7] = "B_FLAT_FLAT"] = 7;
            values[valuesById[8] = "F_FLAT"] = 8;
            values[valuesById[9] = "C_FLAT"] = 9;
            values[valuesById[10] = "G_FLAT"] = 10;
            values[valuesById[11] = "D_FLAT"] = 11;
            values[valuesById[12] = "A_FLAT"] = 12;
            values[valuesById[13] = "E_FLAT"] = 13;
            values[valuesById[14] = "B_FLAT"] = 14;
            values[valuesById[15] = "F"] = 15;
            values[valuesById[16] = "C"] = 16;
            values[valuesById[17] = "G"] = 17;
            values[valuesById[18] = "D"] = 18;
            values[valuesById[19] = "A"] = 19;
            values[valuesById[20] = "E"] = 20;
            values[valuesById[21] = "B"] = 21;
            values[valuesById[22] = "F_SHARP"] = 22;
            values[valuesById[23] = "C_SHARP"] = 23;
            values[valuesById[24] = "G_SHARP"] = 24;
            values[valuesById[25] = "D_SHARP"] = 25;
            values[valuesById[26] = "A_SHARP"] = 26;
            values[valuesById[27] = "E_SHARP"] = 27;
            values[valuesById[28] = "B_SHARP"] = 28;
            values[valuesById[29] = "F_SHARP_SHARP"] = 29;
            values[valuesById[30] = "C_SHARP_SHARP"] = 30;
            values[valuesById[31] = "G_SHARP_SHARP"] = 31;
            values[valuesById[32] = "D_SHARP_SHARP"] = 32;
            values[valuesById[33] = "A_SHARP_SHARP"] = 33;
            values[valuesById[34] = "E_SHARP_SHARP"] = 34;
            values[valuesById[35] = "B_SHARP_SHARP"] = 35;
            return values;
          })();
          NoteSequence2.TimeSignature = (function() {
            function TimeSignature(properties) {
              if (properties) {
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            TimeSignature.prototype.time = 0;
            TimeSignature.prototype.numerator = 0;
            TimeSignature.prototype.denominator = 0;
            TimeSignature.create = function create(properties) {
              return new TimeSignature(properties);
            };
            TimeSignature.encode = function encode(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.time != null && message.hasOwnProperty("time"))
                writer.uint32(
                  /* id 1, wireType 1 =*/
                  9
                ).double(message.time);
              if (message.numerator != null && message.hasOwnProperty("numerator"))
                writer.uint32(
                  /* id 2, wireType 0 =*/
                  16
                ).int32(message.numerator);
              if (message.denominator != null && message.hasOwnProperty("denominator"))
                writer.uint32(
                  /* id 3, wireType 0 =*/
                  24
                ).int32(message.denominator);
              return writer;
            };
            TimeSignature.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            TimeSignature.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.tensorflow.magenta.NoteSequence.TimeSignature();
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1:
                    message.time = reader.double();
                    break;
                  case 2:
                    message.numerator = reader.int32();
                    break;
                  case 3:
                    message.denominator = reader.int32();
                    break;
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            TimeSignature.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            TimeSignature.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.time != null && message.hasOwnProperty("time")) {
                if (typeof message.time !== "number")
                  return "time: number expected";
              }
              if (message.numerator != null && message.hasOwnProperty("numerator")) {
                if (!$util.isInteger(message.numerator))
                  return "numerator: integer expected";
              }
              if (message.denominator != null && message.hasOwnProperty("denominator")) {
                if (!$util.isInteger(message.denominator))
                  return "denominator: integer expected";
              }
              return null;
            };
            TimeSignature.fromObject = function fromObject(object) {
              if (object instanceof $root.tensorflow.magenta.NoteSequence.TimeSignature)
                return object;
              var message = new $root.tensorflow.magenta.NoteSequence.TimeSignature();
              if (object.time != null)
                message.time = Number(object.time);
              if (object.numerator != null)
                message.numerator = object.numerator | 0;
              if (object.denominator != null)
                message.denominator = object.denominator | 0;
              return message;
            };
            TimeSignature.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (options.defaults) {
                object.time = 0;
                object.numerator = 0;
                object.denominator = 0;
              }
              if (message.time != null && message.hasOwnProperty("time"))
                object.time = options.json && !isFinite(message.time) ? String(message.time) : message.time;
              if (message.numerator != null && message.hasOwnProperty("numerator"))
                object.numerator = message.numerator;
              if (message.denominator != null && message.hasOwnProperty("denominator"))
                object.denominator = message.denominator;
              return object;
            };
            TimeSignature.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return TimeSignature;
          })();
          NoteSequence2.KeySignature = (function() {
            function KeySignature(properties) {
              if (properties) {
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            KeySignature.prototype.time = 0;
            KeySignature.prototype.key = 0;
            KeySignature.prototype.mode = 0;
            KeySignature.create = function create(properties) {
              return new KeySignature(properties);
            };
            KeySignature.encode = function encode(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.time != null && message.hasOwnProperty("time"))
                writer.uint32(
                  /* id 1, wireType 1 =*/
                  9
                ).double(message.time);
              if (message.key != null && message.hasOwnProperty("key"))
                writer.uint32(
                  /* id 2, wireType 0 =*/
                  16
                ).int32(message.key);
              if (message.mode != null && message.hasOwnProperty("mode"))
                writer.uint32(
                  /* id 3, wireType 0 =*/
                  24
                ).int32(message.mode);
              return writer;
            };
            KeySignature.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            KeySignature.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.tensorflow.magenta.NoteSequence.KeySignature();
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1:
                    message.time = reader.double();
                    break;
                  case 2:
                    message.key = reader.int32();
                    break;
                  case 3:
                    message.mode = reader.int32();
                    break;
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            KeySignature.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            KeySignature.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.time != null && message.hasOwnProperty("time")) {
                if (typeof message.time !== "number")
                  return "time: number expected";
              }
              if (message.key != null && message.hasOwnProperty("key"))
                switch (message.key) {
                  default:
                    return "key: enum value expected";
                  case 0:
                  case 1:
                  case 1:
                  case 2:
                  case 3:
                  case 3:
                  case 4:
                  case 5:
                  case 6:
                  case 6:
                  case 7:
                  case 8:
                  case 8:
                  case 9:
                  case 10:
                  case 10:
                  case 11:
                    break;
                }
              if (message.mode != null && message.hasOwnProperty("mode"))
                switch (message.mode) {
                  default:
                    return "mode: enum value expected";
                  case 0:
                  case 1:
                  case 2:
                  case 3:
                  case 4:
                  case 5:
                  case 6:
                  case 7:
                    break;
                }
              return null;
            };
            KeySignature.fromObject = function fromObject(object) {
              if (object instanceof $root.tensorflow.magenta.NoteSequence.KeySignature)
                return object;
              var message = new $root.tensorflow.magenta.NoteSequence.KeySignature();
              if (object.time != null)
                message.time = Number(object.time);
              switch (object.key) {
                case "C":
                case 0:
                  message.key = 0;
                  break;
                case "C_SHARP":
                case 1:
                  message.key = 1;
                  break;
                case "D_FLAT":
                case 1:
                  message.key = 1;
                  break;
                case "D":
                case 2:
                  message.key = 2;
                  break;
                case "D_SHARP":
                case 3:
                  message.key = 3;
                  break;
                case "E_FLAT":
                case 3:
                  message.key = 3;
                  break;
                case "E":
                case 4:
                  message.key = 4;
                  break;
                case "F":
                case 5:
                  message.key = 5;
                  break;
                case "F_SHARP":
                case 6:
                  message.key = 6;
                  break;
                case "G_FLAT":
                case 6:
                  message.key = 6;
                  break;
                case "G":
                case 7:
                  message.key = 7;
                  break;
                case "G_SHARP":
                case 8:
                  message.key = 8;
                  break;
                case "A_FLAT":
                case 8:
                  message.key = 8;
                  break;
                case "A":
                case 9:
                  message.key = 9;
                  break;
                case "A_SHARP":
                case 10:
                  message.key = 10;
                  break;
                case "B_FLAT":
                case 10:
                  message.key = 10;
                  break;
                case "B":
                case 11:
                  message.key = 11;
                  break;
              }
              switch (object.mode) {
                case "MAJOR":
                case 0:
                  message.mode = 0;
                  break;
                case "MINOR":
                case 1:
                  message.mode = 1;
                  break;
                case "NOT_SPECIFIED":
                case 2:
                  message.mode = 2;
                  break;
                case "MIXOLYDIAN":
                case 3:
                  message.mode = 3;
                  break;
                case "DORIAN":
                case 4:
                  message.mode = 4;
                  break;
                case "PHRYGIAN":
                case 5:
                  message.mode = 5;
                  break;
                case "LYDIAN":
                case 6:
                  message.mode = 6;
                  break;
                case "LOCRIAN":
                case 7:
                  message.mode = 7;
                  break;
              }
              return message;
            };
            KeySignature.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (options.defaults) {
                object.time = 0;
                object.key = options.enums === String ? "C" : 0;
                object.mode = options.enums === String ? "MAJOR" : 0;
              }
              if (message.time != null && message.hasOwnProperty("time"))
                object.time = options.json && !isFinite(message.time) ? String(message.time) : message.time;
              if (message.key != null && message.hasOwnProperty("key"))
                object.key = options.enums === String ? $root.tensorflow.magenta.NoteSequence.KeySignature.Key[message.key] : message.key;
              if (message.mode != null && message.hasOwnProperty("mode"))
                object.mode = options.enums === String ? $root.tensorflow.magenta.NoteSequence.KeySignature.Mode[message.mode] : message.mode;
              return object;
            };
            KeySignature.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            KeySignature.Key = (function() {
              var valuesById = {}, values = Object.create(valuesById);
              values[valuesById[0] = "C"] = 0;
              values[valuesById[1] = "C_SHARP"] = 1;
              values["D_FLAT"] = 1;
              values[valuesById[2] = "D"] = 2;
              values[valuesById[3] = "D_SHARP"] = 3;
              values["E_FLAT"] = 3;
              values[valuesById[4] = "E"] = 4;
              values[valuesById[5] = "F"] = 5;
              values[valuesById[6] = "F_SHARP"] = 6;
              values["G_FLAT"] = 6;
              values[valuesById[7] = "G"] = 7;
              values[valuesById[8] = "G_SHARP"] = 8;
              values["A_FLAT"] = 8;
              values[valuesById[9] = "A"] = 9;
              values[valuesById[10] = "A_SHARP"] = 10;
              values["B_FLAT"] = 10;
              values[valuesById[11] = "B"] = 11;
              return values;
            })();
            KeySignature.Mode = (function() {
              var valuesById = {}, values = Object.create(valuesById);
              values[valuesById[0] = "MAJOR"] = 0;
              values[valuesById[1] = "MINOR"] = 1;
              values[valuesById[2] = "NOT_SPECIFIED"] = 2;
              values[valuesById[3] = "MIXOLYDIAN"] = 3;
              values[valuesById[4] = "DORIAN"] = 4;
              values[valuesById[5] = "PHRYGIAN"] = 5;
              values[valuesById[6] = "LYDIAN"] = 6;
              values[valuesById[7] = "LOCRIAN"] = 7;
              return values;
            })();
            return KeySignature;
          })();
          NoteSequence2.Tempo = (function() {
            function Tempo(properties) {
              if (properties) {
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            Tempo.prototype.time = 0;
            Tempo.prototype.qpm = 0;
            Tempo.create = function create(properties) {
              return new Tempo(properties);
            };
            Tempo.encode = function encode(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.time != null && message.hasOwnProperty("time"))
                writer.uint32(
                  /* id 1, wireType 1 =*/
                  9
                ).double(message.time);
              if (message.qpm != null && message.hasOwnProperty("qpm"))
                writer.uint32(
                  /* id 2, wireType 1 =*/
                  17
                ).double(message.qpm);
              return writer;
            };
            Tempo.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            Tempo.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.tensorflow.magenta.NoteSequence.Tempo();
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1:
                    message.time = reader.double();
                    break;
                  case 2:
                    message.qpm = reader.double();
                    break;
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            Tempo.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            Tempo.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.time != null && message.hasOwnProperty("time")) {
                if (typeof message.time !== "number")
                  return "time: number expected";
              }
              if (message.qpm != null && message.hasOwnProperty("qpm")) {
                if (typeof message.qpm !== "number")
                  return "qpm: number expected";
              }
              return null;
            };
            Tempo.fromObject = function fromObject(object) {
              if (object instanceof $root.tensorflow.magenta.NoteSequence.Tempo)
                return object;
              var message = new $root.tensorflow.magenta.NoteSequence.Tempo();
              if (object.time != null)
                message.time = Number(object.time);
              if (object.qpm != null)
                message.qpm = Number(object.qpm);
              return message;
            };
            Tempo.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (options.defaults) {
                object.time = 0;
                object.qpm = 0;
              }
              if (message.time != null && message.hasOwnProperty("time"))
                object.time = options.json && !isFinite(message.time) ? String(message.time) : message.time;
              if (message.qpm != null && message.hasOwnProperty("qpm"))
                object.qpm = options.json && !isFinite(message.qpm) ? String(message.qpm) : message.qpm;
              return object;
            };
            Tempo.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return Tempo;
          })();
          NoteSequence2.PitchBend = (function() {
            function PitchBend(properties) {
              if (properties) {
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            PitchBend.prototype.time = 0;
            PitchBend.prototype.bend = 0;
            PitchBend.prototype.instrument = 0;
            PitchBend.prototype.program = 0;
            PitchBend.prototype.isDrum = false;
            PitchBend.create = function create(properties) {
              return new PitchBend(properties);
            };
            PitchBend.encode = function encode(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.time != null && message.hasOwnProperty("time"))
                writer.uint32(
                  /* id 1, wireType 1 =*/
                  9
                ).double(message.time);
              if (message.bend != null && message.hasOwnProperty("bend"))
                writer.uint32(
                  /* id 2, wireType 0 =*/
                  16
                ).int32(message.bend);
              if (message.instrument != null && message.hasOwnProperty("instrument"))
                writer.uint32(
                  /* id 3, wireType 0 =*/
                  24
                ).int32(message.instrument);
              if (message.program != null && message.hasOwnProperty("program"))
                writer.uint32(
                  /* id 4, wireType 0 =*/
                  32
                ).int32(message.program);
              if (message.isDrum != null && message.hasOwnProperty("isDrum"))
                writer.uint32(
                  /* id 5, wireType 0 =*/
                  40
                ).bool(message.isDrum);
              return writer;
            };
            PitchBend.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            PitchBend.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.tensorflow.magenta.NoteSequence.PitchBend();
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1:
                    message.time = reader.double();
                    break;
                  case 2:
                    message.bend = reader.int32();
                    break;
                  case 3:
                    message.instrument = reader.int32();
                    break;
                  case 4:
                    message.program = reader.int32();
                    break;
                  case 5:
                    message.isDrum = reader.bool();
                    break;
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            PitchBend.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            PitchBend.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.time != null && message.hasOwnProperty("time")) {
                if (typeof message.time !== "number")
                  return "time: number expected";
              }
              if (message.bend != null && message.hasOwnProperty("bend")) {
                if (!$util.isInteger(message.bend))
                  return "bend: integer expected";
              }
              if (message.instrument != null && message.hasOwnProperty("instrument")) {
                if (!$util.isInteger(message.instrument))
                  return "instrument: integer expected";
              }
              if (message.program != null && message.hasOwnProperty("program")) {
                if (!$util.isInteger(message.program))
                  return "program: integer expected";
              }
              if (message.isDrum != null && message.hasOwnProperty("isDrum")) {
                if (typeof message.isDrum !== "boolean")
                  return "isDrum: boolean expected";
              }
              return null;
            };
            PitchBend.fromObject = function fromObject(object) {
              if (object instanceof $root.tensorflow.magenta.NoteSequence.PitchBend)
                return object;
              var message = new $root.tensorflow.magenta.NoteSequence.PitchBend();
              if (object.time != null)
                message.time = Number(object.time);
              if (object.bend != null)
                message.bend = object.bend | 0;
              if (object.instrument != null)
                message.instrument = object.instrument | 0;
              if (object.program != null)
                message.program = object.program | 0;
              if (object.isDrum != null)
                message.isDrum = Boolean(object.isDrum);
              return message;
            };
            PitchBend.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (options.defaults) {
                object.time = 0;
                object.bend = 0;
                object.instrument = 0;
                object.program = 0;
                object.isDrum = false;
              }
              if (message.time != null && message.hasOwnProperty("time"))
                object.time = options.json && !isFinite(message.time) ? String(message.time) : message.time;
              if (message.bend != null && message.hasOwnProperty("bend"))
                object.bend = message.bend;
              if (message.instrument != null && message.hasOwnProperty("instrument"))
                object.instrument = message.instrument;
              if (message.program != null && message.hasOwnProperty("program"))
                object.program = message.program;
              if (message.isDrum != null && message.hasOwnProperty("isDrum"))
                object.isDrum = message.isDrum;
              return object;
            };
            PitchBend.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return PitchBend;
          })();
          NoteSequence2.ControlChange = (function() {
            function ControlChange(properties) {
              if (properties) {
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            ControlChange.prototype.time = 0;
            ControlChange.prototype.quantizedStep = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            ControlChange.prototype.controlNumber = 0;
            ControlChange.prototype.controlValue = 0;
            ControlChange.prototype.instrument = 0;
            ControlChange.prototype.program = 0;
            ControlChange.prototype.isDrum = false;
            ControlChange.create = function create(properties) {
              return new ControlChange(properties);
            };
            ControlChange.encode = function encode(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.time != null && message.hasOwnProperty("time"))
                writer.uint32(
                  /* id 1, wireType 1 =*/
                  9
                ).double(message.time);
              if (message.controlNumber != null && message.hasOwnProperty("controlNumber"))
                writer.uint32(
                  /* id 2, wireType 0 =*/
                  16
                ).int32(message.controlNumber);
              if (message.controlValue != null && message.hasOwnProperty("controlValue"))
                writer.uint32(
                  /* id 3, wireType 0 =*/
                  24
                ).int32(message.controlValue);
              if (message.instrument != null && message.hasOwnProperty("instrument"))
                writer.uint32(
                  /* id 4, wireType 0 =*/
                  32
                ).int32(message.instrument);
              if (message.program != null && message.hasOwnProperty("program"))
                writer.uint32(
                  /* id 5, wireType 0 =*/
                  40
                ).int32(message.program);
              if (message.isDrum != null && message.hasOwnProperty("isDrum"))
                writer.uint32(
                  /* id 6, wireType 0 =*/
                  48
                ).bool(message.isDrum);
              if (message.quantizedStep != null && message.hasOwnProperty("quantizedStep"))
                writer.uint32(
                  /* id 7, wireType 0 =*/
                  56
                ).int64(message.quantizedStep);
              return writer;
            };
            ControlChange.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            ControlChange.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.tensorflow.magenta.NoteSequence.ControlChange();
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1:
                    message.time = reader.double();
                    break;
                  case 7:
                    message.quantizedStep = $util.Long ? reader.int64().toNumber() : reader.int64();
                    break;
                  case 2:
                    message.controlNumber = reader.int32();
                    break;
                  case 3:
                    message.controlValue = reader.int32();
                    break;
                  case 4:
                    message.instrument = reader.int32();
                    break;
                  case 5:
                    message.program = reader.int32();
                    break;
                  case 6:
                    message.isDrum = reader.bool();
                    break;
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            ControlChange.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            ControlChange.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.time != null && message.hasOwnProperty("time")) {
                if (typeof message.time !== "number")
                  return "time: number expected";
              }
              if (message.quantizedStep != null && message.hasOwnProperty("quantizedStep")) {
                if (!$util.isInteger(message.quantizedStep) && !(message.quantizedStep && $util.isInteger(message.quantizedStep.low) && $util.isInteger(message.quantizedStep.high)))
                  return "quantizedStep: integer|Long expected";
              }
              if (message.controlNumber != null && message.hasOwnProperty("controlNumber")) {
                if (!$util.isInteger(message.controlNumber))
                  return "controlNumber: integer expected";
              }
              if (message.controlValue != null && message.hasOwnProperty("controlValue")) {
                if (!$util.isInteger(message.controlValue))
                  return "controlValue: integer expected";
              }
              if (message.instrument != null && message.hasOwnProperty("instrument")) {
                if (!$util.isInteger(message.instrument))
                  return "instrument: integer expected";
              }
              if (message.program != null && message.hasOwnProperty("program")) {
                if (!$util.isInteger(message.program))
                  return "program: integer expected";
              }
              if (message.isDrum != null && message.hasOwnProperty("isDrum")) {
                if (typeof message.isDrum !== "boolean")
                  return "isDrum: boolean expected";
              }
              return null;
            };
            ControlChange.fromObject = function fromObject(object) {
              if (object instanceof $root.tensorflow.magenta.NoteSequence.ControlChange)
                return object;
              var message = new $root.tensorflow.magenta.NoteSequence.ControlChange();
              if (object.time != null)
                message.time = Number(object.time);
              if (object.quantizedStep != null) {
                if ($util.Long)
                  (message.quantizedStep = $util.Long.fromValue(object.quantizedStep)).unsigned = false;
                else if (typeof object.quantizedStep === "string")
                  message.quantizedStep = parseInt(object.quantizedStep, 10);
                else if (typeof object.quantizedStep === "number")
                  message.quantizedStep = object.quantizedStep;
                else if (typeof object.quantizedStep === "object")
                  message.quantizedStep = new $util.LongBits(object.quantizedStep.low >>> 0, object.quantizedStep.high >>> 0).toNumber();
              }
              if (object.controlNumber != null)
                message.controlNumber = object.controlNumber | 0;
              if (object.controlValue != null)
                message.controlValue = object.controlValue | 0;
              if (object.instrument != null)
                message.instrument = object.instrument | 0;
              if (object.program != null)
                message.program = object.program | 0;
              if (object.isDrum != null)
                message.isDrum = Boolean(object.isDrum);
              return message;
            };
            ControlChange.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (options.defaults) {
                object.time = 0;
                object.controlNumber = 0;
                object.controlValue = 0;
                object.instrument = 0;
                object.program = 0;
                object.isDrum = false;
                if ($util.Long) {
                  var long = new $util.Long(0, 0, false);
                  object.quantizedStep = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                  object.quantizedStep = options.longs === String ? "0" : 0;
              }
              if (message.time != null && message.hasOwnProperty("time"))
                object.time = options.json && !isFinite(message.time) ? String(message.time) : message.time;
              if (message.controlNumber != null && message.hasOwnProperty("controlNumber"))
                object.controlNumber = message.controlNumber;
              if (message.controlValue != null && message.hasOwnProperty("controlValue"))
                object.controlValue = message.controlValue;
              if (message.instrument != null && message.hasOwnProperty("instrument"))
                object.instrument = message.instrument;
              if (message.program != null && message.hasOwnProperty("program"))
                object.program = message.program;
              if (message.isDrum != null && message.hasOwnProperty("isDrum"))
                object.isDrum = message.isDrum;
              if (message.quantizedStep != null && message.hasOwnProperty("quantizedStep"))
                if (typeof message.quantizedStep === "number")
                  object.quantizedStep = options.longs === String ? String(message.quantizedStep) : message.quantizedStep;
                else
                  object.quantizedStep = options.longs === String ? $util.Long.prototype.toString.call(message.quantizedStep) : options.longs === Number ? new $util.LongBits(message.quantizedStep.low >>> 0, message.quantizedStep.high >>> 0).toNumber() : message.quantizedStep;
              return object;
            };
            ControlChange.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return ControlChange;
          })();
          NoteSequence2.PartInfo = (function() {
            function PartInfo(properties) {
              if (properties) {
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            PartInfo.prototype.part = 0;
            PartInfo.prototype.name = "";
            PartInfo.create = function create(properties) {
              return new PartInfo(properties);
            };
            PartInfo.encode = function encode(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.part != null && message.hasOwnProperty("part"))
                writer.uint32(
                  /* id 1, wireType 0 =*/
                  8
                ).int32(message.part);
              if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(
                  /* id 2, wireType 2 =*/
                  18
                ).string(message.name);
              return writer;
            };
            PartInfo.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            PartInfo.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.tensorflow.magenta.NoteSequence.PartInfo();
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1:
                    message.part = reader.int32();
                    break;
                  case 2:
                    message.name = reader.string();
                    break;
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            PartInfo.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            PartInfo.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.part != null && message.hasOwnProperty("part")) {
                if (!$util.isInteger(message.part))
                  return "part: integer expected";
              }
              if (message.name != null && message.hasOwnProperty("name")) {
                if (!$util.isString(message.name))
                  return "name: string expected";
              }
              return null;
            };
            PartInfo.fromObject = function fromObject(object) {
              if (object instanceof $root.tensorflow.magenta.NoteSequence.PartInfo)
                return object;
              var message = new $root.tensorflow.magenta.NoteSequence.PartInfo();
              if (object.part != null)
                message.part = object.part | 0;
              if (object.name != null)
                message.name = String(object.name);
              return message;
            };
            PartInfo.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (options.defaults) {
                object.part = 0;
                object.name = "";
              }
              if (message.part != null && message.hasOwnProperty("part"))
                object.part = message.part;
              if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
              return object;
            };
            PartInfo.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return PartInfo;
          })();
          NoteSequence2.SourceInfo = (function() {
            function SourceInfo(properties) {
              if (properties) {
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            SourceInfo.prototype.sourceType = 0;
            SourceInfo.prototype.encodingType = 0;
            SourceInfo.prototype.parser = 0;
            SourceInfo.create = function create(properties) {
              return new SourceInfo(properties);
            };
            SourceInfo.encode = function encode(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.sourceType != null && message.hasOwnProperty("sourceType"))
                writer.uint32(
                  /* id 1, wireType 0 =*/
                  8
                ).int32(message.sourceType);
              if (message.encodingType != null && message.hasOwnProperty("encodingType"))
                writer.uint32(
                  /* id 2, wireType 0 =*/
                  16
                ).int32(message.encodingType);
              if (message.parser != null && message.hasOwnProperty("parser"))
                writer.uint32(
                  /* id 3, wireType 0 =*/
                  24
                ).int32(message.parser);
              return writer;
            };
            SourceInfo.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            SourceInfo.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.tensorflow.magenta.NoteSequence.SourceInfo();
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1:
                    message.sourceType = reader.int32();
                    break;
                  case 2:
                    message.encodingType = reader.int32();
                    break;
                  case 3:
                    message.parser = reader.int32();
                    break;
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            SourceInfo.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            SourceInfo.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.sourceType != null && message.hasOwnProperty("sourceType"))
                switch (message.sourceType) {
                  default:
                    return "sourceType: enum value expected";
                  case 0:
                  case 1:
                  case 2:
                    break;
                }
              if (message.encodingType != null && message.hasOwnProperty("encodingType"))
                switch (message.encodingType) {
                  default:
                    return "encodingType: enum value expected";
                  case 0:
                  case 1:
                  case 2:
                  case 3:
                  case 4:
                    break;
                }
              if (message.parser != null && message.hasOwnProperty("parser"))
                switch (message.parser) {
                  default:
                    return "parser: enum value expected";
                  case 0:
                  case 1:
                  case 2:
                  case 3:
                  case 4:
                  case 5:
                  case 6:
                    break;
                }
              return null;
            };
            SourceInfo.fromObject = function fromObject(object) {
              if (object instanceof $root.tensorflow.magenta.NoteSequence.SourceInfo)
                return object;
              var message = new $root.tensorflow.magenta.NoteSequence.SourceInfo();
              switch (object.sourceType) {
                case "UNKNOWN_SOURCE_TYPE":
                case 0:
                  message.sourceType = 0;
                  break;
                case "SCORE_BASED":
                case 1:
                  message.sourceType = 1;
                  break;
                case "PERFORMANCE_BASED":
                case 2:
                  message.sourceType = 2;
                  break;
              }
              switch (object.encodingType) {
                case "UNKNOWN_ENCODING_TYPE":
                case 0:
                  message.encodingType = 0;
                  break;
                case "MUSIC_XML":
                case 1:
                  message.encodingType = 1;
                  break;
                case "ABC":
                case 2:
                  message.encodingType = 2;
                  break;
                case "MIDI":
                case 3:
                  message.encodingType = 3;
                  break;
                case "MUSICNET":
                case 4:
                  message.encodingType = 4;
                  break;
              }
              switch (object.parser) {
                case "UNKNOWN_PARSER":
                case 0:
                  message.parser = 0;
                  break;
                case "MUSIC21":
                case 1:
                  message.parser = 1;
                  break;
                case "PRETTY_MIDI":
                case 2:
                  message.parser = 2;
                  break;
                case "MAGENTA_MUSIC_XML":
                case 3:
                  message.parser = 3;
                  break;
                case "MAGENTA_MUSICNET":
                case 4:
                  message.parser = 4;
                  break;
                case "MAGENTA_ABC":
                case 5:
                  message.parser = 5;
                  break;
                case "TONEJS_MIDI_CONVERT":
                case 6:
                  message.parser = 6;
                  break;
              }
              return message;
            };
            SourceInfo.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (options.defaults) {
                object.sourceType = options.enums === String ? "UNKNOWN_SOURCE_TYPE" : 0;
                object.encodingType = options.enums === String ? "UNKNOWN_ENCODING_TYPE" : 0;
                object.parser = options.enums === String ? "UNKNOWN_PARSER" : 0;
              }
              if (message.sourceType != null && message.hasOwnProperty("sourceType"))
                object.sourceType = options.enums === String ? $root.tensorflow.magenta.NoteSequence.SourceInfo.SourceType[message.sourceType] : message.sourceType;
              if (message.encodingType != null && message.hasOwnProperty("encodingType"))
                object.encodingType = options.enums === String ? $root.tensorflow.magenta.NoteSequence.SourceInfo.EncodingType[message.encodingType] : message.encodingType;
              if (message.parser != null && message.hasOwnProperty("parser"))
                object.parser = options.enums === String ? $root.tensorflow.magenta.NoteSequence.SourceInfo.Parser[message.parser] : message.parser;
              return object;
            };
            SourceInfo.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            SourceInfo.SourceType = (function() {
              var valuesById = {}, values = Object.create(valuesById);
              values[valuesById[0] = "UNKNOWN_SOURCE_TYPE"] = 0;
              values[valuesById[1] = "SCORE_BASED"] = 1;
              values[valuesById[2] = "PERFORMANCE_BASED"] = 2;
              return values;
            })();
            SourceInfo.EncodingType = (function() {
              var valuesById = {}, values = Object.create(valuesById);
              values[valuesById[0] = "UNKNOWN_ENCODING_TYPE"] = 0;
              values[valuesById[1] = "MUSIC_XML"] = 1;
              values[valuesById[2] = "ABC"] = 2;
              values[valuesById[3] = "MIDI"] = 3;
              values[valuesById[4] = "MUSICNET"] = 4;
              return values;
            })();
            SourceInfo.Parser = (function() {
              var valuesById = {}, values = Object.create(valuesById);
              values[valuesById[0] = "UNKNOWN_PARSER"] = 0;
              values[valuesById[1] = "MUSIC21"] = 1;
              values[valuesById[2] = "PRETTY_MIDI"] = 2;
              values[valuesById[3] = "MAGENTA_MUSIC_XML"] = 3;
              values[valuesById[4] = "MAGENTA_MUSICNET"] = 4;
              values[valuesById[5] = "MAGENTA_ABC"] = 5;
              values[valuesById[6] = "TONEJS_MIDI_CONVERT"] = 6;
              return values;
            })();
            return SourceInfo;
          })();
          NoteSequence2.TextAnnotation = (function() {
            function TextAnnotation(properties) {
              if (properties) {
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            TextAnnotation.prototype.time = 0;
            TextAnnotation.prototype.quantizedStep = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            TextAnnotation.prototype.text = "";
            TextAnnotation.prototype.annotationType = 0;
            TextAnnotation.create = function create(properties) {
              return new TextAnnotation(properties);
            };
            TextAnnotation.encode = function encode(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.time != null && message.hasOwnProperty("time"))
                writer.uint32(
                  /* id 1, wireType 1 =*/
                  9
                ).double(message.time);
              if (message.text != null && message.hasOwnProperty("text"))
                writer.uint32(
                  /* id 2, wireType 2 =*/
                  18
                ).string(message.text);
              if (message.annotationType != null && message.hasOwnProperty("annotationType"))
                writer.uint32(
                  /* id 3, wireType 0 =*/
                  24
                ).int32(message.annotationType);
              if (message.quantizedStep != null && message.hasOwnProperty("quantizedStep"))
                writer.uint32(
                  /* id 4, wireType 0 =*/
                  32
                ).int64(message.quantizedStep);
              return writer;
            };
            TextAnnotation.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            TextAnnotation.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.tensorflow.magenta.NoteSequence.TextAnnotation();
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1:
                    message.time = reader.double();
                    break;
                  case 4:
                    message.quantizedStep = $util.Long ? reader.int64().toNumber() : reader.int64();
                    break;
                  case 2:
                    message.text = reader.string();
                    break;
                  case 3:
                    message.annotationType = reader.int32();
                    break;
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            TextAnnotation.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            TextAnnotation.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.time != null && message.hasOwnProperty("time")) {
                if (typeof message.time !== "number")
                  return "time: number expected";
              }
              if (message.quantizedStep != null && message.hasOwnProperty("quantizedStep")) {
                if (!$util.isInteger(message.quantizedStep) && !(message.quantizedStep && $util.isInteger(message.quantizedStep.low) && $util.isInteger(message.quantizedStep.high)))
                  return "quantizedStep: integer|Long expected";
              }
              if (message.text != null && message.hasOwnProperty("text")) {
                if (!$util.isString(message.text))
                  return "text: string expected";
              }
              if (message.annotationType != null && message.hasOwnProperty("annotationType"))
                switch (message.annotationType) {
                  default:
                    return "annotationType: enum value expected";
                  case 0:
                  case 1:
                  case 2:
                    break;
                }
              return null;
            };
            TextAnnotation.fromObject = function fromObject(object) {
              if (object instanceof $root.tensorflow.magenta.NoteSequence.TextAnnotation)
                return object;
              var message = new $root.tensorflow.magenta.NoteSequence.TextAnnotation();
              if (object.time != null)
                message.time = Number(object.time);
              if (object.quantizedStep != null) {
                if ($util.Long)
                  (message.quantizedStep = $util.Long.fromValue(object.quantizedStep)).unsigned = false;
                else if (typeof object.quantizedStep === "string")
                  message.quantizedStep = parseInt(object.quantizedStep, 10);
                else if (typeof object.quantizedStep === "number")
                  message.quantizedStep = object.quantizedStep;
                else if (typeof object.quantizedStep === "object")
                  message.quantizedStep = new $util.LongBits(object.quantizedStep.low >>> 0, object.quantizedStep.high >>> 0).toNumber();
              }
              if (object.text != null)
                message.text = String(object.text);
              switch (object.annotationType) {
                case "UNKNOWN":
                case 0:
                  message.annotationType = 0;
                  break;
                case "CHORD_SYMBOL":
                case 1:
                  message.annotationType = 1;
                  break;
                case "BEAT":
                case 2:
                  message.annotationType = 2;
                  break;
              }
              return message;
            };
            TextAnnotation.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (options.defaults) {
                object.time = 0;
                object.text = "";
                object.annotationType = options.enums === String ? "UNKNOWN" : 0;
                if ($util.Long) {
                  var long = new $util.Long(0, 0, false);
                  object.quantizedStep = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                  object.quantizedStep = options.longs === String ? "0" : 0;
              }
              if (message.time != null && message.hasOwnProperty("time"))
                object.time = options.json && !isFinite(message.time) ? String(message.time) : message.time;
              if (message.text != null && message.hasOwnProperty("text"))
                object.text = message.text;
              if (message.annotationType != null && message.hasOwnProperty("annotationType"))
                object.annotationType = options.enums === String ? $root.tensorflow.magenta.NoteSequence.TextAnnotation.TextAnnotationType[message.annotationType] : message.annotationType;
              if (message.quantizedStep != null && message.hasOwnProperty("quantizedStep"))
                if (typeof message.quantizedStep === "number")
                  object.quantizedStep = options.longs === String ? String(message.quantizedStep) : message.quantizedStep;
                else
                  object.quantizedStep = options.longs === String ? $util.Long.prototype.toString.call(message.quantizedStep) : options.longs === Number ? new $util.LongBits(message.quantizedStep.low >>> 0, message.quantizedStep.high >>> 0).toNumber() : message.quantizedStep;
              return object;
            };
            TextAnnotation.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            TextAnnotation.TextAnnotationType = (function() {
              var valuesById = {}, values = Object.create(valuesById);
              values[valuesById[0] = "UNKNOWN"] = 0;
              values[valuesById[1] = "CHORD_SYMBOL"] = 1;
              values[valuesById[2] = "BEAT"] = 2;
              return values;
            })();
            return TextAnnotation;
          })();
          NoteSequence2.QuantizationInfo = (function() {
            function QuantizationInfo(properties) {
              if (properties) {
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            QuantizationInfo.prototype.stepsPerQuarter = 0;
            QuantizationInfo.prototype.stepsPerSecond = 0;
            var $oneOfFields;
            Object.defineProperty(QuantizationInfo.prototype, "resolution", {
              get: $util.oneOfGetter($oneOfFields = ["stepsPerQuarter", "stepsPerSecond"]),
              set: $util.oneOfSetter($oneOfFields)
            });
            QuantizationInfo.create = function create(properties) {
              return new QuantizationInfo(properties);
            };
            QuantizationInfo.encode = function encode(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.stepsPerQuarter != null && message.hasOwnProperty("stepsPerQuarter"))
                writer.uint32(
                  /* id 1, wireType 0 =*/
                  8
                ).int32(message.stepsPerQuarter);
              if (message.stepsPerSecond != null && message.hasOwnProperty("stepsPerSecond"))
                writer.uint32(
                  /* id 2, wireType 0 =*/
                  16
                ).int32(message.stepsPerSecond);
              return writer;
            };
            QuantizationInfo.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            QuantizationInfo.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.tensorflow.magenta.NoteSequence.QuantizationInfo();
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1:
                    message.stepsPerQuarter = reader.int32();
                    break;
                  case 2:
                    message.stepsPerSecond = reader.int32();
                    break;
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            QuantizationInfo.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            QuantizationInfo.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              var properties = {};
              if (message.stepsPerQuarter != null && message.hasOwnProperty("stepsPerQuarter")) {
                properties.resolution = 1;
                if (!$util.isInteger(message.stepsPerQuarter))
                  return "stepsPerQuarter: integer expected";
              }
              if (message.stepsPerSecond != null && message.hasOwnProperty("stepsPerSecond")) {
                if (properties.resolution === 1)
                  return "resolution: multiple values";
                properties.resolution = 1;
                if (!$util.isInteger(message.stepsPerSecond))
                  return "stepsPerSecond: integer expected";
              }
              return null;
            };
            QuantizationInfo.fromObject = function fromObject(object) {
              if (object instanceof $root.tensorflow.magenta.NoteSequence.QuantizationInfo)
                return object;
              var message = new $root.tensorflow.magenta.NoteSequence.QuantizationInfo();
              if (object.stepsPerQuarter != null)
                message.stepsPerQuarter = object.stepsPerQuarter | 0;
              if (object.stepsPerSecond != null)
                message.stepsPerSecond = object.stepsPerSecond | 0;
              return message;
            };
            QuantizationInfo.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (message.stepsPerQuarter != null && message.hasOwnProperty("stepsPerQuarter")) {
                object.stepsPerQuarter = message.stepsPerQuarter;
                if (options.oneofs)
                  object.resolution = "stepsPerQuarter";
              }
              if (message.stepsPerSecond != null && message.hasOwnProperty("stepsPerSecond")) {
                object.stepsPerSecond = message.stepsPerSecond;
                if (options.oneofs)
                  object.resolution = "stepsPerSecond";
              }
              return object;
            };
            QuantizationInfo.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return QuantizationInfo;
          })();
          NoteSequence2.SubsequenceInfo = (function() {
            function SubsequenceInfo(properties) {
              if (properties) {
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            SubsequenceInfo.prototype.startTimeOffset = 0;
            SubsequenceInfo.prototype.endTimeOffset = 0;
            SubsequenceInfo.create = function create(properties) {
              return new SubsequenceInfo(properties);
            };
            SubsequenceInfo.encode = function encode(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.startTimeOffset != null && message.hasOwnProperty("startTimeOffset"))
                writer.uint32(
                  /* id 1, wireType 1 =*/
                  9
                ).double(message.startTimeOffset);
              if (message.endTimeOffset != null && message.hasOwnProperty("endTimeOffset"))
                writer.uint32(
                  /* id 2, wireType 1 =*/
                  17
                ).double(message.endTimeOffset);
              return writer;
            };
            SubsequenceInfo.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            SubsequenceInfo.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.tensorflow.magenta.NoteSequence.SubsequenceInfo();
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1:
                    message.startTimeOffset = reader.double();
                    break;
                  case 2:
                    message.endTimeOffset = reader.double();
                    break;
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            SubsequenceInfo.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            SubsequenceInfo.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.startTimeOffset != null && message.hasOwnProperty("startTimeOffset")) {
                if (typeof message.startTimeOffset !== "number")
                  return "startTimeOffset: number expected";
              }
              if (message.endTimeOffset != null && message.hasOwnProperty("endTimeOffset")) {
                if (typeof message.endTimeOffset !== "number")
                  return "endTimeOffset: number expected";
              }
              return null;
            };
            SubsequenceInfo.fromObject = function fromObject(object) {
              if (object instanceof $root.tensorflow.magenta.NoteSequence.SubsequenceInfo)
                return object;
              var message = new $root.tensorflow.magenta.NoteSequence.SubsequenceInfo();
              if (object.startTimeOffset != null)
                message.startTimeOffset = Number(object.startTimeOffset);
              if (object.endTimeOffset != null)
                message.endTimeOffset = Number(object.endTimeOffset);
              return message;
            };
            SubsequenceInfo.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (options.defaults) {
                object.startTimeOffset = 0;
                object.endTimeOffset = 0;
              }
              if (message.startTimeOffset != null && message.hasOwnProperty("startTimeOffset"))
                object.startTimeOffset = options.json && !isFinite(message.startTimeOffset) ? String(message.startTimeOffset) : message.startTimeOffset;
              if (message.endTimeOffset != null && message.hasOwnProperty("endTimeOffset"))
                object.endTimeOffset = options.json && !isFinite(message.endTimeOffset) ? String(message.endTimeOffset) : message.endTimeOffset;
              return object;
            };
            SubsequenceInfo.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return SubsequenceInfo;
          })();
          NoteSequence2.SectionAnnotation = (function() {
            function SectionAnnotation(properties) {
              if (properties) {
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            SectionAnnotation.prototype.time = 0;
            SectionAnnotation.prototype.sectionId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            SectionAnnotation.create = function create(properties) {
              return new SectionAnnotation(properties);
            };
            SectionAnnotation.encode = function encode(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.time != null && message.hasOwnProperty("time"))
                writer.uint32(
                  /* id 1, wireType 1 =*/
                  9
                ).double(message.time);
              if (message.sectionId != null && message.hasOwnProperty("sectionId"))
                writer.uint32(
                  /* id 4, wireType 0 =*/
                  32
                ).int64(message.sectionId);
              return writer;
            };
            SectionAnnotation.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            SectionAnnotation.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.tensorflow.magenta.NoteSequence.SectionAnnotation();
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1:
                    message.time = reader.double();
                    break;
                  case 4:
                    message.sectionId = $util.Long ? reader.int64().toNumber() : reader.int64();
                    break;
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            SectionAnnotation.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            SectionAnnotation.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.time != null && message.hasOwnProperty("time")) {
                if (typeof message.time !== "number")
                  return "time: number expected";
              }
              if (message.sectionId != null && message.hasOwnProperty("sectionId")) {
                if (!$util.isInteger(message.sectionId) && !(message.sectionId && $util.isInteger(message.sectionId.low) && $util.isInteger(message.sectionId.high)))
                  return "sectionId: integer|Long expected";
              }
              return null;
            };
            SectionAnnotation.fromObject = function fromObject(object) {
              if (object instanceof $root.tensorflow.magenta.NoteSequence.SectionAnnotation)
                return object;
              var message = new $root.tensorflow.magenta.NoteSequence.SectionAnnotation();
              if (object.time != null)
                message.time = Number(object.time);
              if (object.sectionId != null) {
                if ($util.Long)
                  (message.sectionId = $util.Long.fromValue(object.sectionId)).unsigned = false;
                else if (typeof object.sectionId === "string")
                  message.sectionId = parseInt(object.sectionId, 10);
                else if (typeof object.sectionId === "number")
                  message.sectionId = object.sectionId;
                else if (typeof object.sectionId === "object")
                  message.sectionId = new $util.LongBits(object.sectionId.low >>> 0, object.sectionId.high >>> 0).toNumber();
              }
              return message;
            };
            SectionAnnotation.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (options.defaults) {
                object.time = 0;
                if ($util.Long) {
                  var long = new $util.Long(0, 0, false);
                  object.sectionId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                  object.sectionId = options.longs === String ? "0" : 0;
              }
              if (message.time != null && message.hasOwnProperty("time"))
                object.time = options.json && !isFinite(message.time) ? String(message.time) : message.time;
              if (message.sectionId != null && message.hasOwnProperty("sectionId"))
                if (typeof message.sectionId === "number")
                  object.sectionId = options.longs === String ? String(message.sectionId) : message.sectionId;
                else
                  object.sectionId = options.longs === String ? $util.Long.prototype.toString.call(message.sectionId) : options.longs === Number ? new $util.LongBits(message.sectionId.low >>> 0, message.sectionId.high >>> 0).toNumber() : message.sectionId;
              return object;
            };
            SectionAnnotation.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return SectionAnnotation;
          })();
          NoteSequence2.Section = (function() {
            function Section(properties) {
              if (properties) {
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            Section.prototype.sectionId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            Section.prototype.sectionGroup = null;
            var $oneOfFields;
            Object.defineProperty(Section.prototype, "sectionType", {
              get: $util.oneOfGetter($oneOfFields = ["sectionId", "sectionGroup"]),
              set: $util.oneOfSetter($oneOfFields)
            });
            Section.create = function create(properties) {
              return new Section(properties);
            };
            Section.encode = function encode(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.sectionId != null && message.hasOwnProperty("sectionId"))
                writer.uint32(
                  /* id 1, wireType 0 =*/
                  8
                ).int64(message.sectionId);
              if (message.sectionGroup != null && message.hasOwnProperty("sectionGroup"))
                $root.tensorflow.magenta.NoteSequence.SectionGroup.encode(message.sectionGroup, writer.uint32(
                  /* id 2, wireType 2 =*/
                  18
                ).fork()).ldelim();
              return writer;
            };
            Section.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            Section.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.tensorflow.magenta.NoteSequence.Section();
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1:
                    message.sectionId = $util.Long ? reader.int64().toNumber() : reader.int64();
                    break;
                  case 2:
                    message.sectionGroup = $root.tensorflow.magenta.NoteSequence.SectionGroup.decode(reader, reader.uint32());
                    break;
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            Section.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            Section.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              var properties = {};
              if (message.sectionId != null && message.hasOwnProperty("sectionId")) {
                properties.sectionType = 1;
                if (!$util.isInteger(message.sectionId) && !(message.sectionId && $util.isInteger(message.sectionId.low) && $util.isInteger(message.sectionId.high)))
                  return "sectionId: integer|Long expected";
              }
              if (message.sectionGroup != null && message.hasOwnProperty("sectionGroup")) {
                if (properties.sectionType === 1)
                  return "sectionType: multiple values";
                properties.sectionType = 1;
                {
                  var error = $root.tensorflow.magenta.NoteSequence.SectionGroup.verify(message.sectionGroup);
                  if (error)
                    return "sectionGroup." + error;
                }
              }
              return null;
            };
            Section.fromObject = function fromObject(object) {
              if (object instanceof $root.tensorflow.magenta.NoteSequence.Section)
                return object;
              var message = new $root.tensorflow.magenta.NoteSequence.Section();
              if (object.sectionId != null) {
                if ($util.Long)
                  (message.sectionId = $util.Long.fromValue(object.sectionId)).unsigned = false;
                else if (typeof object.sectionId === "string")
                  message.sectionId = parseInt(object.sectionId, 10);
                else if (typeof object.sectionId === "number")
                  message.sectionId = object.sectionId;
                else if (typeof object.sectionId === "object")
                  message.sectionId = new $util.LongBits(object.sectionId.low >>> 0, object.sectionId.high >>> 0).toNumber();
              }
              if (object.sectionGroup != null) {
                if (typeof object.sectionGroup !== "object")
                  throw TypeError(".tensorflow.magenta.NoteSequence.Section.sectionGroup: object expected");
                message.sectionGroup = $root.tensorflow.magenta.NoteSequence.SectionGroup.fromObject(object.sectionGroup);
              }
              return message;
            };
            Section.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (message.sectionId != null && message.hasOwnProperty("sectionId")) {
                if (typeof message.sectionId === "number")
                  object.sectionId = options.longs === String ? String(message.sectionId) : message.sectionId;
                else
                  object.sectionId = options.longs === String ? $util.Long.prototype.toString.call(message.sectionId) : options.longs === Number ? new $util.LongBits(message.sectionId.low >>> 0, message.sectionId.high >>> 0).toNumber() : message.sectionId;
                if (options.oneofs)
                  object.sectionType = "sectionId";
              }
              if (message.sectionGroup != null && message.hasOwnProperty("sectionGroup")) {
                object.sectionGroup = $root.tensorflow.magenta.NoteSequence.SectionGroup.toObject(message.sectionGroup, options);
                if (options.oneofs)
                  object.sectionType = "sectionGroup";
              }
              return object;
            };
            Section.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return Section;
          })();
          NoteSequence2.SectionGroup = (function() {
            function SectionGroup(properties) {
              this.sections = [];
              if (properties) {
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            SectionGroup.prototype.sections = $util.emptyArray;
            SectionGroup.prototype.numTimes = 0;
            SectionGroup.create = function create(properties) {
              return new SectionGroup(properties);
            };
            SectionGroup.encode = function encode(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.sections != null && message.sections.length)
                for (var i = 0; i < message.sections.length; ++i)
                  $root.tensorflow.magenta.NoteSequence.Section.encode(message.sections[i], writer.uint32(
                    /* id 1, wireType 2 =*/
                    10
                  ).fork()).ldelim();
              if (message.numTimes != null && message.hasOwnProperty("numTimes"))
                writer.uint32(
                  /* id 2, wireType 0 =*/
                  16
                ).int32(message.numTimes);
              return writer;
            };
            SectionGroup.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            SectionGroup.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.tensorflow.magenta.NoteSequence.SectionGroup();
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1:
                    if (!(message.sections && message.sections.length))
                      message.sections = [];
                    message.sections.push($root.tensorflow.magenta.NoteSequence.Section.decode(reader, reader.uint32()));
                    break;
                  case 2:
                    message.numTimes = reader.int32();
                    break;
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            SectionGroup.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            SectionGroup.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.sections != null && message.hasOwnProperty("sections")) {
                if (!Array.isArray(message.sections))
                  return "sections: array expected";
                for (var i = 0; i < message.sections.length; ++i) {
                  var error = $root.tensorflow.magenta.NoteSequence.Section.verify(message.sections[i]);
                  if (error)
                    return "sections." + error;
                }
              }
              if (message.numTimes != null && message.hasOwnProperty("numTimes")) {
                if (!$util.isInteger(message.numTimes))
                  return "numTimes: integer expected";
              }
              return null;
            };
            SectionGroup.fromObject = function fromObject(object) {
              if (object instanceof $root.tensorflow.magenta.NoteSequence.SectionGroup)
                return object;
              var message = new $root.tensorflow.magenta.NoteSequence.SectionGroup();
              if (object.sections) {
                if (!Array.isArray(object.sections))
                  throw TypeError(".tensorflow.magenta.NoteSequence.SectionGroup.sections: array expected");
                message.sections = [];
                for (var i = 0; i < object.sections.length; ++i) {
                  if (typeof object.sections[i] !== "object")
                    throw TypeError(".tensorflow.magenta.NoteSequence.SectionGroup.sections: object expected");
                  message.sections[i] = $root.tensorflow.magenta.NoteSequence.Section.fromObject(object.sections[i]);
                }
              }
              if (object.numTimes != null)
                message.numTimes = object.numTimes | 0;
              return message;
            };
            SectionGroup.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (options.arrays || options.defaults)
                object.sections = [];
              if (options.defaults)
                object.numTimes = 0;
              if (message.sections && message.sections.length) {
                object.sections = [];
                for (var j = 0; j < message.sections.length; ++j)
                  object.sections[j] = $root.tensorflow.magenta.NoteSequence.Section.toObject(message.sections[j], options);
              }
              if (message.numTimes != null && message.hasOwnProperty("numTimes"))
                object.numTimes = message.numTimes;
              return object;
            };
            SectionGroup.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return SectionGroup;
          })();
          return NoteSequence2;
        })();
        magenta.SequenceMetadata = (function() {
          function SequenceMetadata(properties) {
            this.genre = [];
            this.composers = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          SequenceMetadata.prototype.title = "";
          SequenceMetadata.prototype.artist = "";
          SequenceMetadata.prototype.genre = $util.emptyArray;
          SequenceMetadata.prototype.composers = $util.emptyArray;
          SequenceMetadata.create = function create(properties) {
            return new SequenceMetadata(properties);
          };
          SequenceMetadata.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.title != null && message.hasOwnProperty("title"))
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(message.title);
            if (message.artist != null && message.hasOwnProperty("artist"))
              writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).string(message.artist);
            if (message.genre != null && message.genre.length)
              for (var i = 0; i < message.genre.length; ++i)
                writer.uint32(
                  /* id 3, wireType 2 =*/
                  26
                ).string(message.genre[i]);
            if (message.composers != null && message.composers.length)
              for (var i = 0; i < message.composers.length; ++i)
                writer.uint32(
                  /* id 4, wireType 2 =*/
                  34
                ).string(message.composers[i]);
            return writer;
          };
          SequenceMetadata.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          SequenceMetadata.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.tensorflow.magenta.SequenceMetadata();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.title = reader.string();
                  break;
                case 2:
                  message.artist = reader.string();
                  break;
                case 3:
                  if (!(message.genre && message.genre.length))
                    message.genre = [];
                  message.genre.push(reader.string());
                  break;
                case 4:
                  if (!(message.composers && message.composers.length))
                    message.composers = [];
                  message.composers.push(reader.string());
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          SequenceMetadata.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          SequenceMetadata.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.title != null && message.hasOwnProperty("title")) {
              if (!$util.isString(message.title))
                return "title: string expected";
            }
            if (message.artist != null && message.hasOwnProperty("artist")) {
              if (!$util.isString(message.artist))
                return "artist: string expected";
            }
            if (message.genre != null && message.hasOwnProperty("genre")) {
              if (!Array.isArray(message.genre))
                return "genre: array expected";
              for (var i = 0; i < message.genre.length; ++i)
                if (!$util.isString(message.genre[i]))
                  return "genre: string[] expected";
            }
            if (message.composers != null && message.hasOwnProperty("composers")) {
              if (!Array.isArray(message.composers))
                return "composers: array expected";
              for (var i = 0; i < message.composers.length; ++i)
                if (!$util.isString(message.composers[i]))
                  return "composers: string[] expected";
            }
            return null;
          };
          SequenceMetadata.fromObject = function fromObject(object) {
            if (object instanceof $root.tensorflow.magenta.SequenceMetadata)
              return object;
            var message = new $root.tensorflow.magenta.SequenceMetadata();
            if (object.title != null)
              message.title = String(object.title);
            if (object.artist != null)
              message.artist = String(object.artist);
            if (object.genre) {
              if (!Array.isArray(object.genre))
                throw TypeError(".tensorflow.magenta.SequenceMetadata.genre: array expected");
              message.genre = [];
              for (var i = 0; i < object.genre.length; ++i)
                message.genre[i] = String(object.genre[i]);
            }
            if (object.composers) {
              if (!Array.isArray(object.composers))
                throw TypeError(".tensorflow.magenta.SequenceMetadata.composers: array expected");
              message.composers = [];
              for (var i = 0; i < object.composers.length; ++i)
                message.composers[i] = String(object.composers[i]);
            }
            return message;
          };
          SequenceMetadata.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults) {
              object.genre = [];
              object.composers = [];
            }
            if (options.defaults) {
              object.title = "";
              object.artist = "";
            }
            if (message.title != null && message.hasOwnProperty("title"))
              object.title = message.title;
            if (message.artist != null && message.hasOwnProperty("artist"))
              object.artist = message.artist;
            if (message.genre && message.genre.length) {
              object.genre = [];
              for (var j = 0; j < message.genre.length; ++j)
                object.genre[j] = message.genre[j];
            }
            if (message.composers && message.composers.length) {
              object.composers = [];
              for (var j = 0; j < message.composers.length; ++j)
                object.composers[j] = message.composers[j];
            }
            return object;
          };
          SequenceMetadata.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return SequenceMetadata;
        })();
        magenta.VelocityRange = (function() {
          function VelocityRange(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          VelocityRange.prototype.min = 0;
          VelocityRange.prototype.max = 0;
          VelocityRange.create = function create(properties) {
            return new VelocityRange(properties);
          };
          VelocityRange.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.min != null && message.hasOwnProperty("min"))
              writer.uint32(
                /* id 1, wireType 0 =*/
                8
              ).int32(message.min);
            if (message.max != null && message.hasOwnProperty("max"))
              writer.uint32(
                /* id 2, wireType 0 =*/
                16
              ).int32(message.max);
            return writer;
          };
          VelocityRange.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          VelocityRange.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.tensorflow.magenta.VelocityRange();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.min = reader.int32();
                  break;
                case 2:
                  message.max = reader.int32();
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          VelocityRange.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          VelocityRange.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.min != null && message.hasOwnProperty("min")) {
              if (!$util.isInteger(message.min))
                return "min: integer expected";
            }
            if (message.max != null && message.hasOwnProperty("max")) {
              if (!$util.isInteger(message.max))
                return "max: integer expected";
            }
            return null;
          };
          VelocityRange.fromObject = function fromObject(object) {
            if (object instanceof $root.tensorflow.magenta.VelocityRange)
              return object;
            var message = new $root.tensorflow.magenta.VelocityRange();
            if (object.min != null)
              message.min = object.min | 0;
            if (object.max != null)
              message.max = object.max | 0;
            return message;
          };
          VelocityRange.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults) {
              object.min = 0;
              object.max = 0;
            }
            if (message.min != null && message.hasOwnProperty("min"))
              object.min = message.min;
            if (message.max != null && message.hasOwnProperty("max"))
              object.max = message.max;
            return object;
          };
          VelocityRange.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return VelocityRange;
        })();
        return magenta;
      })();
      return tensorflow2;
    })();
    module2.exports = $root;
  }
});

// node_modules/node-fetch/browser.js
var require_browser = __commonJS({
  "node_modules/node-fetch/browser.js"(exports2, module2) {
    "use strict";
    var getGlobal = function() {
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw new Error("unable to locate global object");
    };
    var globalObject2 = getGlobal();
    module2.exports = exports2 = globalObject2.fetch;
    if (globalObject2.fetch) {
      exports2.default = globalObject2.fetch.bind(globalObject2);
    }
    exports2.Headers = globalObject2.Headers;
    exports2.Request = globalObject2.Request;
    exports2.Response = globalObject2.Response;
  }
});

// node_modules/@magenta/music/esm/core/compat/performance_node.js
var performance_node_exports = {};
__export(performance_node_exports, {
  now: () => now,
  timing: () => timing
});
var NS_PER_SEC, time, now, timing;
var init_performance_node = __esm({
  "node_modules/@magenta/music/esm/core/compat/performance_node.js"() {
    NS_PER_SEC = 1e9;
    time = global.process.hrtime();
    now = () => {
      const diff = global.process.hrtime(time);
      return diff[0] + diff[1] / NS_PER_SEC;
    };
    timing = {
      navigationStart: Date.now()
    };
  }
});

// node_modules/@magenta/music/esm/core/compat/navigator_node.js
var navigator_node_exports = {};
__export(navigator_node_exports, {
  userAgent: () => userAgent
});
var userAgent;
var init_navigator_node = __esm({
  "node_modules/@magenta/music/esm/core/compat/navigator_node.js"() {
    userAgent = "";
  }
});

// node_modules/midi-file/lib/midi-parser.js
var require_midi_parser = __commonJS({
  "node_modules/midi-file/lib/midi-parser.js"(exports2, module2) {
    function parseMidi(data) {
      var p = new Parser(data);
      var headerChunk = p.readChunk();
      if (headerChunk.id != "MThd")
        throw "Bad MIDI file.  Expected 'MHdr', got: '" + headerChunk.id + "'";
      var header = parseHeader(headerChunk.data);
      var tracks = [];
      for (var i = 0; !p.eof() && i < header.numTracks; i++) {
        var trackChunk = p.readChunk();
        if (trackChunk.id != "MTrk")
          throw "Bad MIDI file.  Expected 'MTrk', got: '" + trackChunk.id + "'";
        var track = parseTrack(trackChunk.data);
        tracks.push(track);
      }
      return {
        header,
        tracks
      };
    }
    function parseHeader(data) {
      var p = new Parser(data);
      var format = p.readUInt16();
      var numTracks = p.readUInt16();
      var result = {
        format,
        numTracks
      };
      var timeDivision = p.readUInt16();
      if (timeDivision & 32768) {
        result.framesPerSecond = 256 - (timeDivision >> 8);
        result.ticksPerFrame = timeDivision & 255;
      } else {
        result.ticksPerBeat = timeDivision;
      }
      return result;
    }
    function parseTrack(data) {
      var p = new Parser(data);
      var events = [];
      while (!p.eof()) {
        var event = readEvent();
        events.push(event);
      }
      return events;
      var lastEventTypeByte = null;
      function readEvent() {
        var event2 = {};
        event2.deltaTime = p.readVarInt();
        var eventTypeByte = p.readUInt8();
        if ((eventTypeByte & 240) === 240) {
          if (eventTypeByte === 255) {
            event2.meta = true;
            var metatypeByte = p.readUInt8();
            var length = p.readVarInt();
            switch (metatypeByte) {
              case 0:
                event2.type = "sequenceNumber";
                if (length !== 2) throw "Expected length for sequenceNumber event is 2, got " + length;
                event2.number = p.readUInt16();
                return event2;
              case 1:
                event2.type = "text";
                event2.text = p.readString(length);
                return event2;
              case 2:
                event2.type = "copyrightNotice";
                event2.text = p.readString(length);
                return event2;
              case 3:
                event2.type = "trackName";
                event2.text = p.readString(length);
                return event2;
              case 4:
                event2.type = "instrumentName";
                event2.text = p.readString(length);
                return event2;
              case 5:
                event2.type = "lyrics";
                event2.text = p.readString(length);
                return event2;
              case 6:
                event2.type = "marker";
                event2.text = p.readString(length);
                return event2;
              case 7:
                event2.type = "cuePoint";
                event2.text = p.readString(length);
                return event2;
              case 32:
                event2.type = "channelPrefix";
                if (length != 1) throw "Expected length for channelPrefix event is 1, got " + length;
                event2.channel = p.readUInt8();
                return event2;
              case 33:
                event2.type = "portPrefix";
                if (length != 1) throw "Expected length for portPrefix event is 1, got " + length;
                event2.port = p.readUInt8();
                return event2;
              case 47:
                event2.type = "endOfTrack";
                if (length != 0) throw "Expected length for endOfTrack event is 0, got " + length;
                return event2;
              case 81:
                event2.type = "setTempo";
                if (length != 3) throw "Expected length for setTempo event is 3, got " + length;
                event2.microsecondsPerBeat = p.readUInt24();
                return event2;
              case 84:
                event2.type = "smpteOffset";
                if (length != 5) throw "Expected length for smpteOffset event is 5, got " + length;
                var hourByte = p.readUInt8();
                var FRAME_RATES = { 0: 24, 32: 25, 64: 29, 96: 30 };
                event2.frameRate = FRAME_RATES[hourByte & 96];
                event2.hour = hourByte & 31;
                event2.min = p.readUInt8();
                event2.sec = p.readUInt8();
                event2.frame = p.readUInt8();
                event2.subFrame = p.readUInt8();
                return event2;
              case 88:
                event2.type = "timeSignature";
                if (length != 2 && length != 4) throw "Expected length for timeSignature event is 4 or 2, got " + length;
                event2.numerator = p.readUInt8();
                event2.denominator = 1 << p.readUInt8();
                if (length === 4) {
                  event2.metronome = p.readUInt8();
                  event2.thirtyseconds = p.readUInt8();
                } else {
                  event2.metronome = 36;
                  event2.thirtyseconds = 8;
                }
                return event2;
              case 89:
                event2.type = "keySignature";
                if (length != 2) throw "Expected length for keySignature event is 2, got " + length;
                event2.key = p.readInt8();
                event2.scale = p.readUInt8();
                return event2;
              case 127:
                event2.type = "sequencerSpecific";
                event2.data = p.readBytes(length);
                return event2;
              default:
                event2.type = "unknownMeta";
                event2.data = p.readBytes(length);
                event2.metatypeByte = metatypeByte;
                return event2;
            }
          } else if (eventTypeByte == 240) {
            event2.type = "sysEx";
            var length = p.readVarInt();
            event2.data = p.readBytes(length);
            return event2;
          } else if (eventTypeByte == 247) {
            event2.type = "endSysEx";
            var length = p.readVarInt();
            event2.data = p.readBytes(length);
            return event2;
          } else {
            throw "Unrecognised MIDI event type byte: " + eventTypeByte;
          }
        } else {
          var param1;
          if ((eventTypeByte & 128) === 0) {
            if (lastEventTypeByte === null)
              throw "Running status byte encountered before status byte";
            param1 = eventTypeByte;
            eventTypeByte = lastEventTypeByte;
            event2.running = true;
          } else {
            param1 = p.readUInt8();
            lastEventTypeByte = eventTypeByte;
          }
          var eventType = eventTypeByte >> 4;
          event2.channel = eventTypeByte & 15;
          switch (eventType) {
            case 8:
              event2.type = "noteOff";
              event2.noteNumber = param1;
              event2.velocity = p.readUInt8();
              return event2;
            case 9:
              var velocity = p.readUInt8();
              event2.type = velocity === 0 ? "noteOff" : "noteOn";
              event2.noteNumber = param1;
              event2.velocity = velocity;
              if (velocity === 0) event2.byte9 = true;
              return event2;
            case 10:
              event2.type = "noteAftertouch";
              event2.noteNumber = param1;
              event2.amount = p.readUInt8();
              return event2;
            case 11:
              event2.type = "controller";
              event2.controllerType = param1;
              event2.value = p.readUInt8();
              return event2;
            case 12:
              event2.type = "programChange";
              event2.programNumber = param1;
              return event2;
            case 13:
              event2.type = "channelAftertouch";
              event2.amount = param1;
              return event2;
            case 14:
              event2.type = "pitchBend";
              event2.value = param1 + (p.readUInt8() << 7) - 8192;
              return event2;
            default:
              throw "Unrecognised MIDI event type: " + eventType;
          }
        }
      }
    }
    function Parser(data) {
      this.buffer = data;
      this.bufferLen = this.buffer.length;
      this.pos = 0;
    }
    Parser.prototype.eof = function() {
      return this.pos >= this.bufferLen;
    };
    Parser.prototype.readUInt8 = function() {
      var result = this.buffer[this.pos];
      this.pos += 1;
      return result;
    };
    Parser.prototype.readInt8 = function() {
      var u = this.readUInt8();
      if (u & 128)
        return u - 256;
      else
        return u;
    };
    Parser.prototype.readUInt16 = function() {
      var b0 = this.readUInt8(), b1 = this.readUInt8();
      return (b0 << 8) + b1;
    };
    Parser.prototype.readInt16 = function() {
      var u = this.readUInt16();
      if (u & 32768)
        return u - 65536;
      else
        return u;
    };
    Parser.prototype.readUInt24 = function() {
      var b0 = this.readUInt8(), b1 = this.readUInt8(), b2 = this.readUInt8();
      return (b0 << 16) + (b1 << 8) + b2;
    };
    Parser.prototype.readInt24 = function() {
      var u = this.readUInt24();
      if (u & 8388608)
        return u - 16777216;
      else
        return u;
    };
    Parser.prototype.readUInt32 = function() {
      var b0 = this.readUInt8(), b1 = this.readUInt8(), b2 = this.readUInt8(), b3 = this.readUInt8();
      return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
    };
    Parser.prototype.readBytes = function(len) {
      var bytes = this.buffer.slice(this.pos, this.pos + len);
      this.pos += len;
      return bytes;
    };
    Parser.prototype.readString = function(len) {
      var bytes = this.readBytes(len);
      return String.fromCharCode.apply(null, bytes);
    };
    Parser.prototype.readVarInt = function() {
      var result = 0;
      while (!this.eof()) {
        var b = this.readUInt8();
        if (b & 128) {
          result += b & 127;
          result <<= 7;
        } else {
          return result + b;
        }
      }
      return result;
    };
    Parser.prototype.readChunk = function() {
      var id = this.readString(4);
      var length = this.readUInt32();
      var data = this.readBytes(length);
      return {
        id,
        length,
        data
      };
    };
    module2.exports = parseMidi;
  }
});

// node_modules/midi-file/lib/midi-writer.js
var require_midi_writer = __commonJS({
  "node_modules/midi-file/lib/midi-writer.js"(exports2, module2) {
    function writeMidi(data, opts) {
      if (typeof data !== "object")
        throw "Invalid MIDI data";
      opts = opts || {};
      var header = data.header || {};
      var tracks = data.tracks || [];
      var i, len = tracks.length;
      var w = new Writer();
      writeHeader(w, header, len);
      for (i = 0; i < len; i++) {
        writeTrack(w, tracks[i], opts);
      }
      return w.buffer;
    }
    function writeHeader(w, header, numTracks) {
      var format = header.format == null ? 1 : header.format;
      var timeDivision = 128;
      if (header.timeDivision) {
        timeDivision = header.timeDivision;
      } else if (header.ticksPerFrame && header.framesPerSecond) {
        timeDivision = -(header.framesPerSecond & 255) << 8 | header.ticksPerFrame & 255;
      } else if (header.ticksPerBeat) {
        timeDivision = header.ticksPerBeat & 32767;
      }
      var h = new Writer();
      h.writeUInt16(format);
      h.writeUInt16(numTracks);
      h.writeUInt16(timeDivision);
      w.writeChunk("MThd", h.buffer);
    }
    function writeTrack(w, track, opts) {
      var t = new Writer();
      var i, len = track.length;
      var eventTypeByte = null;
      for (i = 0; i < len; i++) {
        if (opts.running === false || !opts.running && !track[i].running) eventTypeByte = null;
        eventTypeByte = writeEvent(t, track[i], eventTypeByte, opts.useByte9ForNoteOff);
      }
      w.writeChunk("MTrk", t.buffer);
    }
    function writeEvent(w, event, lastEventTypeByte, useByte9ForNoteOff) {
      var type = event.type;
      var deltaTime = event.deltaTime;
      var text = event.text || "";
      var data = event.data || [];
      var eventTypeByte = null;
      w.writeVarInt(deltaTime);
      switch (type) {
        // meta events
        case "sequenceNumber":
          w.writeUInt8(255);
          w.writeUInt8(0);
          w.writeVarInt(2);
          w.writeUInt16(event.number);
          break;
        case "text":
          w.writeUInt8(255);
          w.writeUInt8(1);
          w.writeVarInt(text.length);
          w.writeString(text);
          break;
        case "copyrightNotice":
          w.writeUInt8(255);
          w.writeUInt8(2);
          w.writeVarInt(text.length);
          w.writeString(text);
          break;
        case "trackName":
          w.writeUInt8(255);
          w.writeUInt8(3);
          w.writeVarInt(text.length);
          w.writeString(text);
          break;
        case "instrumentName":
          w.writeUInt8(255);
          w.writeUInt8(4);
          w.writeVarInt(text.length);
          w.writeString(text);
          break;
        case "lyrics":
          w.writeUInt8(255);
          w.writeUInt8(5);
          w.writeVarInt(text.length);
          w.writeString(text);
          break;
        case "marker":
          w.writeUInt8(255);
          w.writeUInt8(6);
          w.writeVarInt(text.length);
          w.writeString(text);
          break;
        case "cuePoint":
          w.writeUInt8(255);
          w.writeUInt8(7);
          w.writeVarInt(text.length);
          w.writeString(text);
          break;
        case "channelPrefix":
          w.writeUInt8(255);
          w.writeUInt8(32);
          w.writeVarInt(1);
          w.writeUInt8(event.channel);
          break;
        case "portPrefix":
          w.writeUInt8(255);
          w.writeUInt8(33);
          w.writeVarInt(1);
          w.writeUInt8(event.port);
          break;
        case "endOfTrack":
          w.writeUInt8(255);
          w.writeUInt8(47);
          w.writeVarInt(0);
          break;
        case "setTempo":
          w.writeUInt8(255);
          w.writeUInt8(81);
          w.writeVarInt(3);
          w.writeUInt24(event.microsecondsPerBeat);
          break;
        case "smpteOffset":
          w.writeUInt8(255);
          w.writeUInt8(84);
          w.writeVarInt(5);
          var FRAME_RATES = { 24: 0, 25: 32, 29: 64, 30: 96 };
          var hourByte = event.hour & 31 | FRAME_RATES[event.frameRate];
          w.writeUInt8(hourByte);
          w.writeUInt8(event.min);
          w.writeUInt8(event.sec);
          w.writeUInt8(event.frame);
          w.writeUInt8(event.subFrame);
          break;
        case "timeSignature":
          w.writeUInt8(255);
          w.writeUInt8(88);
          w.writeVarInt(4);
          w.writeUInt8(event.numerator);
          var denominator = Math.floor(Math.log(event.denominator) / Math.LN2) & 255;
          w.writeUInt8(denominator);
          w.writeUInt8(event.metronome);
          w.writeUInt8(event.thirtyseconds || 8);
          break;
        case "keySignature":
          w.writeUInt8(255);
          w.writeUInt8(89);
          w.writeVarInt(2);
          w.writeInt8(event.key);
          w.writeUInt8(event.scale);
          break;
        case "sequencerSpecific":
          w.writeUInt8(255);
          w.writeUInt8(127);
          w.writeVarInt(data.length);
          w.writeBytes(data);
          break;
        case "unknownMeta":
          if (event.metatypeByte != null) {
            w.writeUInt8(255);
            w.writeUInt8(event.metatypeByte);
            w.writeVarInt(data.length);
            w.writeBytes(data);
          }
          break;
        // system-exclusive
        case "sysEx":
          w.writeUInt8(240);
          w.writeVarInt(data.length);
          w.writeBytes(data);
          break;
        case "endSysEx":
          w.writeUInt8(247);
          w.writeVarInt(data.length);
          w.writeBytes(data);
          break;
        // channel events
        case "noteOff":
          var noteByte = useByte9ForNoteOff !== false && event.byte9 || useByte9ForNoteOff && event.velocity == 0 ? 144 : 128;
          eventTypeByte = noteByte | event.channel;
          if (eventTypeByte !== lastEventTypeByte) w.writeUInt8(eventTypeByte);
          w.writeUInt8(event.noteNumber);
          w.writeUInt8(event.velocity);
          break;
        case "noteOn":
          eventTypeByte = 144 | event.channel;
          if (eventTypeByte !== lastEventTypeByte) w.writeUInt8(eventTypeByte);
          w.writeUInt8(event.noteNumber);
          w.writeUInt8(event.velocity);
          break;
        case "noteAftertouch":
          eventTypeByte = 160 | event.channel;
          if (eventTypeByte !== lastEventTypeByte) w.writeUInt8(eventTypeByte);
          w.writeUInt8(event.noteNumber);
          w.writeUInt8(event.amount);
          break;
        case "controller":
          eventTypeByte = 176 | event.channel;
          if (eventTypeByte !== lastEventTypeByte) w.writeUInt8(eventTypeByte);
          w.writeUInt8(event.controllerType);
          w.writeUInt8(event.value);
          break;
        case "programChange":
          eventTypeByte = 192 | event.channel;
          if (eventTypeByte !== lastEventTypeByte) w.writeUInt8(eventTypeByte);
          w.writeUInt8(event.programNumber);
          break;
        case "channelAftertouch":
          eventTypeByte = 208 | event.channel;
          if (eventTypeByte !== lastEventTypeByte) w.writeUInt8(eventTypeByte);
          w.writeUInt8(event.amount);
          break;
        case "pitchBend":
          eventTypeByte = 224 | event.channel;
          if (eventTypeByte !== lastEventTypeByte) w.writeUInt8(eventTypeByte);
          var value14 = 8192 + event.value;
          var lsb14 = value14 & 127;
          var msb14 = value14 >> 7 & 127;
          w.writeUInt8(lsb14);
          w.writeUInt8(msb14);
          break;
        default:
          throw "Unrecognized event type: " + type;
      }
      return eventTypeByte;
    }
    function Writer() {
      this.buffer = [];
    }
    Writer.prototype.writeUInt8 = function(v) {
      this.buffer.push(v & 255);
    };
    Writer.prototype.writeInt8 = Writer.prototype.writeUInt8;
    Writer.prototype.writeUInt16 = function(v) {
      var b0 = v >> 8 & 255, b1 = v & 255;
      this.writeUInt8(b0);
      this.writeUInt8(b1);
    };
    Writer.prototype.writeInt16 = Writer.prototype.writeUInt16;
    Writer.prototype.writeUInt24 = function(v) {
      var b0 = v >> 16 & 255, b1 = v >> 8 & 255, b2 = v & 255;
      this.writeUInt8(b0);
      this.writeUInt8(b1);
      this.writeUInt8(b2);
    };
    Writer.prototype.writeInt24 = Writer.prototype.writeUInt24;
    Writer.prototype.writeUInt32 = function(v) {
      var b0 = v >> 24 & 255, b1 = v >> 16 & 255, b2 = v >> 8 & 255, b3 = v & 255;
      this.writeUInt8(b0);
      this.writeUInt8(b1);
      this.writeUInt8(b2);
      this.writeUInt8(b3);
    };
    Writer.prototype.writeInt32 = Writer.prototype.writeUInt32;
    Writer.prototype.writeBytes = function(arr) {
      this.buffer = this.buffer.concat(Array.prototype.slice.call(arr, 0));
    };
    Writer.prototype.writeString = function(str) {
      var i, len = str.length, arr = [];
      for (i = 0; i < len; i++) {
        arr.push(str.codePointAt(i));
      }
      this.writeBytes(arr);
    };
    Writer.prototype.writeVarInt = function(v) {
      if (v < 0) throw "Cannot write negative variable-length integer";
      if (v <= 127) {
        this.writeUInt8(v);
      } else {
        var i = v;
        var bytes = [];
        bytes.push(i & 127);
        i >>= 7;
        while (i) {
          var b = i & 127 | 128;
          bytes.push(b);
          i >>= 7;
        }
        this.writeBytes(bytes.reverse());
      }
    };
    Writer.prototype.writeChunk = function(id, data) {
      this.writeString(id);
      this.writeUInt32(data.length);
      this.writeBytes(data);
    };
    module2.exports = writeMidi;
  }
});

// node_modules/midi-file/index.js
var require_midi_file = __commonJS({
  "node_modules/midi-file/index.js"(exports2) {
    exports2.parseMidi = require_midi_parser();
    exports2.writeMidi = require_midi_writer();
  }
});

// node_modules/@tonejs/midi/dist/BinarySearch.js
var require_BinarySearch = __commonJS({
  "node_modules/@tonejs/midi/dist/BinarySearch.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.insert = exports2.search = void 0;
    function search(array, value, prop) {
      if (prop === void 0) {
        prop = "ticks";
      }
      var beginning = 0;
      var len = array.length;
      var end = len;
      if (len > 0 && array[len - 1][prop] <= value) {
        return len - 1;
      }
      while (beginning < end) {
        var midPoint = Math.floor(beginning + (end - beginning) / 2);
        var event_1 = array[midPoint];
        var nextEvent = array[midPoint + 1];
        if (event_1[prop] === value) {
          for (var i = midPoint; i < array.length; i++) {
            var testEvent = array[i];
            if (testEvent[prop] === value) {
              midPoint = i;
            }
          }
          return midPoint;
        } else if (event_1[prop] < value && nextEvent[prop] > value) {
          return midPoint;
        } else if (event_1[prop] > value) {
          end = midPoint;
        } else if (event_1[prop] < value) {
          beginning = midPoint + 1;
        }
      }
      return -1;
    }
    exports2.search = search;
    function insert(array, event, prop) {
      if (prop === void 0) {
        prop = "ticks";
      }
      if (array.length) {
        var index = search(array, event[prop], prop);
        array.splice(index + 1, 0, event);
      } else {
        array.push(event);
      }
    }
    exports2.insert = insert;
  }
});

// node_modules/@tonejs/midi/dist/Header.js
var require_Header = __commonJS({
  "node_modules/@tonejs/midi/dist/Header.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Header = exports2.keySignatureKeys = void 0;
    var BinarySearch_1 = require_BinarySearch();
    var privatePPQMap = /* @__PURE__ */ new WeakMap();
    exports2.keySignatureKeys = [
      "Cb",
      "Gb",
      "Db",
      "Ab",
      "Eb",
      "Bb",
      "F",
      "C",
      "G",
      "D",
      "A",
      "E",
      "B",
      "F#",
      "C#"
    ];
    var Header = (
      /** @class */
      (function() {
        function Header2(midiData) {
          var _this = this;
          this.tempos = [];
          this.timeSignatures = [];
          this.keySignatures = [];
          this.meta = [];
          this.name = "";
          privatePPQMap.set(this, 480);
          if (midiData) {
            privatePPQMap.set(this, midiData.header.ticksPerBeat);
            midiData.tracks.forEach(function(track) {
              track.forEach(function(event) {
                if (event.meta) {
                  if (event.type === "timeSignature") {
                    _this.timeSignatures.push({
                      ticks: event.absoluteTime,
                      timeSignature: [
                        event.numerator,
                        event.denominator
                      ]
                    });
                  } else if (event.type === "setTempo") {
                    _this.tempos.push({
                      bpm: 6e7 / event.microsecondsPerBeat,
                      ticks: event.absoluteTime
                    });
                  } else if (event.type === "keySignature") {
                    _this.keySignatures.push({
                      key: exports2.keySignatureKeys[event.key + 7],
                      scale: event.scale === 0 ? "major" : "minor",
                      ticks: event.absoluteTime
                    });
                  }
                }
              });
            });
            var firstTrackCurrentTicks_1 = 0;
            midiData.tracks[0].forEach(function(event) {
              firstTrackCurrentTicks_1 += event.deltaTime;
              if (event.meta) {
                if (event.type === "trackName") {
                  _this.name = event.text;
                } else if (event.type === "text" || event.type === "cuePoint" || event.type === "marker" || event.type === "lyrics") {
                  _this.meta.push({
                    text: event.text,
                    ticks: firstTrackCurrentTicks_1,
                    type: event.type
                  });
                }
              }
            });
            this.update();
          }
        }
        Header2.prototype.update = function() {
          var _this = this;
          var currentTime = 0;
          var lastEventBeats = 0;
          this.tempos.sort(function(a, b) {
            return a.ticks - b.ticks;
          });
          this.tempos.forEach(function(event, index) {
            var lastBPM = index > 0 ? _this.tempos[index - 1].bpm : _this.tempos[0].bpm;
            var beats = event.ticks / _this.ppq - lastEventBeats;
            var elapsedSeconds = 60 / lastBPM * beats;
            event.time = elapsedSeconds + currentTime;
            currentTime = event.time;
            lastEventBeats += beats;
          });
          this.timeSignatures.sort(function(a, b) {
            return a.ticks - b.ticks;
          });
          this.timeSignatures.forEach(function(event, index) {
            var lastEvent = index > 0 ? _this.timeSignatures[index - 1] : _this.timeSignatures[0];
            var elapsedBeats = (event.ticks - lastEvent.ticks) / _this.ppq;
            var elapsedMeasures = elapsedBeats / lastEvent.timeSignature[0] / (lastEvent.timeSignature[1] / 4);
            lastEvent.measures = lastEvent.measures || 0;
            event.measures = elapsedMeasures + lastEvent.measures;
          });
        };
        Header2.prototype.ticksToSeconds = function(ticks) {
          var index = (0, BinarySearch_1.search)(this.tempos, ticks);
          if (index !== -1) {
            var tempo = this.tempos[index];
            var tempoTime = tempo.time;
            var elapsedBeats = (ticks - tempo.ticks) / this.ppq;
            return tempoTime + 60 / tempo.bpm * elapsedBeats;
          } else {
            var beats = ticks / this.ppq;
            return 60 / 120 * beats;
          }
        };
        Header2.prototype.ticksToMeasures = function(ticks) {
          var index = (0, BinarySearch_1.search)(this.timeSignatures, ticks);
          if (index !== -1) {
            var timeSigEvent = this.timeSignatures[index];
            var elapsedBeats = (ticks - timeSigEvent.ticks) / this.ppq;
            return timeSigEvent.measures + elapsedBeats / (timeSigEvent.timeSignature[0] / timeSigEvent.timeSignature[1]) / 4;
          } else {
            return ticks / this.ppq / 4;
          }
        };
        Object.defineProperty(Header2.prototype, "ppq", {
          /**
           * The number of ticks per quarter note.
           */
          get: function() {
            return privatePPQMap.get(this);
          },
          enumerable: false,
          configurable: true
        });
        Header2.prototype.secondsToTicks = function(seconds) {
          var index = (0, BinarySearch_1.search)(this.tempos, seconds, "time");
          if (index !== -1) {
            var tempo = this.tempos[index];
            var tempoTime = tempo.time;
            var elapsedTime = seconds - tempoTime;
            var elapsedBeats = elapsedTime / (60 / tempo.bpm);
            return Math.round(tempo.ticks + elapsedBeats * this.ppq);
          } else {
            var beats = seconds / (60 / 120);
            return Math.round(beats * this.ppq);
          }
        };
        Header2.prototype.toJSON = function() {
          return {
            keySignatures: this.keySignatures,
            meta: this.meta,
            name: this.name,
            ppq: this.ppq,
            tempos: this.tempos.map(function(t) {
              return {
                bpm: t.bpm,
                ticks: t.ticks
              };
            }),
            timeSignatures: this.timeSignatures
          };
        };
        Header2.prototype.fromJSON = function(json) {
          this.name = json.name;
          this.tempos = json.tempos.map(function(t) {
            return Object.assign({}, t);
          });
          this.timeSignatures = json.timeSignatures.map(function(t) {
            return Object.assign({}, t);
          });
          this.keySignatures = json.keySignatures.map(function(t) {
            return Object.assign({}, t);
          });
          this.meta = json.meta.map(function(t) {
            return Object.assign({}, t);
          });
          privatePPQMap.set(this, json.ppq);
          this.update();
        };
        Header2.prototype.setTempo = function(bpm) {
          this.tempos = [
            {
              bpm,
              ticks: 0
            }
          ];
          this.update();
        };
        return Header2;
      })()
    );
    exports2.Header = Header;
  }
});

// node_modules/@tonejs/midi/dist/ControlChange.js
var require_ControlChange = __commonJS({
  "node_modules/@tonejs/midi/dist/ControlChange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ControlChange = exports2.controlChangeIds = exports2.controlChangeNames = void 0;
    exports2.controlChangeNames = {
      1: "modulationWheel",
      2: "breath",
      4: "footController",
      5: "portamentoTime",
      7: "volume",
      8: "balance",
      10: "pan",
      64: "sustain",
      65: "portamentoTime",
      66: "sostenuto",
      67: "softPedal",
      68: "legatoFootswitch",
      84: "portamentoControl"
    };
    exports2.controlChangeIds = Object.keys(exports2.controlChangeNames).reduce(function(obj, key) {
      obj[exports2.controlChangeNames[key]] = key;
      return obj;
    }, {});
    var privateHeaderMap = /* @__PURE__ */ new WeakMap();
    var privateCCNumberMap = /* @__PURE__ */ new WeakMap();
    var ControlChange = (
      /** @class */
      (function() {
        function ControlChange2(event, header) {
          privateHeaderMap.set(this, header);
          privateCCNumberMap.set(this, event.controllerType);
          this.ticks = event.absoluteTime;
          this.value = event.value;
        }
        Object.defineProperty(ControlChange2.prototype, "number", {
          /**
           * The controller number
           */
          get: function() {
            return privateCCNumberMap.get(this);
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(ControlChange2.prototype, "name", {
          /**
           * return the common name of the control number if it exists
           */
          get: function() {
            if (exports2.controlChangeNames[this.number]) {
              return exports2.controlChangeNames[this.number];
            } else {
              return null;
            }
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(ControlChange2.prototype, "time", {
          /**
           * The time of the event in seconds
           */
          get: function() {
            var header = privateHeaderMap.get(this);
            return header.ticksToSeconds(this.ticks);
          },
          set: function(t) {
            var header = privateHeaderMap.get(this);
            this.ticks = header.secondsToTicks(t);
          },
          enumerable: false,
          configurable: true
        });
        ControlChange2.prototype.toJSON = function() {
          return {
            number: this.number,
            ticks: this.ticks,
            time: this.time,
            value: this.value
          };
        };
        return ControlChange2;
      })()
    );
    exports2.ControlChange = ControlChange;
  }
});

// node_modules/@tonejs/midi/dist/ControlChanges.js
var require_ControlChanges = __commonJS({
  "node_modules/@tonejs/midi/dist/ControlChanges.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createControlChanges = void 0;
    var ControlChange_1 = require_ControlChange();
    function createControlChanges() {
      return new Proxy({}, {
        // tslint:disable-next-line: typedef
        get: function(target, handler) {
          if (target[handler]) {
            return target[handler];
          } else if (ControlChange_1.controlChangeIds.hasOwnProperty(handler)) {
            return target[ControlChange_1.controlChangeIds[handler]];
          }
        },
        // tslint:disable-next-line: typedef
        set: function(target, handler, value) {
          if (ControlChange_1.controlChangeIds.hasOwnProperty(handler)) {
            target[ControlChange_1.controlChangeIds[handler]] = value;
          } else {
            target[handler] = value;
          }
          return true;
        }
      });
    }
    exports2.createControlChanges = createControlChanges;
  }
});

// node_modules/@tonejs/midi/dist/PitchBend.js
var require_PitchBend = __commonJS({
  "node_modules/@tonejs/midi/dist/PitchBend.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PitchBend = void 0;
    var privateHeaderMap = /* @__PURE__ */ new WeakMap();
    var PitchBend = (
      /** @class */
      (function() {
        function PitchBend2(event, header) {
          privateHeaderMap.set(this, header);
          this.ticks = event.absoluteTime;
          this.value = event.value;
        }
        Object.defineProperty(PitchBend2.prototype, "time", {
          /**
           * The time of the event in seconds
           */
          get: function() {
            var header = privateHeaderMap.get(this);
            return header.ticksToSeconds(this.ticks);
          },
          set: function(t) {
            var header = privateHeaderMap.get(this);
            this.ticks = header.secondsToTicks(t);
          },
          enumerable: false,
          configurable: true
        });
        PitchBend2.prototype.toJSON = function() {
          return {
            ticks: this.ticks,
            time: this.time,
            value: this.value
          };
        };
        return PitchBend2;
      })()
    );
    exports2.PitchBend = PitchBend;
  }
});

// node_modules/@tonejs/midi/dist/InstrumentMaps.js
var require_InstrumentMaps = __commonJS({
  "node_modules/@tonejs/midi/dist/InstrumentMaps.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DrumKitByPatchID = exports2.InstrumentFamilyByID = exports2.instrumentByPatchID = void 0;
    exports2.instrumentByPatchID = [
      "acoustic grand piano",
      "bright acoustic piano",
      "electric grand piano",
      "honky-tonk piano",
      "electric piano 1",
      "electric piano 2",
      "harpsichord",
      "clavi",
      "celesta",
      "glockenspiel",
      "music box",
      "vibraphone",
      "marimba",
      "xylophone",
      "tubular bells",
      "dulcimer",
      "drawbar organ",
      "percussive organ",
      "rock organ",
      "church organ",
      "reed organ",
      "accordion",
      "harmonica",
      "tango accordion",
      "acoustic guitar (nylon)",
      "acoustic guitar (steel)",
      "electric guitar (jazz)",
      "electric guitar (clean)",
      "electric guitar (muted)",
      "overdriven guitar",
      "distortion guitar",
      "guitar harmonics",
      "acoustic bass",
      "electric bass (finger)",
      "electric bass (pick)",
      "fretless bass",
      "slap bass 1",
      "slap bass 2",
      "synth bass 1",
      "synth bass 2",
      "violin",
      "viola",
      "cello",
      "contrabass",
      "tremolo strings",
      "pizzicato strings",
      "orchestral harp",
      "timpani",
      "string ensemble 1",
      "string ensemble 2",
      "synthstrings 1",
      "synthstrings 2",
      "choir aahs",
      "voice oohs",
      "synth voice",
      "orchestra hit",
      "trumpet",
      "trombone",
      "tuba",
      "muted trumpet",
      "french horn",
      "brass section",
      "synthbrass 1",
      "synthbrass 2",
      "soprano sax",
      "alto sax",
      "tenor sax",
      "baritone sax",
      "oboe",
      "english horn",
      "bassoon",
      "clarinet",
      "piccolo",
      "flute",
      "recorder",
      "pan flute",
      "blown bottle",
      "shakuhachi",
      "whistle",
      "ocarina",
      "lead 1 (square)",
      "lead 2 (sawtooth)",
      "lead 3 (calliope)",
      "lead 4 (chiff)",
      "lead 5 (charang)",
      "lead 6 (voice)",
      "lead 7 (fifths)",
      "lead 8 (bass + lead)",
      "pad 1 (new age)",
      "pad 2 (warm)",
      "pad 3 (polysynth)",
      "pad 4 (choir)",
      "pad 5 (bowed)",
      "pad 6 (metallic)",
      "pad 7 (halo)",
      "pad 8 (sweep)",
      "fx 1 (rain)",
      "fx 2 (soundtrack)",
      "fx 3 (crystal)",
      "fx 4 (atmosphere)",
      "fx 5 (brightness)",
      "fx 6 (goblins)",
      "fx 7 (echoes)",
      "fx 8 (sci-fi)",
      "sitar",
      "banjo",
      "shamisen",
      "koto",
      "kalimba",
      "bag pipe",
      "fiddle",
      "shanai",
      "tinkle bell",
      "agogo",
      "steel drums",
      "woodblock",
      "taiko drum",
      "melodic tom",
      "synth drum",
      "reverse cymbal",
      "guitar fret noise",
      "breath noise",
      "seashore",
      "bird tweet",
      "telephone ring",
      "helicopter",
      "applause",
      "gunshot"
    ];
    exports2.InstrumentFamilyByID = [
      "piano",
      "chromatic percussion",
      "organ",
      "guitar",
      "bass",
      "strings",
      "ensemble",
      "brass",
      "reed",
      "pipe",
      "synth lead",
      "synth pad",
      "synth effects",
      "world",
      "percussive",
      "sound effects"
    ];
    exports2.DrumKitByPatchID = {
      0: "standard kit",
      8: "room kit",
      16: "power kit",
      24: "electronic kit",
      25: "tr-808 kit",
      32: "jazz kit",
      40: "brush kit",
      48: "orchestra kit",
      56: "sound fx kit"
    };
  }
});

// node_modules/@tonejs/midi/dist/Instrument.js
var require_Instrument = __commonJS({
  "node_modules/@tonejs/midi/dist/Instrument.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Instrument = void 0;
    var InstrumentMaps_1 = require_InstrumentMaps();
    var privateTrackMap = /* @__PURE__ */ new WeakMap();
    var Instrument3 = (
      /** @class */
      (function() {
        function Instrument4(trackData, track) {
          this.number = 0;
          privateTrackMap.set(this, track);
          this.number = 0;
          if (trackData) {
            var programChange = trackData.find(function(e) {
              return e.type === "programChange";
            });
            if (programChange) {
              this.number = programChange.programNumber;
            }
          }
        }
        Object.defineProperty(Instrument4.prototype, "name", {
          /**
           * The common name of the instrument.
           */
          get: function() {
            if (this.percussion) {
              return InstrumentMaps_1.DrumKitByPatchID[this.number];
            } else {
              return InstrumentMaps_1.instrumentByPatchID[this.number];
            }
          },
          set: function(n) {
            var patchNumber = InstrumentMaps_1.instrumentByPatchID.indexOf(n);
            if (patchNumber !== -1) {
              this.number = patchNumber;
            }
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Instrument4.prototype, "family", {
          /**
           * The instrument family, e.g. "piano".
           */
          get: function() {
            if (this.percussion) {
              return "drums";
            } else {
              return InstrumentMaps_1.InstrumentFamilyByID[Math.floor(this.number / 8)];
            }
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Instrument4.prototype, "percussion", {
          /**
           * If the instrument is a percussion instrument.
           */
          get: function() {
            var track = privateTrackMap.get(this);
            return track.channel === 9;
          },
          enumerable: false,
          configurable: true
        });
        Instrument4.prototype.toJSON = function() {
          return {
            family: this.family,
            number: this.number,
            name: this.name
          };
        };
        Instrument4.prototype.fromJSON = function(json) {
          this.number = json.number;
        };
        return Instrument4;
      })()
    );
    exports2.Instrument = Instrument3;
  }
});

// node_modules/@tonejs/midi/dist/Note.js
var require_Note = __commonJS({
  "node_modules/@tonejs/midi/dist/Note.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Note = void 0;
    function midiToPitch(midi) {
      var octave = Math.floor(midi / 12) - 1;
      return midiToPitchClass(midi) + octave.toString();
    }
    function midiToPitchClass(midi) {
      var scaleIndexToNote2 = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
      var note = midi % 12;
      return scaleIndexToNote2[note];
    }
    function pitchClassToMidi(pitch) {
      var scaleIndexToNote2 = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
      return scaleIndexToNote2.indexOf(pitch);
    }
    var pitchToMidi = /* @__PURE__ */ (function() {
      var regexp = /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i;
      var noteToScaleIndex2 = {
        // tslint:disable-next-line: object-literal-sort-keys
        cbb: -2,
        cb: -1,
        c: 0,
        "c#": 1,
        cx: 2,
        dbb: 0,
        db: 1,
        d: 2,
        "d#": 3,
        dx: 4,
        ebb: 2,
        eb: 3,
        e: 4,
        "e#": 5,
        ex: 6,
        fbb: 3,
        fb: 4,
        f: 5,
        "f#": 6,
        fx: 7,
        gbb: 5,
        gb: 6,
        g: 7,
        "g#": 8,
        gx: 9,
        abb: 7,
        ab: 8,
        a: 9,
        "a#": 10,
        ax: 11,
        bbb: 9,
        bb: 10,
        b: 11,
        "b#": 12,
        bx: 13
      };
      return function(note) {
        var split3 = regexp.exec(note);
        var pitch = split3[1];
        var octave = split3[2];
        var index = noteToScaleIndex2[pitch.toLowerCase()];
        return index + (parseInt(octave, 10) + 1) * 12;
      };
    })();
    var privateHeaderMap = /* @__PURE__ */ new WeakMap();
    var Note = (
      /** @class */
      (function() {
        function Note2(noteOn, noteOff, header) {
          privateHeaderMap.set(this, header);
          this.midi = noteOn.midi;
          this.velocity = noteOn.velocity;
          this.noteOffVelocity = noteOff.velocity;
          this.ticks = noteOn.ticks;
          this.durationTicks = noteOff.ticks - noteOn.ticks;
        }
        Object.defineProperty(Note2.prototype, "name", {
          /**
           * The note name and octave in scientific pitch notation, e.g. "C4".
           */
          get: function() {
            return midiToPitch(this.midi);
          },
          set: function(n) {
            this.midi = pitchToMidi(n);
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Note2.prototype, "octave", {
          /**
           * The notes octave number.
           */
          get: function() {
            return Math.floor(this.midi / 12) - 1;
          },
          set: function(o) {
            var diff = o - this.octave;
            this.midi += diff * 12;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Note2.prototype, "pitch", {
          /**
           * The pitch class name. e.g. "A".
           */
          get: function() {
            return midiToPitchClass(this.midi);
          },
          set: function(p) {
            this.midi = 12 * (this.octave + 1) + pitchClassToMidi(p);
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Note2.prototype, "duration", {
          /**
           * The duration of the segment in seconds.
           */
          get: function() {
            var header = privateHeaderMap.get(this);
            return header.ticksToSeconds(this.ticks + this.durationTicks) - header.ticksToSeconds(this.ticks);
          },
          set: function(d) {
            var header = privateHeaderMap.get(this);
            var noteEndTicks = header.secondsToTicks(this.time + d);
            this.durationTicks = noteEndTicks - this.ticks;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Note2.prototype, "time", {
          /**
           * The time of the event in seconds.
           */
          get: function() {
            var header = privateHeaderMap.get(this);
            return header.ticksToSeconds(this.ticks);
          },
          set: function(t) {
            var header = privateHeaderMap.get(this);
            this.ticks = header.secondsToTicks(t);
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Note2.prototype, "bars", {
          /**
           * The number of measures (and partial measures) to this beat.
           * Takes into account time signature changes.
           * @readonly
           */
          get: function() {
            var header = privateHeaderMap.get(this);
            return header.ticksToMeasures(this.ticks);
          },
          enumerable: false,
          configurable: true
        });
        Note2.prototype.toJSON = function() {
          return {
            duration: this.duration,
            durationTicks: this.durationTicks,
            midi: this.midi,
            name: this.name,
            ticks: this.ticks,
            time: this.time,
            velocity: this.velocity
          };
        };
        return Note2;
      })()
    );
    exports2.Note = Note;
  }
});

// node_modules/@tonejs/midi/dist/Track.js
var require_Track = __commonJS({
  "node_modules/@tonejs/midi/dist/Track.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Track = void 0;
    var BinarySearch_1 = require_BinarySearch();
    var ControlChange_1 = require_ControlChange();
    var ControlChanges_1 = require_ControlChanges();
    var PitchBend_1 = require_PitchBend();
    var Instrument_1 = require_Instrument();
    var Note_1 = require_Note();
    var privateHeaderMap = /* @__PURE__ */ new WeakMap();
    var Track = (
      /** @class */
      (function() {
        function Track2(trackData, header) {
          var _this = this;
          this.name = "";
          this.notes = [];
          this.controlChanges = (0, ControlChanges_1.createControlChanges)();
          this.pitchBends = [];
          privateHeaderMap.set(this, header);
          if (trackData) {
            var nameEvent = trackData.find(function(e) {
              return e.type === "trackName";
            });
            this.name = nameEvent ? nameEvent.text : "";
          }
          this.instrument = new Instrument_1.Instrument(trackData, this);
          this.channel = 0;
          if (trackData) {
            var noteOns = trackData.filter(function(event) {
              return event.type === "noteOn";
            });
            var noteOffs = trackData.filter(function(event) {
              return event.type === "noteOff";
            });
            var _loop_1 = function() {
              var currentNote = noteOns.shift();
              this_1.channel = currentNote.channel;
              var offIndex = noteOffs.findIndex(function(note) {
                return note.noteNumber === currentNote.noteNumber && note.absoluteTime >= currentNote.absoluteTime;
              });
              if (offIndex !== -1) {
                var noteOff = noteOffs.splice(offIndex, 1)[0];
                this_1.addNote({
                  durationTicks: noteOff.absoluteTime - currentNote.absoluteTime,
                  midi: currentNote.noteNumber,
                  noteOffVelocity: noteOff.velocity / 127,
                  ticks: currentNote.absoluteTime,
                  velocity: currentNote.velocity / 127
                });
              }
            };
            var this_1 = this;
            while (noteOns.length) {
              _loop_1();
            }
            var controlChanges = trackData.filter(function(event) {
              return event.type === "controller";
            });
            controlChanges.forEach(function(event) {
              _this.addCC({
                number: event.controllerType,
                ticks: event.absoluteTime,
                value: event.value / 127
              });
            });
            var pitchBends = trackData.filter(function(event) {
              return event.type === "pitchBend";
            });
            pitchBends.forEach(function(event) {
              _this.addPitchBend({
                ticks: event.absoluteTime,
                // Scale the value between -2^13 to 2^13 to -2 to 2.
                value: event.value / Math.pow(2, 13)
              });
            });
            var endOfTrackEvent = trackData.find(function(event) {
              return event.type === "endOfTrack";
            });
            this.endOfTrackTicks = endOfTrackEvent !== void 0 ? endOfTrackEvent.absoluteTime : void 0;
          }
        }
        Track2.prototype.addNote = function(props) {
          var header = privateHeaderMap.get(this);
          var note = new Note_1.Note({
            midi: 0,
            ticks: 0,
            velocity: 1
          }, {
            ticks: 0,
            velocity: 0
          }, header);
          Object.assign(note, props);
          (0, BinarySearch_1.insert)(this.notes, note, "ticks");
          return this;
        };
        Track2.prototype.addCC = function(props) {
          var header = privateHeaderMap.get(this);
          var cc = new ControlChange_1.ControlChange({
            controllerType: props.number
          }, header);
          delete props.number;
          Object.assign(cc, props);
          if (!Array.isArray(this.controlChanges[cc.number])) {
            this.controlChanges[cc.number] = [];
          }
          (0, BinarySearch_1.insert)(this.controlChanges[cc.number], cc, "ticks");
          return this;
        };
        Track2.prototype.addPitchBend = function(props) {
          var header = privateHeaderMap.get(this);
          var pb = new PitchBend_1.PitchBend({}, header);
          Object.assign(pb, props);
          (0, BinarySearch_1.insert)(this.pitchBends, pb, "ticks");
          return this;
        };
        Object.defineProperty(Track2.prototype, "duration", {
          /**
           * The end time of the last event in the track.
           */
          get: function() {
            if (!this.notes.length) {
              return 0;
            }
            var maxDuration = this.notes[this.notes.length - 1].time + this.notes[this.notes.length - 1].duration;
            for (var i = 0; i < this.notes.length - 1; i++) {
              var duration = this.notes[i].time + this.notes[i].duration;
              if (maxDuration < duration) {
                maxDuration = duration;
              }
            }
            return maxDuration;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Track2.prototype, "durationTicks", {
          /**
           * The end time of the last event in the track in ticks.
           */
          get: function() {
            if (!this.notes.length) {
              return 0;
            }
            var maxDuration = this.notes[this.notes.length - 1].ticks + this.notes[this.notes.length - 1].durationTicks;
            for (var i = 0; i < this.notes.length - 1; i++) {
              var duration = this.notes[i].ticks + this.notes[i].durationTicks;
              if (maxDuration < duration) {
                maxDuration = duration;
              }
            }
            return maxDuration;
          },
          enumerable: false,
          configurable: true
        });
        Track2.prototype.fromJSON = function(json) {
          var _this = this;
          this.name = json.name;
          this.channel = json.channel;
          this.instrument = new Instrument_1.Instrument(void 0, this);
          this.instrument.fromJSON(json.instrument);
          if (json.endOfTrackTicks !== void 0) {
            this.endOfTrackTicks = json.endOfTrackTicks;
          }
          for (var number in json.controlChanges) {
            if (json.controlChanges[number]) {
              json.controlChanges[number].forEach(function(cc) {
                _this.addCC({
                  number: cc.number,
                  ticks: cc.ticks,
                  value: cc.value
                });
              });
            }
          }
          json.notes.forEach(function(n) {
            _this.addNote({
              durationTicks: n.durationTicks,
              midi: n.midi,
              ticks: n.ticks,
              velocity: n.velocity
            });
          });
        };
        Track2.prototype.toJSON = function() {
          var controlChanges = {};
          for (var i = 0; i < 127; i++) {
            if (this.controlChanges.hasOwnProperty(i)) {
              controlChanges[i] = this.controlChanges[i].map(function(c) {
                return c.toJSON();
              });
            }
          }
          var json = {
            channel: this.channel,
            controlChanges,
            pitchBends: this.pitchBends.map(function(pb) {
              return pb.toJSON();
            }),
            instrument: this.instrument.toJSON(),
            name: this.name,
            notes: this.notes.map(function(n) {
              return n.toJSON();
            })
          };
          if (this.endOfTrackTicks !== void 0) {
            json.endOfTrackTicks = this.endOfTrackTicks;
          }
          return json;
        };
        return Track2;
      })()
    );
    exports2.Track = Track;
  }
});

// node_modules/array-flatten/dist.es2015/index.js
var dist_exports2 = {};
__export(dist_exports2, {
  flatten: () => flatten
});
function flatten(array) {
  var result = [];
  $flatten(array, result);
  return result;
}
function $flatten(array, result) {
  for (var i = 0; i < array.length; i++) {
    var value = array[i];
    if (Array.isArray(value)) {
      $flatten(value, result);
    } else {
      result.push(value);
    }
  }
}
var init_dist = __esm({
  "node_modules/array-flatten/dist.es2015/index.js"() {
  }
});

// node_modules/@tonejs/midi/dist/Encode.js
var require_Encode = __commonJS({
  "node_modules/@tonejs/midi/dist/Encode.js"(exports2) {
    "use strict";
    var __spreadArray = exports2 && exports2.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.encode = void 0;
    var midi_file_1 = require_midi_file();
    var Header_1 = require_Header();
    var array_flatten_1 = (init_dist(), __toCommonJS(dist_exports2));
    function encodeNote(note, channel) {
      return [
        {
          absoluteTime: note.ticks,
          channel,
          deltaTime: 0,
          noteNumber: note.midi,
          type: "noteOn",
          velocity: Math.floor(note.velocity * 127)
        },
        {
          absoluteTime: note.ticks + note.durationTicks,
          channel,
          deltaTime: 0,
          noteNumber: note.midi,
          type: "noteOff",
          velocity: Math.floor(note.noteOffVelocity * 127)
        }
      ];
    }
    function encodeNotes(track) {
      return (0, array_flatten_1.flatten)(track.notes.map(function(note) {
        return encodeNote(note, track.channel);
      }));
    }
    function encodeControlChange(cc, channel) {
      return {
        absoluteTime: cc.ticks,
        channel,
        controllerType: cc.number,
        deltaTime: 0,
        type: "controller",
        value: Math.floor(cc.value * 127)
      };
    }
    function encodeControlChanges(track) {
      var controlChanges = [];
      for (var i = 0; i < 127; i++) {
        if (track.controlChanges.hasOwnProperty(i)) {
          track.controlChanges[i].forEach(function(cc) {
            controlChanges.push(encodeControlChange(cc, track.channel));
          });
        }
      }
      return controlChanges;
    }
    function encodePitchBend(pb, channel) {
      return {
        absoluteTime: pb.ticks,
        channel,
        deltaTime: 0,
        type: "pitchBend",
        value: pb.value
      };
    }
    function encodePitchBends(track) {
      var pitchBends = [];
      track.pitchBends.forEach(function(pb) {
        pitchBends.push(encodePitchBend(pb, track.channel));
      });
      return pitchBends;
    }
    function encodeInstrument(track) {
      return {
        absoluteTime: 0,
        channel: track.channel,
        deltaTime: 0,
        programNumber: track.instrument.number,
        type: "programChange"
      };
    }
    function encodeTrackName(name) {
      return {
        absoluteTime: 0,
        deltaTime: 0,
        meta: true,
        text: name,
        type: "trackName"
      };
    }
    function encodeTempo(tempo) {
      return {
        absoluteTime: tempo.ticks,
        deltaTime: 0,
        meta: true,
        microsecondsPerBeat: Math.floor(6e7 / tempo.bpm),
        type: "setTempo"
      };
    }
    function encodeTimeSignature(timeSig) {
      return {
        absoluteTime: timeSig.ticks,
        deltaTime: 0,
        denominator: timeSig.timeSignature[1],
        meta: true,
        metronome: 24,
        numerator: timeSig.timeSignature[0],
        thirtyseconds: 8,
        type: "timeSignature"
      };
    }
    function encodeKeySignature(keySig) {
      var keyIndex = Header_1.keySignatureKeys.indexOf(keySig.key);
      return {
        absoluteTime: keySig.ticks,
        deltaTime: 0,
        key: keyIndex + 7,
        meta: true,
        scale: keySig.scale === "major" ? 0 : 1,
        type: "keySignature"
      };
    }
    function encodeText(textEvent) {
      return {
        absoluteTime: textEvent.ticks,
        deltaTime: 0,
        meta: true,
        text: textEvent.text,
        type: textEvent.type
      };
    }
    function encode(midi) {
      var midiData = {
        header: {
          format: 1,
          numTracks: midi.tracks.length + 1,
          ticksPerBeat: midi.header.ppq
        },
        tracks: __spreadArray([
          __spreadArray(__spreadArray(__spreadArray(__spreadArray([
            // The name data.
            {
              absoluteTime: 0,
              deltaTime: 0,
              meta: true,
              text: midi.header.name,
              type: "trackName"
            }
          ], midi.header.keySignatures.map(function(keySig) {
            return encodeKeySignature(keySig);
          }), true), midi.header.meta.map(function(e) {
            return encodeText(e);
          }), true), midi.header.tempos.map(function(tempo) {
            return encodeTempo(tempo);
          }), true), midi.header.timeSignatures.map(function(timeSig) {
            return encodeTimeSignature(timeSig);
          }), true)
        ], midi.tracks.map(function(track) {
          return __spreadArray(__spreadArray(__spreadArray([
            // Add the name
            encodeTrackName(track.name),
            // the instrument
            encodeInstrument(track)
          ], encodeNotes(track), true), encodeControlChanges(track), true), encodePitchBends(track), true);
        }), true)
      };
      midiData.tracks = midiData.tracks.map(function(track) {
        track = track.sort(function(a, b) {
          return a.absoluteTime - b.absoluteTime;
        });
        var lastTime = 0;
        track.forEach(function(note) {
          note.deltaTime = note.absoluteTime - lastTime;
          lastTime = note.absoluteTime;
          delete note.absoluteTime;
        });
        track.push({
          deltaTime: 0,
          meta: true,
          type: "endOfTrack"
        });
        return track;
      });
      return new Uint8Array((0, midi_file_1.writeMidi)(midiData));
    }
    exports2.encode = encode;
  }
});

// node_modules/@tonejs/midi/dist/Midi.js
var require_Midi = __commonJS({
  "node_modules/@tonejs/midi/dist/Midi.js"(exports2) {
    "use strict";
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports2 && exports2.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Header = exports2.Track = exports2.Midi = void 0;
    var midi_file_1 = require_midi_file();
    var Header_1 = require_Header();
    var Track_1 = require_Track();
    var Encode_1 = require_Encode();
    var Midi3 = (
      /** @class */
      (function() {
        function Midi4(midiArray) {
          var _this = this;
          var midiData = null;
          if (midiArray) {
            var midiArrayLike = midiArray instanceof ArrayBuffer ? new Uint8Array(midiArray) : midiArray;
            midiData = (0, midi_file_1.parseMidi)(midiArrayLike);
            midiData.tracks.forEach(function(track) {
              var currentTicks = 0;
              track.forEach(function(event) {
                currentTicks += event.deltaTime;
                event.absoluteTime = currentTicks;
              });
            });
            midiData.tracks = splitTracks(midiData.tracks);
          }
          this.header = new Header_1.Header(midiData);
          this.tracks = [];
          if (midiArray) {
            this.tracks = midiData.tracks.map(function(trackData) {
              return new Track_1.Track(trackData, _this.header);
            });
            if (midiData.header.format === 1 && this.tracks[0].duration === 0) {
              this.tracks.shift();
            }
          }
        }
        Midi4.fromUrl = function(url) {
          return __awaiter2(this, void 0, void 0, function() {
            var response, arrayBuffer;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, fetch(url)];
                case 1:
                  response = _a.sent();
                  if (!response.ok) return [3, 3];
                  return [4, response.arrayBuffer()];
                case 2:
                  arrayBuffer = _a.sent();
                  return [2, new Midi4(arrayBuffer)];
                case 3:
                  throw new Error("Could not load '".concat(url, "'"));
              }
            });
          });
        };
        Object.defineProperty(Midi4.prototype, "name", {
          /**
           * The name of the midi file, taken from the first track.
           */
          get: function() {
            return this.header.name;
          },
          set: function(n) {
            this.header.name = n;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Midi4.prototype, "duration", {
          /**
           * The total length of the file in seconds.
           */
          get: function() {
            var durations = this.tracks.map(function(t) {
              return t.duration;
            });
            return Math.max.apply(Math, durations);
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Midi4.prototype, "durationTicks", {
          /**
           * The total length of the file in ticks.
           */
          get: function() {
            var durationTicks = this.tracks.map(function(t) {
              return t.durationTicks;
            });
            return Math.max.apply(Math, durationTicks);
          },
          enumerable: false,
          configurable: true
        });
        Midi4.prototype.addTrack = function() {
          var track = new Track_1.Track(void 0, this.header);
          this.tracks.push(track);
          return track;
        };
        Midi4.prototype.toArray = function() {
          return (0, Encode_1.encode)(this);
        };
        Midi4.prototype.toJSON = function() {
          return {
            header: this.header.toJSON(),
            tracks: this.tracks.map(function(track) {
              return track.toJSON();
            })
          };
        };
        Midi4.prototype.fromJSON = function(json) {
          var _this = this;
          this.header = new Header_1.Header();
          this.header.fromJSON(json.header);
          this.tracks = json.tracks.map(function(trackJSON) {
            var track = new Track_1.Track(void 0, _this.header);
            track.fromJSON(trackJSON);
            return track;
          });
        };
        Midi4.prototype.clone = function() {
          var midi = new Midi4();
          midi.fromJSON(this.toJSON());
          return midi;
        };
        return Midi4;
      })()
    );
    exports2.Midi = Midi3;
    var Track_2 = require_Track();
    Object.defineProperty(exports2, "Track", { enumerable: true, get: function() {
      return Track_2.Track;
    } });
    var Header_2 = require_Header();
    Object.defineProperty(exports2, "Header", { enumerable: true, get: function() {
      return Header_2.Header;
    } });
    function splitTracks(tracks) {
      var newTracks = [];
      for (var i = 0; i < tracks.length; i++) {
        var defaultTrack = newTracks.length;
        var trackMap = /* @__PURE__ */ new Map();
        var currentProgram = Array(16).fill(0);
        for (var _i = 0, _a = tracks[i]; _i < _a.length; _i++) {
          var event_1 = _a[_i];
          var targetTrack = defaultTrack;
          var channel = event_1.channel;
          if (channel !== void 0) {
            if (event_1.type === "programChange") {
              currentProgram[channel] = event_1.programNumber;
            }
            var program = currentProgram[channel];
            var trackKey = "".concat(program, " ").concat(channel);
            if (trackMap.has(trackKey)) {
              targetTrack = trackMap.get(trackKey);
            } else {
              targetTrack = defaultTrack + trackMap.size;
              trackMap.set(trackKey, targetTrack);
            }
          }
          if (!newTracks[targetTrack]) {
            newTracks.push([]);
          }
          newTracks[targetTrack].push(event_1);
        }
      }
      return newTracks;
    }
  }
});

// node_modules/staffrender/es6/index.js
var require_es6 = __commonJS({
  "node_modules/staffrender/es6/index.js"(exports2, module2) {
    !(function(t, e) {
      "object" == typeof exports2 && "object" == typeof module2 ? module2.exports = e() : "function" == typeof define && define.amd ? define([], e) : "object" == typeof exports2 ? exports2.index = e() : t.index = e();
    })(self, (function() {
      return (function(t) {
        var e = {};
        function i(s) {
          if (e[s]) return e[s].exports;
          var n = e[s] = { i: s, l: false, exports: {} };
          return t[s].call(n.exports, n, n.exports, i), n.l = true, n.exports;
        }
        return i.m = t, i.c = e, i.d = function(t2, e2, s) {
          i.o(t2, e2) || Object.defineProperty(t2, e2, { enumerable: true, get: s });
        }, i.r = function(t2) {
          "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
        }, i.t = function(t2, e2) {
          if (1 & e2 && (t2 = i(t2)), 8 & e2) return t2;
          if (4 & e2 && "object" == typeof t2 && t2 && t2.__esModule) return t2;
          var s = /* @__PURE__ */ Object.create(null);
          if (i.r(s), Object.defineProperty(s, "default", { enumerable: true, value: t2 }), 2 & e2 && "string" != typeof t2) for (var n in t2) i.d(s, n, (function(e3) {
            return t2[e3];
          }).bind(null, n));
          return s;
        }, i.n = function(t2) {
          var e2 = t2 && t2.__esModule ? function() {
            return t2.default;
          } : function() {
            return t2;
          };
          return i.d(e2, "a", e2), e2;
        }, i.o = function(t2, e2) {
          return Object.prototype.hasOwnProperty.call(t2, e2);
        }, i.p = "", i(i.s = 4);
      })([function(t, e, i) {
        "use strict";
        i.r(e), i.d(e, "SVGNS", (function() {
          return s;
        })), i.d(e, "drawSVGPath", (function() {
          return n;
        })), i.d(e, "drawSVGText", (function() {
          return r;
        })), i.d(e, "createSVGGroupChild", (function() {
          return a;
        })), i.d(e, "setFade", (function() {
          return h;
        }));
        const s = "http://www.w3.org/2000/svg";
        function n(t2, e2, i2, n2, r2, a2, h2 = 1) {
          const l = document.createElementNS(s, "path");
          return l.setAttributeNS(null, "d", e2), l.setAttributeNS(null, "transform", `translate(${i2}, ${n2}) scale(${r2}, ${a2})`), l.setAttributeNS(null, "opacity", `${h2}`), t2.appendChild(l), l;
        }
        function r(t2, e2, i2, n2, r2, a2 = false, h2 = 1, l = 1) {
          const c = document.createElementNS(s, "text");
          c.setAttributeNS(null, "font-family", "Times"), c.setAttributeNS(null, "font-size", r2), a2 && c.setAttributeNS(null, "font-weight", "bold"), c.setAttributeNS(null, "transform", `translate(${i2}, ${n2}) scale(${h2}, ${l})`);
          const o = document.createTextNode(e2);
          return c.appendChild(o), t2.appendChild(c), c;
        }
        function a(t2, e2) {
          const i2 = document.createElementNS(s, "g");
          return i2.setAttribute("data-id", e2), t2.appendChild(i2), i2;
        }
        function h(t2, e2 = false, i2 = 1, n2 = 0) {
          let r2 = t2.querySelector("animate");
          if (!r2) {
            (r2 = document.createElementNS(s, "animate")).setAttributeNS(null, "attributeName", "opacity"), r2.setAttributeNS(null, "dur", "4s"), r2.setAttributeNS(null, "fill", "freeze"), r2.setAttributeNS(null, "keyTimes", "0; 0.25; 0.5; 0.75; 1");
            const t3 = (i2 + 3 * n2) / 4;
            r2.setAttributeNS(null, "values", `${i2}; ${t3}; ${n2}; ${t3}; ${i2}`);
          }
          return e2 ? r2.setAttributeNS(null, "repeatCount", "indefinite") : r2.setAttributeNS(null, "repeatCount", "1"), t2.appendChild(r2), t2;
        }
      }, function(t, e, i) {
        "use strict";
        i.r(e), i.d(e, "PATH_SCALE", (function() {
          return s;
        })), i.d(e, "staffLinePath", (function() {
          return r;
        })), i.d(e, "extraLinePath", (function() {
          return a;
        })), i.d(e, "barPath", (function() {
          return h;
        })), i.d(e, "stemPath", (function() {
          return l;
        })), i.d(e, "singleFlagPath", (function() {
          return c;
        })), i.d(e, "multiFlagPath", (function() {
          return o;
        })), i.d(e, "tiePath", (function() {
          return u;
        })), i.d(e, "dotPath", (function() {
          return d;
        })), i.d(e, "NOTE_PATHS", (function() {
          return f;
        })), i.d(e, "REST_PATHS", (function() {
          return g;
        })), i.d(e, "CLEF_PATHS", (function() {
          return S;
        })), i.d(e, "ACCIDENTAL_PATHS", (function() {
          return p;
        }));
        const s = 100, n = "M 0,10 C 0,-15 35,-50 80,-50 110,-50 125,-35 125,-10 \n125,15 90,50 45,50 15,50 0,35 0,10 Z", r = "m 0,0 h 100", a = "m -25,0 h 175", h = "m 0,-200 v 400", l = "m 0,0 v 100 h 15 v -100 z", c = "M0,0 h 12 c 7,100 175,156 62,314 79,-177 -49,\n-193 -61,-200 l -13,-5 z", o = "m 0,0 h 10 c 6,72 173,64 84,227 44,-120 -44,\n-123 -94,-167 z", u = "M 0,25 C 10,46 30,67 50,67 69,67 90,47 100,25 94,\n65 73,89 50,89 26,89 5,63 0,25 Z", d = "M 5 -20 a 20 20 0 1 0 0.00001 0 z", f = { 4: { path: "m 0,0 c 0,-37 49,-51 79,-51 31,0 83,13 83,51 0,39 \n-55,51 -84,51 C 49,51 0,37 0,0 Z m 111,31 c 13,-19 0,-58 -22,-68 -33,-15 \n-53,10 -39,49 9,27 48,39 61,19 z", width: 150, stemVSteps: 0, stemAnchor: 0, flags: 0 }, 2: { path: "m 0,10 c 0,-25 35,-60 80,-60 15,0 45,4 45,40 C 125,16 \n89,50 45,50 17,50 0,36 0,10 Z m 71,7 c 17,-11 45,-34 38,-45 -7,-10 -39,1 \n-57,12 -19,11 -42,31 -36,42 6,10 37,2 55,-9 z", width: 125, stemVSteps: 7, stemAnchor: -10, flags: 0 }, 1: { path: n, width: 125, stemVSteps: 7, stemAnchor: -10, flags: 0 }, 0.5: { path: n, width: 125, stemVSteps: 7, stemAnchor: -10, flags: 1 }, 0.25: { path: n, width: 125, stemVSteps: 9, stemAnchor: -10, flags: 2 }, 0.125: { path: n, width: 125, stemVSteps: 11, stemAnchor: -10, flags: 3 }, 0.0625: { path: n, width: 125, stemVSteps: 13, stemAnchor: -10, flags: 4 } }, g = { 4: "m 0,-50 h 125 v -50 H 0 Z", 2: "M 0,0 H 125 V -50 H 0 Z", 1: "m 0,-25 c 39,-39 37,-75 8,-120 l 6,-5 61,103 C \n40,-13 31,4 73,71 l -5,5 C 14,52 16,125 67,144 l -4,6 C -37,102 -1,22 59,60 Z", 0.5: "m 52,-47 c 26,-2 42,-21 48,-42 l 12,4 L 64,83 52,79 \n88,-49 c 0,0 -17,22 -57,22 -16,0 -31,-13 -31,-27 0,-18 10,-31 27,-31 17,0 \n33,15 25,38 z", 0.25: "m 129,-191 c -6,21 -22,40 -48,42 8,-23 -8,-38 \n-25,-38 -17,0 -27,13 -27,31 0,14 15,27 31,27 40,0 57,-22 57,-22 l -20,69 \nc -7,18 -22,33 -45,35 8,-23 -8,-38 -25,-38 -17,0 -27,13 -27,31 0,14 15,27 \n31,27 40,0 57,-22 57,-22 l -36,128 12,4 77,-270 z", 0.125: "m 129,-191 c -6,21 -22,40 -48,42 8,-23 -8,-38 \n-25,-38 -17,0 -27,13 -27,31 0,14 15,27 31,27 40,0 57,-22 57,-22 l -20,69 \nc -7,18 -22,33 -45,35 8,-23 -8,-38 -25,-38 -17,0 -27,13 -27,31 0,14 15,27 \n31,27 40,0 57,-22 57,-22 L 68,20 C 61,37 46,51 24,52 32,29 16,14 -1,14 c \n-17,0 -27,13 -27,31 0,14 15,27 31,27 38,0 55,-20 57,-22 l -36,128 12,4 \n105,-369 z", 0.0625: "m 158,-292 c -6,21 -22,40 -48,42 8,-23 -8,-38 \n-25,-38 -17,0 -27,13 -27,31 0,14 15,27 31,27 40,0 57,-22 57,-22 l -17,61 \nv 0 c -6,21 -22,40 -48,42 8,-23 -8,-38 -25,-38 -17,0 -27,13 -27,31 0,14 \n15,27 31,27 40,0 57,-22 57,-22 l -20,69 c -7,18 -22,33 -45,35 8,-23 -8,-38 \n-25,-38 -17,0 -27,13 -27,31 0,14 15,27 31,27 40,0 57,-22 57,-22 L 68,20 C \n61,37 46,51 24,52 32,29 16,14 -1,14 c -17,0 -27,13 -27,31 0,14 15,27 31,27 \n38,0 55,-20 57,-22 l -36,128 12,4 134,-469 z" }, S = { 50: { path: "m 101,-199 c -49,0 -100,28 -100,83 0,39 58,57 82,26 15,-20 \n-4,-47 -32,-47 -23,1 -25,0 -25,-8 0,-22 40,-46 71,-41 91,16 67,208 -105,302 \n75,-27 198,-94 211,-201 6,-66 -42,-114 -102,-114 z m 143,33 c -13,0 -23,11 \n-23,24 0,14 10,24 23,24 13,0 23,-11 23,-24 0,-13 -10,-24 -23,-24 z m 2,83 c \n-13,0 -23,11 -23,24 0,14 10,24 23,24 13,0 23,-11 23,-24 0,-13 -10,-24 -23,-24 \nz", upper: -4, lower: 3 }, 71: { path: "M 139,48 C 102,57 76,120 131,151 41,128 64,24 129,2 L \n117,-57 C -32,47 26,217 166,182 Z m 12,-1 27,131 C 242,153 216,46 151,47 \nZ m -35,-177 c 34,-23 82,-117 50,-140 -23,-17 -71,33 -50,140 z m -10,10 c \n-23,-77 -20,-200 48,-213 19,-4 89,171 -26,266 l 13,66 c 120,-6 137,155 \n39,191 l 12,58 c 30,131 -137,145 -138,47 0,-29 37,-59 63,-37 21,18 25,71 \n-25,70 32,42 103,0 91,-65 L 167,193 C 56,232 -112,63 106,-120 Z", upper: -7, lower: 8 } }, p = [null, "m -49,-121 v 52 l -29,9 v -48 h -8 v 51 l -20,6 v 29 l \n20,-6 v 70 l -20,6 v 30 l 20,-6 v 51 h 8 V 69 l 30,-8 v 50 h 8 V 58 l 20,-6 \nV 23 l -20,6 v -71 l 20,-6 v -29 l -20,6 v -50 z m 1,82 v 71 l -29,9 v -71 z", "M -106,-166 V 67 c 52,-42 85,-56 85,-94 0,-47 -46,-51 \n-73,-22 v -117 z m 31,120 c 20,0 42,46 -20,91 V -7 c 0,-28 10,-39 20,-39 z", "m -81,-58 v -48 H -92 V 73 l 60,-13 v 50 h 11 V -72 Z m \n50,24 v 58 l -50,11 v -58 z"];
      }, function(t, e, i) {
        "use strict";
        i.r(e), i.d(e, "MIN_RESOLUTION", (function() {
          return s;
        })), i.d(e, "STEM_WIDTH", (function() {
          return n;
        })), i.d(e, "LINE_STROKE", (function() {
          return r;
        })), i.d(e, "COMPACT_SPACING", (function() {
          return a;
        }));
        const s = 0.0625, n = 15, r = 1, a = 150;
      }, function(t, e, i) {
        "use strict";
        i.r(e), i.d(e, "MAX_QUARTER_DIVISION", (function() {
          return l;
        })), i.d(e, "ScrollType", (function() {
          return c;
        })), i.d(e, "StaffSVGRender", (function() {
          return o;
        }));
        var s = i(2), n = i(0), r = i(1);
        const a = [{ steps: [0, 0, -1, -1, -2, -3, -3, -4, -4, -5, -5, -6], accidental: [0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0] }, { steps: [0, -1, -1, -2, -2, -3, -4, -4, -5, -5, -6, -6], accidental: [0, 0, 3, 0, 3, 0, 0, 3, 0, 3, 0, 3] }, { steps: [0, 0, -1, -1, -2, -3, -3, -4, -4, -5, -5, -6], accidental: [3, 0, 0, 1, 0, 3, 0, 0, 1, 0, 1, 0] }, { steps: [0, -1, -1, -2, -2, -3, -4, -4, -5, -5, -6, -6], accidental: [0, 2, 0, 0, 3, 0, 2, 0, 0, 3, 0, 3] }, { steps: [0, 0, -1, -1, -2, -3, -3, -4, -4, -5, -5, -6], accidental: [3, 0, 3, 0, 0, 3, 0, 3, 0, 0, 1, 0] }, { steps: [0, -1, -1, -2, -2, -3, -4, -4, -5, -5, -6, -6], accidental: [0, 2, 0, 2, 0, 0, 2, 0, 2, 0, 0, 3] }, { steps: [0, -1, -1, -2, -2, -3, -4, -4, -5, -5, -6, -7], accidental: [3, 0, 3, 0, 3, 0, 0, 3, 0, 3, 0, 0] }, { steps: [0, 0, -1, -1, -2, -3, -3, -4, -4, -5, -5, -6], accidental: [0, 1, 0, 1, 0, 3, 0, 0, 1, 0, 1, 0] }, { steps: [0, -1, -1, -2, -2, -3, -4, -4, -5, -5, -6, -6], accidental: [0, 0, 3, 0, 3, 0, 2, 0, 0, 3, 0, 3] }, { steps: [0, 0, -1, -1, -2, -3, -3, -4, -4, -5, -5, -6], accidental: [3, 0, 0, 1, 0, 3, 0, 3, 0, 0, 1, 0] }, { steps: [0, -1, -1, -2, -2, -3, -4, -4, -5, -5, -6, -6], accidental: [0, 2, 0, 0, 3, 0, 2, 0, 2, 0, 0, 3] }, { steps: [0, 0, -1, -1, -2, -3, -3, -4, -4, -5, -5, -6], accidental: [3, 0, 3, 0, 0, 3, 0, 3, 0, 3, 0, 0] }], h = [{ accidental: 1, pitches: [] }, { accidental: 2, pitches: [70, 75, 68, 73, 66] }, { accidental: 1, pitches: [78, 73] }, { accidental: 2, pitches: [70, 75, 68] }, { accidental: 1, pitches: [78, 73, 80, 75] }, { accidental: 2, pitches: [70] }, { accidental: 2, pitches: [70, 75, 68, 73, 66, 71] }, { accidental: 1, pitches: [78] }, { accidental: 2, pitches: [70, 75, 68, 73] }, { accidental: 1, pitches: [78, 73, 80] }, { accidental: 2, pitches: [70, 75] }, { accidental: 1, pitches: [78, 73, 80, 75, 70] }], l = 16;
        var c;
        !(function(t2) {
          t2[t2.PAGE = 0] = "PAGE", t2[t2.NOTE = 1] = "NOTE", t2[t2.BAR = 2] = "BAR";
        })(c || (c = {}));
        class o {
          constructor(t2, e2, i2) {
            this.handleScrollEvent = (t3) => {
              this.lastKnownScrollLeft = this.parentElement.scrollLeft, this.ticking || window.requestAnimationFrame(() => {
                this.changeAndDrawSignaturesIfNeeded(this.lastKnownScrollLeft), this.ticking = false;
              }), this.ticking = true;
            }, this.scoreInfo = t2;
            this.config = { noteHeight: e2.noteHeight || 6, noteSpacing: e2.noteSpacing || 1, pixelsPerTimeStep: e2.pixelsPerTimeStep || 30, noteRGB: e2.noteRGB || "8, 41, 64", activeNoteRGB: e2.activeNoteRGB || "240, 84, 119" }, this.div = i2, this.timeSignatureNumerator = 4, this.timeSignatureDenominator = 4, this.key = e2.defaultKey || 0, this.scrollType = e2.scrollType || c.PAGE, this.scale = this.config.noteHeight / r.PATH_SCALE, (void 0 === e2.pixelsPerTimeStep || e2.pixelsPerTimeStep <= 0) && (this.config.pixelsPerTimeStep = 0, this.config.noteSpacing = s.COMPACT_SPACING * this.scale), this.clear(), this.redraw();
          }
          clear() {
            for (; this.div.lastChild; ) this.div.removeChild(this.div.lastChild);
            this.div.style.overflow = "visible", this.div.style.position = "relative", this.overlaySVG = document.createElementNS(n.SVGNS, "svg"), this.overlaySVG.style.position = "absolute", this.div.appendChild(this.overlaySVG), this.overlayG = Object(n.createSVGGroupChild)(this.overlaySVG, "overlay"), this.signaturesBlinking = false, this.signaturesQuarters = 0, this.parentElement = document.createElement("div"), this.parentElement.style.overflow = "auto", this.div.appendChild(this.parentElement), this.ticking = false, this.lastKnownScrollLeft = 0, this.parentElement.addEventListener("scroll", this.handleScrollEvent), this.staffSVG = document.createElementNS(n.SVGNS, "svg"), this.parentElement.appendChild(this.staffSVG), this.staffG = Object(n.createSVGGroupChild)(this.staffSVG, "staff"), this.linesG = Object(n.createSVGGroupChild)(this.staffSVG, "lines"), this.setStroke(this.linesG), this.staffG.appendChild(this.linesG), this.musicG = Object(n.createSVGGroupChild)(this.staffSVG, "music"), this.setFill(this.musicG), this.setStroke(this.musicG, 0), this.staffG.appendChild(this.musicG), this.signaturesG = Object(n.createSVGGroupChild)(this.staffSVG, "signatures"), this.staffG.appendChild(this.signaturesG);
            let t2 = 0, e2 = 0;
            this.scoreInfo.notes.forEach((i3) => {
              t2 += i3.pitch, ++e2;
            });
            const i2 = t2 / e2;
            this.clef = i2 < 60 ? 50 : 71, this.signaturesList = [{ x: 0, q: 0 }], this.signatureCurrent = 0, this.signatureNext = 0, this.changeKeySignatureIfNeeded(0), this.changeTimeSignatureIfNeeded(0), this.vStepSize = this.config.noteHeight / 2, this.hStepSize = this.config.pixelsPerTimeStep, this.staffOffset = 0, this.height = 0, this.width = 0, this.musicBlockMap = /* @__PURE__ */ new Map(), this.playingNotes = [], this.lastBar = 0, this.barAccidentals = {}, this.lastQ = -1;
          }
          isPaintingActiveNote(t2, e2) {
            const i2 = t2.start === e2.start, s2 = t2.start <= e2.start && t2.start + t2.length >= e2.start + e2.length;
            return i2 || s2;
          }
          redraw(t2, e2) {
            let i2 = -1;
            const s2 = 0 === this.config.pixelsPerTimeStep;
            if (t2) {
              const r2 = [];
              this.playingNotes.forEach((e3) => {
                this.isPaintingActiveNote(e3, t2) ? r2.push(e3) : this.highlightElement(this.getGroup(e3), false);
              }), this.playingNotes = r2;
              const a2 = this.getGroup(t2);
              if (a2) {
                this.playingNotes.push(t2), this.highlightElement(a2, true), i2 = a2.getBoundingClientRect().left - this.staffSVG.getBoundingClientRect().left;
                const r3 = t2.start, h2 = a2.getAttribute("data-is-bar-beginning");
                (this.scrollType !== c.BAR || h2) && this.scrollIntoViewIfNeeded(e2, i2), !s2 && this.signaturesBlinking && r3 >= this.signaturesQuarters && (this.signaturesBlinking = false, Object(n.setFade)(this.overlayG, this.signaturesBlinking));
              }
            } else {
              this.setDetails();
              const t3 = -1 === this.lastQ;
              let e3 = 0, i3 = 0;
              t3 ? (i3 = this.drawSignatures(this.overlayG, e3, true, true, true), s2 && (this.width = 0, i3 += this.config.noteSpacing), i3 += this.drawRests(this.initialRest, e3 + i3)) : e3 = this.width, this.musicBlockMap.forEach((t4, n3) => {
                s2 || (e3 = this.quartersToTime(n3) * this.hStepSize), n3 > this.lastQ ? (i3 += this.drawMusicBlock(t4, e3 + i3), this.lastQ = n3) : n3 === this.lastQ && (i3 += this.drawRests(t4, e3 + i3));
              });
              const n2 = this.staffSVG.getBoundingClientRect(), r2 = this.musicG.getBoundingClientRect();
              if (this.updateVerticalBoundaries(r2.top - n2.top, r2.bottom - n2.top), s2) this.width += i3;
              else {
                const t4 = this.musicBlockMap.get(this.lastQ), e4 = this.quartersToTime(this.lastQ + t4.notes[0].length);
                this.width = e4 * this.config.pixelsPerTimeStep;
              }
              this.staffSVG.setAttributeNS(null, "width", `${this.width}`), this.redrawStaff(this.linesG, 0, this.width);
            }
            return i2;
          }
          drawMusicBlock(t2, e2) {
            const i2 = t2.notes[0].start;
            let a2 = this.drawBarIfNeeded(i2, e2);
            a2 += this.drawSignaturesIfNeeded(i2, e2 + a2);
            let h2 = 0;
            for (let e3 = 4; e3 >= s.MIN_RESOLUTION && !h2; e3 /= 2) e3 <= t2.notes[0].length && (h2 = e3);
            if (0 === h2) {
              const e3 = 0 === t2.notes[0].length ? "[infinite]" : `${4 / t2.notes[0].length}`;
              console.warn(" StaffRender ", "background:orange; color:white", `StaffRender does not handle notes shorther than 1/${4 / s.MIN_RESOLUTION}th, and this score tries to draw a 1/${e3}th. Shortest possible note will be drawn instead.`), h2 = s.MIN_RESOLUTION;
            }
            const l2 = r.NOTE_PATHS[h2];
            let c2;
            if (l2.stemAnchor && (c2 = Object(n.createSVGGroupChild)(this.musicG, "stem")), t2.notes.forEach((i3) => {
              const s2 = i3.vSteps * this.vStepSize, c3 = 2 * (i3.vSteps > 0 ? Math.floor(i3.vSteps / 2) : Math.ceil(i3.vSteps / 2)), o2 = i3.vSteps > 0 ? -2 : 2;
              for (let t3 = c3; Math.abs(t3) > 4; t3 += o2) Object(n.drawSVGPath)(this.linesG, r.extraLinePath, e2 + a2, t3 * this.vStepSize, this.scale, 1);
              if (i3.g = i3.tiedFrom ? i3.tiedFrom.g : Object(n.createSVGGroupChild)(this.musicG, `${i3.start}-${i3.pitch}`), t2.isBarBeginning && i3.g.setAttribute("data-is-bar-beginning", "true"), i3.tiedFrom) {
                const t3 = e2 + a2 - i3.tiedFrom.xHeadRight;
                Object(n.drawSVGPath)(i3.g, r.tiePath, i3.tiedFrom.xHeadRight, s2, t3 / r.PATH_SCALE, this.scale * (i3.vSteps < 0 ? -1 : 1), i3.opacity);
              }
              Object(n.drawSVGPath)(i3.g, l2.path, e2 + a2, s2, this.scale, this.scale, i3.opacity), i3.xHeadRight = e2 + a2 + l2.width * this.scale, 1.5 * h2 <= i3.length && Object(n.drawSVGPath)(i3.g, r.dotPath, e2 + a2 + l2.width * this.scale + this.vStepSize / 2, s2 - this.vStepSize / 2, this.scale, this.scale, i3.opacity), 0 !== i3.accidental && Object(n.drawSVGPath)(i3.g, r.ACCIDENTAL_PATHS[i3.accidental], e2 + a2, s2, this.scale, this.scale, i3.opacity);
            }), l2.stemAnchor) {
              let i3, h3, o2 = e2 + a2;
              const u = l2.stemAnchor * this.scale, d = t2.minVStep + t2.maxVStep < 0, f = l2.flags > 2 ? 2 * (l2.flags - 2) : 0;
              if (d ? (i3 = t2.maxVStep * this.vStepSize - u, h3 = (t2.minVStep + 7 + f) * this.vStepSize) : (o2 += (l2.width - s.STEM_WIDTH) * this.scale, i3 = t2.minVStep * this.vStepSize + u, h3 = (t2.maxVStep - 7 - f) * this.vStepSize), Object(n.drawSVGPath)(c2, r.stemPath, o2, i3, this.scale, (h3 - i3) / r.PATH_SCALE), 1 === l2.flags) Object(n.drawSVGPath)(c2, r.singleFlagPath, o2, h3, this.scale, this.scale * (d ? -1 : 1), 1);
              else if (l2.flags > 1) for (let t3 = 0; t3 < l2.flags; ++t3) Object(n.drawSVGPath)(c2, r.multiFlagPath, o2, h3, this.scale, this.scale * (d ? -1 : 1), 1), h3 += (d ? -2 : 2) * this.vStepSize;
            }
            return 0 === this.config.pixelsPerTimeStep && (a2 += l2.width * this.scale, c2 && (a2 += c2.getBoundingClientRect().width), a2 += this.config.noteSpacing), a2 += this.drawRests(t2, e2 + a2);
          }
          drawBarIfNeeded(t2, e2) {
            let i2 = 0;
            const s2 = this.lastBar + this.getBarLength();
            return 0 !== t2 && t2 >= s2 && (this.config.pixelsPerTimeStep > 0 ? e2 -= this.config.noteSpacing : i2 = this.config.noteSpacing, Object(n.drawSVGPath)(this.linesG, r.barPath, e2, 0, 1, this.scale), this.lastBar = s2), i2;
          }
          drawRests(t2, e2) {
            let i2 = 0, a2 = t2.restToNextLength;
            if (a2) {
              this.config.pixelsPerTimeStep > 0 && (e2 += this.quartersToTime(t2.notes[0].length) * this.hStepSize);
              let h2 = t2.notes[0].start + t2.notes[0].length, l2 = 0;
              const c2 = this.lastBar + this.getBarLength() - h2;
              let o2;
              for (a2 > c2 && (l2 = a2 - c2, a2 = c2), o2 = 4; o2 > this.getBarLength() && o2 >= s.MIN_RESOLUTION; o2 /= 2) ;
              let u = o2;
              for (; (a2 || l2) && u >= s.MIN_RESOLUTION; ) {
                if (u <= a2) {
                  i2 += this.drawBarIfNeeded(h2, e2 + i2), i2 += this.drawSignaturesIfNeeded(h2, e2 + i2);
                  const t3 = Object(n.drawSVGPath)(this.musicG, r.REST_PATHS[u], e2 + i2, 0, this.scale, this.scale);
                  this.config.pixelsPerTimeStep > 0 ? e2 += this.quartersToTime(u) * this.hStepSize : (i2 += t3.getBoundingClientRect().width, i2 += this.config.noteSpacing), h2 += u, a2 -= u;
                }
                if (l2 && a2 <= 0) {
                  const t3 = this.getBarLength();
                  for (l2 > t3 ? (a2 = t3, l2 -= t3) : (a2 = l2, l2 = 0), o2 = 4; o2 > this.getBarLength() && o2 >= s.MIN_RESOLUTION; o2 /= 2) ;
                  u = o2;
                }
                a2 < u && (u /= 2);
              }
            }
            return i2;
          }
          redrawStaff(t2, e2, i2) {
            let s2 = t2.querySelector('g[data-id="staff-five-lines"]');
            if (s2) s2.setAttributeNS(null, "transform", `scale(${i2 / r.PATH_SCALE}, 1)`);
            else {
              s2 = Object(n.createSVGGroupChild)(t2, "staff-five-lines");
              const a2 = 0;
              for (let t3 = -4; t3 <= 4; t3 += 2) Object(n.drawSVGPath)(s2, r.staffLinePath, e2, a2 + t3 * this.vStepSize, i2 / r.PATH_SCALE, 1);
            }
            return s2;
          }
          clearSignatureOverlay() {
            for (; this.overlayG.lastChild; ) this.overlayG.removeChild(this.overlayG.lastChild);
          }
          drawSignaturesIfNeeded(t2, e2) {
            let i2 = 0;
            const r2 = this.changeKeySignatureIfNeeded(t2), a2 = this.changeTimeSignatureIfNeeded(t2);
            if (r2 || a2) {
              const h2 = s.COMPACT_SPACING * this.scale * (this.config.pixelsPerTimeStep > 0 ? 3 : 2);
              this.signaturesList.push({ x: e2 - h2, q: t2 }), null === this.signatureNext && (this.signatureNext = e2);
              const l2 = t2 > 0 ? Object(n.createSVGGroupChild)(this.signaturesG, "signatures") : this.overlayG;
              i2 += this.drawSignatures(l2, e2 + i2, false, r2, a2);
            }
            return 0 === this.config.pixelsPerTimeStep ? i2 : 0;
          }
          drawSignatures(t2, e2, i2, a2, l2) {
            const c2 = s.COMPACT_SPACING * this.scale;
            let o2, u = c2;
            const d = t2 === this.overlayG || this.config.pixelsPerTimeStep > 0;
            if (d) {
              (o2 = document.createElementNS(n.SVGNS, "rect")).setAttributeNS(null, "x", `${e2}`), o2.setAttributeNS(null, "y", "0"), o2.setAttributeNS(null, "width", "1"), o2.setAttributeNS(null, "height", "1"), o2.setAttribute("data-id", "background"), t2.appendChild(o2);
              const i3 = document.defaultView.getComputedStyle(this.div.parentElement);
              o2.setAttributeNS(null, "fill", i3.getPropertyValue("background-color"));
            }
            if (i2) {
              const i3 = Object(n.drawSVGPath)(t2, r.CLEF_PATHS[this.clef].path, e2 + u, 0, this.scale, this.scale);
              this.setFill(i3), u += 3 * c2;
            }
            if (a2) {
              const i3 = h[this.key].accidental, s2 = 71 === this.clef ? 0 : 14;
              h[this.key].pitches.forEach((a3) => {
                const h2 = this.getPitchDetails(a3).vSteps, l3 = Object(n.drawSVGPath)(t2, r.ACCIDENTAL_PATHS[i3], e2 + u, (s2 + h2) * this.vStepSize, this.scale, this.scale);
                this.setFill(l3), u += l3.getBoundingClientRect().width;
              });
            }
            if (l2) {
              const i3 = Object(n.createSVGGroupChild)(t2, "time-key"), s2 = `${2.85 * this.config.noteHeight}px`;
              Object(n.drawSVGText)(i3, `${this.timeSignatureNumerator}`, e2 + u, -0.5, s2, true), Object(n.drawSVGText)(i3, `${this.timeSignatureDenominator}`, e2 + u, 4 * this.vStepSize - 0.5, s2, true), this.setFill(i3), u += i3.getBoundingClientRect().width + c2;
            }
            const f = this.redrawStaff(t2, e2, u);
            this.setStroke(f);
            const g = this.div.getBoundingClientRect(), S = t2.getBoundingClientRect();
            if (this.updateVerticalBoundaries(S.top - g.top, S.bottom - g.top), d && (o2.setAttributeNS(null, "y", `${-this.staffOffset}`), o2.setAttributeNS(null, "height", `${this.height}`), o2.setAttributeNS(null, "width", `${u}`)), t2 === this.overlayG) {
              this.overlaySVG.setAttributeNS(null, "width", `${u + 5}`);
              for (let e3 = 0; e3 < 5; ++e3) {
                const i3 = Object(n.drawSVGPath)(t2, r.stemPath, u + e3, e3 * e3 - this.staffOffset, 1 / s.STEM_WIDTH, (this.height - 2 * e3 * e3) / r.PATH_SCALE, (e3 - 5) * (e3 - 5) * 2 / r.PATH_SCALE);
                this.setFill(i3);
              }
            }
            if (this.config.pixelsPerTimeStep > 0) {
              const i3 = 0 === this.signaturesQuarters;
              return i3 && (this.signaturesQuarters = this.timeToQuarters(u / this.hStepSize)), (i3 || e2 > 0) && (this.signaturesBlinking = true, Object(n.setFade)(t2, this.signaturesBlinking)), 0;
            }
            return u;
          }
          changeKeySignatureIfNeeded(t2) {
            if (this.scoreInfo.keySignatures) {
              let e2 = this.key;
              for (let i2 = 0; i2 < this.scoreInfo.keySignatures.length && this.scoreInfo.keySignatures[i2].start <= t2; ++i2) e2 = this.scoreInfo.keySignatures[i2].key;
              if (e2 !== this.key) return this.key = e2, true;
            }
            return false;
          }
          changeTimeSignatureIfNeeded(t2) {
            if (this.scoreInfo.timeSignatures) {
              let e2 = this.timeSignatureNumerator, i2 = this.timeSignatureDenominator;
              for (let s2 = 0; s2 < this.scoreInfo.timeSignatures.length && this.scoreInfo.timeSignatures[s2].start <= t2; ++s2) e2 = this.scoreInfo.timeSignatures[s2].numerator, i2 = this.scoreInfo.timeSignatures[s2].denominator;
              if (e2 !== this.timeSignatureNumerator || i2 !== this.timeSignatureDenominator) return this.timeSignatureNumerator = e2, this.timeSignatureDenominator = i2, true;
            }
            return false;
          }
          changeAndDrawSignaturesIfNeeded(t2) {
            let e2;
            if (t2 < this.signatureCurrent || null !== this.signatureNext && this.signatureNext <= t2) {
              e2 = this.signaturesList[0].q, this.signatureNext = null;
              for (let i2 = 0; i2 < this.signaturesList.length; ++i2) {
                if (t2 < this.signaturesList[i2].x) {
                  this.signatureNext = this.signaturesList[i2].x;
                  break;
                }
                this.signatureCurrent = this.signaturesList[i2].x, e2 = this.signaturesList[i2].q;
              }
            }
            if (void 0 !== e2) {
              const t3 = this.key, i2 = this.timeSignatureNumerator, s2 = this.timeSignatureDenominator;
              this.changeKeySignatureIfNeeded(e2), this.changeTimeSignatureIfNeeded(e2), this.clearSignatureOverlay(), this.drawSignatures(this.overlayG, 0, true, true, true), this.key = t3, this.timeSignatureNumerator = i2, this.timeSignatureDenominator = s2;
            }
            this.config.pixelsPerTimeStep > 0 && 0 === t2 && (this.signatureNext = 0, this.signaturesBlinking = true, Object(n.setFade)(this.overlayG, this.signaturesBlinking));
          }
          getBarLength() {
            return 4 * this.timeSignatureNumerator / this.timeSignatureDenominator;
          }
          scrollIntoViewIfNeeded(t2, e2) {
            if (t2) if (this.scrollType === c.PAGE) {
              const t3 = this.parentElement.getBoundingClientRect().width;
              e2 > this.parentElement.scrollLeft + t3 && (this.parentElement.scrollLeft = e2 - 20);
            } else {
              const t3 = this.parentElement.getBoundingClientRect().width;
              this.parentElement.scrollLeft = e2 - 0.5 * t3;
            }
          }
          updateVerticalBoundaries(t2, e2) {
            let i2 = 0;
            if (t2 < 0) {
              this.staffOffset -= t2;
              const e3 = `translate(0, ${this.staffOffset})`;
              this.overlayG.setAttributeNS(null, "transform", e3), this.staffG.setAttributeNS(null, "transform", e3), i2 = this.height - t2;
            }
            if ((i2 = Math.max(i2, e2 - t2)) > this.height) {
              this.height = i2, this.overlaySVG.setAttributeNS(null, "height", `${this.height}`), this.staffSVG.setAttributeNS(null, "height", `${this.height}`);
              const t3 = this.div.querySelectorAll('rect[data-id="background"]');
              for (let e3 = 0; e3 < t3.length; ++e3) {
                const i3 = t3[e3];
                i3.setAttributeNS(null, "y", `${-this.staffOffset}`), i3.setAttributeNS(null, "height", `${this.height}`);
              }
            }
          }
          setFill(t2, e2 = false) {
            t2.setAttributeNS(null, "fill", this.getColor(e2));
          }
          setStroke(t2, e2 = s.LINE_STROKE, i2 = false) {
            t2.setAttributeNS(null, "stroke", this.getColor(i2)), t2.setAttributeNS(null, "stroke-width", `${e2}`);
          }
          getColor(t2) {
            return `rgb(${t2 ? this.config.activeNoteRGB : this.config.noteRGB})`;
          }
          getOpacity(t2) {
            return t2 ? t2 / 127 * 0.8 + 0.2 : 1;
          }
          getGroup(t2) {
            const e2 = t2.start, i2 = t2.pitch;
            return this.staffSVG.querySelector(`g[data-id="${e2}-${i2}"]`);
          }
          highlightElement(t2, e2) {
            t2.setAttribute("fill", this.getColor(e2)), t2.setAttribute("stroke", this.getColor(e2));
          }
          getBarBeginnings() {
            const t2 = /* @__PURE__ */ new Set();
            let e2 = 0;
            this.scoreInfo.notes.forEach((t3) => {
              t3.start + t3.length > e2 && (e2 = t3.start + t3.length);
            });
            const i2 = this.scoreInfo.timeSignatures ? this.scoreInfo.timeSignatures.slice(0) : [{ start: 0, numerator: 4, denominator: 4 }];
            i2.sort((t3, e3) => t3.start - e3.start);
            let s2 = 0;
            for (let n2 = 0; n2 < i2.length; ++n2) {
              const r2 = n2 === i2.length - 1 ? e2 : i2[n2].start, a2 = 4 * i2[n2].numerator / i2[n2].denominator;
              for (; s2 < r2; s2 += a2) t2.add(s2);
            }
            return t2;
          }
          quartersToTime(t2) {
            return t2 / this.scoreInfo.tempos[0].qpm * 60;
          }
          timeToQuarters(t2) {
            return t2 * this.scoreInfo.tempos[0].qpm / 60;
          }
          setDetails() {
            let t2 = /* @__PURE__ */ new Map();
            const e2 = this.getBarBeginnings(), i2 = new Set(e2);
            this.scoreInfo.notes.slice().sort((t3, e3) => t3.start - e3.start).forEach((e3) => {
              const s3 = this.getQNote(e3);
              i2.add(s3.start), i2.add(s3.start + s3.length), t2.has(s3.start) ? t2.get(s3.start).push(s3) : t2.set(s3.start, [s3]);
            }), Array.from(i2).sort((t3, e3) => t3 - e3).forEach((e3) => {
              const i3 = [];
              t2.forEach((t3) => {
                t3.forEach((t4) => {
                  const s3 = this.splitQNote(t4, e3);
                  s3 && i3.push(s3);
                });
              }), i3.forEach((e4) => {
                t2.has(e4.start) ? t2.get(e4.start).push(e4) : t2.set(e4.start, [e4]);
              });
            }), t2 = new Map(Array.from(t2).sort((t3, e3) => t3[0] - e3[0]));
            const s2 = this.key;
            let n2 = null, r2 = 0;
            const a2 = e2[Symbol.iterator]();
            let h2 = a2.next();
            t2.forEach((t3, e3) => {
              const i3 = { maxVStep: Number.MAX_SAFE_INTEGER, minVStep: Number.MIN_SAFE_INTEGER, restToNextLength: 0, isBarBeginning: false, notes: [] };
              this.changeKeySignatureIfNeeded(e3);
              const s3 = h2.value + this.getBarLength();
              !h2.done && e3 >= s3 && (h2 = a2.next(), this.barAccidentals = {}, i3.isBarBeginning = true), t3.forEach((t4) => {
                this.analyzePitch(t4, e3), i3.minVStep = Math.max(t4.vSteps, i3.minVStep), i3.maxVStep = Math.min(t4.vSteps, i3.maxVStep), i3.notes.push(t4);
              }), n2 && (n2.restToNextLength = e3 - r2), this.musicBlockMap.set(e3, i3), n2 = i3, r2 = e3 + i3.notes[0].length;
            }), this.initialRest = { maxVStep: 0, minVStep: 0, restToNextLength: this.musicBlockMap.values().next().value.notes[0].start, isBarBeginning: true, notes: [{ start: 0, length: 0, vSteps: 0, accidental: 0, opacity: 0, pitch: 0, xHeadRight: 0 }] }, this.key = s2;
          }
          getQNote(t2) {
            return { start: t2.start, length: t2.length, vSteps: 0, accidental: 0, opacity: this.getOpacity(t2.intensity), pitch: t2.pitch, xHeadRight: 0 };
          }
          splitQNote(t2, e2) {
            const i2 = t2.start + t2.length - e2;
            return e2 > t2.start && i2 > 0 ? (t2.length -= i2, { start: e2, length: i2, vSteps: t2.vSteps, accidental: t2.accidental, opacity: t2.opacity, pitch: t2.pitch, xHeadRight: 0, tiedFrom: t2 }) : null;
          }
          analyzePitch(t2, e2) {
            const i2 = this.getPitchDetails(t2.pitch);
            i2.vSteps in this.barAccidentals ? i2.accidental === this.barAccidentals[i2.vSteps] ? i2.accidental = 0 : (3 === this.barAccidentals[i2.vSteps] ? i2.accidental = i2.keyAccidental : 0 === i2.accidental && (i2.accidental = 3), this.barAccidentals[i2.vSteps] = i2.accidental) : (t2.tiedFrom && (i2.accidental = 0), this.barAccidentals[i2.vSteps] = i2.accidental), t2.vSteps = i2.vSteps, t2.accidental = i2.accidental;
          }
          getPitchDetails(t2) {
            const e2 = t2 - 60, i2 = Math.floor(e2 / 12), s2 = e2 - 12 * i2, n2 = a[this.key].steps[s2], r2 = 71 === this.clef ? 6 : -6, l2 = 1 === h[this.key].accidental ? 69 + (s2 + 3) % 12 : 64 + (s2 + 8) % 12;
            return { vSteps: r2 - 7 * i2 + n2, accidental: a[this.key].accidental[s2], keyAccidental: h[this.key].pitches.indexOf(l2) > -1 ? h[this.key].accidental : 0 };
          }
        }
      }, function(t, e, i) {
        "use strict";
        i.r(e);
        var s = i(3);
        i.d(e, "MAX_QUARTER_DIVISION", (function() {
          return s.MAX_QUARTER_DIVISION;
        })), i.d(e, "ScrollType", (function() {
          return s.ScrollType;
        })), i.d(e, "StaffSVGRender", (function() {
          return s.StaffSVGRender;
        }));
      }]);
    }));
  }
});

// node_modules/fft.js/lib/fft.js
var require_fft = __commonJS({
  "node_modules/fft.js/lib/fft.js"(exports2, module2) {
    "use strict";
    function FFT4(size) {
      this.size = size | 0;
      if (this.size <= 1 || (this.size & this.size - 1) !== 0)
        throw new Error("FFT size must be a power of two and bigger than 1");
      this._csize = size << 1;
      var table = new Array(this.size * 2);
      for (var i = 0; i < table.length; i += 2) {
        const angle = Math.PI * i / this.size;
        table[i] = Math.cos(angle);
        table[i + 1] = -Math.sin(angle);
      }
      this.table = table;
      var power = 0;
      for (var t = 1; this.size > t; t <<= 1)
        power++;
      this._width = power % 2 === 0 ? power - 1 : power;
      this._bitrev = new Array(1 << this._width);
      for (var j = 0; j < this._bitrev.length; j++) {
        this._bitrev[j] = 0;
        for (var shift = 0; shift < this._width; shift += 2) {
          var revShift = this._width - shift - 2;
          this._bitrev[j] |= (j >>> shift & 3) << revShift;
        }
      }
      this._out = null;
      this._data = null;
      this._inv = 0;
    }
    module2.exports = FFT4;
    FFT4.prototype.fromComplexArray = function fromComplexArray(complex, storage) {
      var res = storage || new Array(complex.length >>> 1);
      for (var i = 0; i < complex.length; i += 2)
        res[i >>> 1] = complex[i];
      return res;
    };
    FFT4.prototype.createComplexArray = function createComplexArray() {
      const res = new Array(this._csize);
      for (var i = 0; i < res.length; i++)
        res[i] = 0;
      return res;
    };
    FFT4.prototype.toComplexArray = function toComplexArray(input2, storage) {
      var res = storage || this.createComplexArray();
      for (var i = 0; i < res.length; i += 2) {
        res[i] = input2[i >>> 1];
        res[i + 1] = 0;
      }
      return res;
    };
    FFT4.prototype.completeSpectrum = function completeSpectrum(spectrum) {
      var size = this._csize;
      var half = size >>> 1;
      for (var i = 2; i < half; i += 2) {
        spectrum[size - i] = spectrum[i];
        spectrum[size - i + 1] = -spectrum[i + 1];
      }
    };
    FFT4.prototype.transform = function transform(out, data) {
      if (out === data)
        throw new Error("Input and output buffers must be different");
      this._out = out;
      this._data = data;
      this._inv = 0;
      this._transform4();
      this._out = null;
      this._data = null;
    };
    FFT4.prototype.realTransform = function realTransform(out, data) {
      if (out === data)
        throw new Error("Input and output buffers must be different");
      this._out = out;
      this._data = data;
      this._inv = 0;
      this._realTransform4();
      this._out = null;
      this._data = null;
    };
    FFT4.prototype.inverseTransform = function inverseTransform(out, data) {
      if (out === data)
        throw new Error("Input and output buffers must be different");
      this._out = out;
      this._data = data;
      this._inv = 1;
      this._transform4();
      for (var i = 0; i < out.length; i++)
        out[i] /= this.size;
      this._out = null;
      this._data = null;
    };
    FFT4.prototype._transform4 = function _transform4() {
      var out = this._out;
      var size = this._csize;
      var width = this._width;
      var step = 1 << width;
      var len = size / step << 1;
      var outOff;
      var t;
      var bitrev = this._bitrev;
      if (len === 4) {
        for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {
          const off = bitrev[t];
          this._singleTransform2(outOff, off, step);
        }
      } else {
        for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {
          const off = bitrev[t];
          this._singleTransform4(outOff, off, step);
        }
      }
      var inv = this._inv ? -1 : 1;
      var table = this.table;
      for (step >>= 2; step >= 2; step >>= 2) {
        len = size / step << 1;
        var quarterLen = len >>> 2;
        for (outOff = 0; outOff < size; outOff += len) {
          var limit = outOff + quarterLen;
          for (var i = outOff, k = 0; i < limit; i += 2, k += step) {
            const A = i;
            const B = A + quarterLen;
            const C = B + quarterLen;
            const D = C + quarterLen;
            const Ar = out[A];
            const Ai = out[A + 1];
            const Br = out[B];
            const Bi = out[B + 1];
            const Cr = out[C];
            const Ci = out[C + 1];
            const Dr = out[D];
            const Di = out[D + 1];
            const MAr = Ar;
            const MAi = Ai;
            const tableBr = table[k];
            const tableBi = inv * table[k + 1];
            const MBr = Br * tableBr - Bi * tableBi;
            const MBi = Br * tableBi + Bi * tableBr;
            const tableCr = table[2 * k];
            const tableCi = inv * table[2 * k + 1];
            const MCr = Cr * tableCr - Ci * tableCi;
            const MCi = Cr * tableCi + Ci * tableCr;
            const tableDr = table[3 * k];
            const tableDi = inv * table[3 * k + 1];
            const MDr = Dr * tableDr - Di * tableDi;
            const MDi = Dr * tableDi + Di * tableDr;
            const T0r = MAr + MCr;
            const T0i = MAi + MCi;
            const T1r = MAr - MCr;
            const T1i = MAi - MCi;
            const T2r = MBr + MDr;
            const T2i = MBi + MDi;
            const T3r = inv * (MBr - MDr);
            const T3i = inv * (MBi - MDi);
            const FAr = T0r + T2r;
            const FAi = T0i + T2i;
            const FCr = T0r - T2r;
            const FCi = T0i - T2i;
            const FBr = T1r + T3i;
            const FBi = T1i - T3r;
            const FDr = T1r - T3i;
            const FDi = T1i + T3r;
            out[A] = FAr;
            out[A + 1] = FAi;
            out[B] = FBr;
            out[B + 1] = FBi;
            out[C] = FCr;
            out[C + 1] = FCi;
            out[D] = FDr;
            out[D + 1] = FDi;
          }
        }
      }
    };
    FFT4.prototype._singleTransform2 = function _singleTransform2(outOff, off, step) {
      const out = this._out;
      const data = this._data;
      const evenR = data[off];
      const evenI = data[off + 1];
      const oddR = data[off + step];
      const oddI = data[off + step + 1];
      const leftR = evenR + oddR;
      const leftI = evenI + oddI;
      const rightR = evenR - oddR;
      const rightI = evenI - oddI;
      out[outOff] = leftR;
      out[outOff + 1] = leftI;
      out[outOff + 2] = rightR;
      out[outOff + 3] = rightI;
    };
    FFT4.prototype._singleTransform4 = function _singleTransform4(outOff, off, step) {
      const out = this._out;
      const data = this._data;
      const inv = this._inv ? -1 : 1;
      const step2 = step * 2;
      const step3 = step * 3;
      const Ar = data[off];
      const Ai = data[off + 1];
      const Br = data[off + step];
      const Bi = data[off + step + 1];
      const Cr = data[off + step2];
      const Ci = data[off + step2 + 1];
      const Dr = data[off + step3];
      const Di = data[off + step3 + 1];
      const T0r = Ar + Cr;
      const T0i = Ai + Ci;
      const T1r = Ar - Cr;
      const T1i = Ai - Ci;
      const T2r = Br + Dr;
      const T2i = Bi + Di;
      const T3r = inv * (Br - Dr);
      const T3i = inv * (Bi - Di);
      const FAr = T0r + T2r;
      const FAi = T0i + T2i;
      const FBr = T1r + T3i;
      const FBi = T1i - T3r;
      const FCr = T0r - T2r;
      const FCi = T0i - T2i;
      const FDr = T1r - T3i;
      const FDi = T1i + T3r;
      out[outOff] = FAr;
      out[outOff + 1] = FAi;
      out[outOff + 2] = FBr;
      out[outOff + 3] = FBi;
      out[outOff + 4] = FCr;
      out[outOff + 5] = FCi;
      out[outOff + 6] = FDr;
      out[outOff + 7] = FDi;
    };
    FFT4.prototype._realTransform4 = function _realTransform4() {
      var out = this._out;
      var size = this._csize;
      var width = this._width;
      var step = 1 << width;
      var len = size / step << 1;
      var outOff;
      var t;
      var bitrev = this._bitrev;
      if (len === 4) {
        for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {
          const off = bitrev[t];
          this._singleRealTransform2(outOff, off >>> 1, step >>> 1);
        }
      } else {
        for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {
          const off = bitrev[t];
          this._singleRealTransform4(outOff, off >>> 1, step >>> 1);
        }
      }
      var inv = this._inv ? -1 : 1;
      var table = this.table;
      for (step >>= 2; step >= 2; step >>= 2) {
        len = size / step << 1;
        var halfLen = len >>> 1;
        var quarterLen = halfLen >>> 1;
        var hquarterLen = quarterLen >>> 1;
        for (outOff = 0; outOff < size; outOff += len) {
          for (var i = 0, k = 0; i <= hquarterLen; i += 2, k += step) {
            var A = outOff + i;
            var B = A + quarterLen;
            var C = B + quarterLen;
            var D = C + quarterLen;
            var Ar = out[A];
            var Ai = out[A + 1];
            var Br = out[B];
            var Bi = out[B + 1];
            var Cr = out[C];
            var Ci = out[C + 1];
            var Dr = out[D];
            var Di = out[D + 1];
            var MAr = Ar;
            var MAi = Ai;
            var tableBr = table[k];
            var tableBi = inv * table[k + 1];
            var MBr = Br * tableBr - Bi * tableBi;
            var MBi = Br * tableBi + Bi * tableBr;
            var tableCr = table[2 * k];
            var tableCi = inv * table[2 * k + 1];
            var MCr = Cr * tableCr - Ci * tableCi;
            var MCi = Cr * tableCi + Ci * tableCr;
            var tableDr = table[3 * k];
            var tableDi = inv * table[3 * k + 1];
            var MDr = Dr * tableDr - Di * tableDi;
            var MDi = Dr * tableDi + Di * tableDr;
            var T0r = MAr + MCr;
            var T0i = MAi + MCi;
            var T1r = MAr - MCr;
            var T1i = MAi - MCi;
            var T2r = MBr + MDr;
            var T2i = MBi + MDi;
            var T3r = inv * (MBr - MDr);
            var T3i = inv * (MBi - MDi);
            var FAr = T0r + T2r;
            var FAi = T0i + T2i;
            var FBr = T1r + T3i;
            var FBi = T1i - T3r;
            out[A] = FAr;
            out[A + 1] = FAi;
            out[B] = FBr;
            out[B + 1] = FBi;
            if (i === 0) {
              var FCr = T0r - T2r;
              var FCi = T0i - T2i;
              out[C] = FCr;
              out[C + 1] = FCi;
              continue;
            }
            if (i === hquarterLen)
              continue;
            var ST0r = T1r;
            var ST0i = -T1i;
            var ST1r = T0r;
            var ST1i = -T0i;
            var ST2r = -inv * T3i;
            var ST2i = -inv * T3r;
            var ST3r = -inv * T2i;
            var ST3i = -inv * T2r;
            var SFAr = ST0r + ST2r;
            var SFAi = ST0i + ST2i;
            var SFBr = ST1r + ST3i;
            var SFBi = ST1i - ST3r;
            var SA = outOff + quarterLen - i;
            var SB = outOff + halfLen - i;
            out[SA] = SFAr;
            out[SA + 1] = SFAi;
            out[SB] = SFBr;
            out[SB + 1] = SFBi;
          }
        }
      }
    };
    FFT4.prototype._singleRealTransform2 = function _singleRealTransform2(outOff, off, step) {
      const out = this._out;
      const data = this._data;
      const evenR = data[off];
      const oddR = data[off + step];
      const leftR = evenR + oddR;
      const rightR = evenR - oddR;
      out[outOff] = leftR;
      out[outOff + 1] = 0;
      out[outOff + 2] = rightR;
      out[outOff + 3] = 0;
    };
    FFT4.prototype._singleRealTransform4 = function _singleRealTransform4(outOff, off, step) {
      const out = this._out;
      const data = this._data;
      const inv = this._inv ? -1 : 1;
      const step2 = step * 2;
      const step3 = step * 3;
      const Ar = data[off];
      const Br = data[off + step];
      const Cr = data[off + step2];
      const Dr = data[off + step3];
      const T0r = Ar + Cr;
      const T1r = Ar - Cr;
      const T2r = Br + Dr;
      const T3r = inv * (Br - Dr);
      const FAr = T0r + T2r;
      const FBr = T1r;
      const FBi = -T3r;
      const FCr = T0r - T2r;
      const FDr = T1r;
      const FDi = T3r;
      out[outOff] = FAr;
      out[outOff + 1] = 0;
      out[outOff + 2] = FBr;
      out[outOff + 3] = FBi;
      out[outOff + 4] = FCr;
      out[outOff + 5] = 0;
      out[outOff + 6] = FDr;
      out[outOff + 7] = FDi;
    };
  }
});

// node_modules/iota-array/iota.js
var require_iota = __commonJS({
  "node_modules/iota-array/iota.js"(exports2, module2) {
    "use strict";
    function iota(n) {
      var result = new Array(n);
      for (var i = 0; i < n; ++i) {
        result[i] = i;
      }
      return result;
    }
    module2.exports = iota;
  }
});

// node_modules/is-buffer/index.js
var require_is_buffer = __commonJS({
  "node_modules/is-buffer/index.js"(exports2, module2) {
    module2.exports = function(obj) {
      return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
    };
    function isBuffer(obj) {
      return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
    }
    function isSlowBuffer(obj) {
      return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isBuffer(obj.slice(0, 0));
    }
  }
});

// node_modules/ndarray/ndarray.js
var require_ndarray = __commonJS({
  "node_modules/ndarray/ndarray.js"(exports2, module2) {
    var iota = require_iota();
    var isBuffer = require_is_buffer();
    var hasTypedArrays = typeof Float64Array !== "undefined";
    function compare1st(a, b) {
      return a[0] - b[0];
    }
    function order() {
      var stride = this.stride;
      var terms = new Array(stride.length);
      var i;
      for (i = 0; i < terms.length; ++i) {
        terms[i] = [Math.abs(stride[i]), i];
      }
      terms.sort(compare1st);
      var result = new Array(terms.length);
      for (i = 0; i < result.length; ++i) {
        result[i] = terms[i][1];
      }
      return result;
    }
    function compileConstructor(dtype, dimension) {
      var className = ["View", dimension, "d", dtype].join("");
      if (dimension < 0) {
        className = "View_Nil" + dtype;
      }
      var useGetters = dtype === "generic";
      if (dimension === -1) {
        var code = "function " + className + "(a){this.data=a;};var proto=" + className + ".prototype;proto.dtype='" + dtype + "';proto.index=function(){return -1};proto.size=0;proto.dimension=-1;proto.shape=proto.stride=proto.order=[];proto.lo=proto.hi=proto.transpose=proto.step=function(){return new " + className + "(this.data);};proto.get=proto.set=function(){};proto.pick=function(){return null};return function construct_" + className + "(a){return new " + className + "(a);}";
        var procedure = new Function(code);
        return procedure();
      } else if (dimension === 0) {
        var code = "function " + className + "(a,d) {this.data = a;this.offset = d};var proto=" + className + ".prototype;proto.dtype='" + dtype + "';proto.index=function(){return this.offset};proto.dimension=0;proto.size=1;proto.shape=proto.stride=proto.order=[];proto.lo=proto.hi=proto.transpose=proto.step=function " + className + "_copy() {return new " + className + "(this.data,this.offset)};proto.pick=function " + className + "_pick(){return TrivialArray(this.data);};proto.valueOf=proto.get=function " + className + "_get(){return " + (useGetters ? "this.data.get(this.offset)" : "this.data[this.offset]") + "};proto.set=function " + className + "_set(v){return " + (useGetters ? "this.data.set(this.offset,v)" : "this.data[this.offset]=v") + "};return function construct_" + className + "(a,b,c,d){return new " + className + "(a,d)}";
        var procedure = new Function("TrivialArray", code);
        return procedure(CACHED_CONSTRUCTORS[dtype][0]);
      }
      var code = ["'use strict'"];
      var indices = iota(dimension);
      var args = indices.map(function(i2) {
        return "i" + i2;
      });
      var index_str = "this.offset+" + indices.map(function(i2) {
        return "this.stride[" + i2 + "]*i" + i2;
      }).join("+");
      var shapeArg = indices.map(function(i2) {
        return "b" + i2;
      }).join(",");
      var strideArg = indices.map(function(i2) {
        return "c" + i2;
      }).join(",");
      code.push(
        "function " + className + "(a," + shapeArg + "," + strideArg + ",d){this.data=a",
        "this.shape=[" + shapeArg + "]",
        "this.stride=[" + strideArg + "]",
        "this.offset=d|0}",
        "var proto=" + className + ".prototype",
        "proto.dtype='" + dtype + "'",
        "proto.dimension=" + dimension
      );
      code.push(
        "Object.defineProperty(proto,'size',{get:function " + className + "_size(){return " + indices.map(function(i2) {
          return "this.shape[" + i2 + "]";
        }).join("*"),
        "}})"
      );
      if (dimension === 1) {
        code.push("proto.order=[0]");
      } else {
        code.push("Object.defineProperty(proto,'order',{get:");
        if (dimension < 4) {
          code.push("function " + className + "_order(){");
          if (dimension === 2) {
            code.push("return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})");
          } else if (dimension === 3) {
            code.push(
              "var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);if(s0>s1){if(s1>s2){return [2,1,0];}else if(s0>s2){return [1,2,0];}else{return [1,0,2];}}else if(s0>s2){return [2,0,1];}else if(s2>s1){return [0,1,2];}else{return [0,2,1];}}})"
            );
          }
        } else {
          code.push("ORDER})");
        }
      }
      code.push(
        "proto.set=function " + className + "_set(" + args.join(",") + ",v){"
      );
      if (useGetters) {
        code.push("return this.data.set(" + index_str + ",v)}");
      } else {
        code.push("return this.data[" + index_str + "]=v}");
      }
      code.push("proto.get=function " + className + "_get(" + args.join(",") + "){");
      if (useGetters) {
        code.push("return this.data.get(" + index_str + ")}");
      } else {
        code.push("return this.data[" + index_str + "]}");
      }
      code.push(
        "proto.index=function " + className + "_index(",
        args.join(),
        "){return " + index_str + "}"
      );
      code.push("proto.hi=function " + className + "_hi(" + args.join(",") + "){return new " + className + "(this.data," + indices.map(function(i2) {
        return ["(typeof i", i2, "!=='number'||i", i2, "<0)?this.shape[", i2, "]:i", i2, "|0"].join("");
      }).join(",") + "," + indices.map(function(i2) {
        return "this.stride[" + i2 + "]";
      }).join(",") + ",this.offset)}");
      var a_vars = indices.map(function(i2) {
        return "a" + i2 + "=this.shape[" + i2 + "]";
      });
      var c_vars = indices.map(function(i2) {
        return "c" + i2 + "=this.stride[" + i2 + "]";
      });
      code.push("proto.lo=function " + className + "_lo(" + args.join(",") + "){var b=this.offset,d=0," + a_vars.join(",") + "," + c_vars.join(","));
      for (var i = 0; i < dimension; ++i) {
        code.push(
          "if(typeof i" + i + "==='number'&&i" + i + ">=0){d=i" + i + "|0;b+=c" + i + "*d;a" + i + "-=d}"
        );
      }
      code.push("return new " + className + "(this.data," + indices.map(function(i2) {
        return "a" + i2;
      }).join(",") + "," + indices.map(function(i2) {
        return "c" + i2;
      }).join(",") + ",b)}");
      code.push("proto.step=function " + className + "_step(" + args.join(",") + "){var " + indices.map(function(i2) {
        return "a" + i2 + "=this.shape[" + i2 + "]";
      }).join(",") + "," + indices.map(function(i2) {
        return "b" + i2 + "=this.stride[" + i2 + "]";
      }).join(",") + ",c=this.offset,d=0,ceil=Math.ceil");
      for (var i = 0; i < dimension; ++i) {
        code.push(
          "if(typeof i" + i + "==='number'){d=i" + i + "|0;if(d<0){c+=b" + i + "*(a" + i + "-1);a" + i + "=ceil(-a" + i + "/d)}else{a" + i + "=ceil(a" + i + "/d)}b" + i + "*=d}"
        );
      }
      code.push("return new " + className + "(this.data," + indices.map(function(i2) {
        return "a" + i2;
      }).join(",") + "," + indices.map(function(i2) {
        return "b" + i2;
      }).join(",") + ",c)}");
      var tShape = new Array(dimension);
      var tStride = new Array(dimension);
      for (var i = 0; i < dimension; ++i) {
        tShape[i] = "a[i" + i + "]";
        tStride[i] = "b[i" + i + "]";
      }
      code.push(
        "proto.transpose=function " + className + "_transpose(" + args + "){" + args.map(function(n, idx) {
          return n + "=(" + n + "===undefined?" + idx + ":" + n + "|0)";
        }).join(";"),
        "var a=this.shape,b=this.stride;return new " + className + "(this.data," + tShape.join(",") + "," + tStride.join(",") + ",this.offset)}"
      );
      code.push("proto.pick=function " + className + "_pick(" + args + "){var a=[],b=[],c=this.offset");
      for (var i = 0; i < dimension; ++i) {
        code.push("if(typeof i" + i + "==='number'&&i" + i + ">=0){c=(c+this.stride[" + i + "]*i" + i + ")|0}else{a.push(this.shape[" + i + "]);b.push(this.stride[" + i + "])}");
      }
      code.push("var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}");
      code.push("return function construct_" + className + "(data,shape,stride,offset){return new " + className + "(data," + indices.map(function(i2) {
        return "shape[" + i2 + "]";
      }).join(",") + "," + indices.map(function(i2) {
        return "stride[" + i2 + "]";
      }).join(",") + ",offset)}");
      var procedure = new Function("CTOR_LIST", "ORDER", code.join("\n"));
      return procedure(CACHED_CONSTRUCTORS[dtype], order);
    }
    function arrayDType(data) {
      if (isBuffer(data)) {
        return "buffer";
      }
      if (hasTypedArrays) {
        switch (Object.prototype.toString.call(data)) {
          case "[object Float64Array]":
            return "float64";
          case "[object Float32Array]":
            return "float32";
          case "[object Int8Array]":
            return "int8";
          case "[object Int16Array]":
            return "int16";
          case "[object Int32Array]":
            return "int32";
          case "[object Uint8Array]":
            return "uint8";
          case "[object Uint16Array]":
            return "uint16";
          case "[object Uint32Array]":
            return "uint32";
          case "[object Uint8ClampedArray]":
            return "uint8_clamped";
          case "[object BigInt64Array]":
            return "bigint64";
          case "[object BigUint64Array]":
            return "biguint64";
        }
      }
      if (Array.isArray(data)) {
        return "array";
      }
      return "generic";
    }
    var CACHED_CONSTRUCTORS = {
      "float32": [],
      "float64": [],
      "int8": [],
      "int16": [],
      "int32": [],
      "uint8": [],
      "uint16": [],
      "uint32": [],
      "array": [],
      "uint8_clamped": [],
      "bigint64": [],
      "biguint64": [],
      "buffer": [],
      "generic": []
    };
    function wrappedNDArrayCtor(data, shape, stride, offset) {
      if (data === void 0) {
        var ctor = CACHED_CONSTRUCTORS.array[0];
        return ctor([]);
      } else if (typeof data === "number") {
        data = [data];
      }
      if (shape === void 0) {
        shape = [data.length];
      }
      var d = shape.length;
      if (stride === void 0) {
        stride = new Array(d);
        for (var i = d - 1, sz = 1; i >= 0; --i) {
          stride[i] = sz;
          sz *= shape[i];
        }
      }
      if (offset === void 0) {
        offset = 0;
        for (var i = 0; i < d; ++i) {
          if (stride[i] < 0) {
            offset -= (shape[i] - 1) * stride[i];
          }
        }
      }
      var dtype = arrayDType(data);
      var ctor_list = CACHED_CONSTRUCTORS[dtype];
      while (ctor_list.length <= d + 1) {
        ctor_list.push(compileConstructor(dtype, ctor_list.length - 1));
      }
      var ctor = ctor_list[d + 1];
      return ctor(data, shape, stride, offset);
    }
    module2.exports = wrappedNDArrayCtor;
  }
});

// node_modules/uniq/uniq.js
var require_uniq = __commonJS({
  "node_modules/uniq/uniq.js"(exports2, module2) {
    "use strict";
    function unique_pred(list, compare) {
      var ptr = 1, len = list.length, a = list[0], b = list[0];
      for (var i = 1; i < len; ++i) {
        b = a;
        a = list[i];
        if (compare(a, b)) {
          if (i === ptr) {
            ptr++;
            continue;
          }
          list[ptr++] = a;
        }
      }
      list.length = ptr;
      return list;
    }
    function unique_eq(list) {
      var ptr = 1, len = list.length, a = list[0], b = list[0];
      for (var i = 1; i < len; ++i, b = a) {
        b = a;
        a = list[i];
        if (a !== b) {
          if (i === ptr) {
            ptr++;
            continue;
          }
          list[ptr++] = a;
        }
      }
      list.length = ptr;
      return list;
    }
    function unique(list, compare, sorted) {
      if (list.length === 0) {
        return list;
      }
      if (compare) {
        if (!sorted) {
          list.sort(compare);
        }
        return unique_pred(list, compare);
      }
      if (!sorted) {
        list.sort();
      }
      return unique_eq(list);
    }
    module2.exports = unique;
  }
});

// node_modules/cwise-compiler/lib/compile.js
var require_compile = __commonJS({
  "node_modules/cwise-compiler/lib/compile.js"(exports2, module2) {
    "use strict";
    var uniq = require_uniq();
    function innerFill(order, proc, body) {
      var dimension = order.length, nargs = proc.arrayArgs.length, has_index = proc.indexArgs.length > 0, code = [], vars = [], idx = 0, pidx = 0, i, j;
      for (i = 0; i < dimension; ++i) {
        vars.push(["i", i, "=0"].join(""));
      }
      for (j = 0; j < nargs; ++j) {
        for (i = 0; i < dimension; ++i) {
          pidx = idx;
          idx = order[i];
          if (i === 0) {
            vars.push(["d", j, "s", i, "=t", j, "p", idx].join(""));
          } else {
            vars.push(["d", j, "s", i, "=(t", j, "p", idx, "-s", pidx, "*t", j, "p", pidx, ")"].join(""));
          }
        }
      }
      if (vars.length > 0) {
        code.push("var " + vars.join(","));
      }
      for (i = dimension - 1; i >= 0; --i) {
        idx = order[i];
        code.push(["for(i", i, "=0;i", i, "<s", idx, ";++i", i, "){"].join(""));
      }
      code.push(body);
      for (i = 0; i < dimension; ++i) {
        pidx = idx;
        idx = order[i];
        for (j = 0; j < nargs; ++j) {
          code.push(["p", j, "+=d", j, "s", i].join(""));
        }
        if (has_index) {
          if (i > 0) {
            code.push(["index[", pidx, "]-=s", pidx].join(""));
          }
          code.push(["++index[", idx, "]"].join(""));
        }
        code.push("}");
      }
      return code.join("\n");
    }
    function outerFill(matched, order, proc, body) {
      var dimension = order.length, nargs = proc.arrayArgs.length, blockSize = proc.blockSize, has_index = proc.indexArgs.length > 0, code = [];
      for (var i = 0; i < nargs; ++i) {
        code.push(["var offset", i, "=p", i].join(""));
      }
      for (var i = matched; i < dimension; ++i) {
        code.push(["for(var j" + i + "=SS[", order[i], "]|0;j", i, ">0;){"].join(""));
        code.push(["if(j", i, "<", blockSize, "){"].join(""));
        code.push(["s", order[i], "=j", i].join(""));
        code.push(["j", i, "=0"].join(""));
        code.push(["}else{s", order[i], "=", blockSize].join(""));
        code.push(["j", i, "-=", blockSize, "}"].join(""));
        if (has_index) {
          code.push(["index[", order[i], "]=j", i].join(""));
        }
      }
      for (var i = 0; i < nargs; ++i) {
        var indexStr = ["offset" + i];
        for (var j = matched; j < dimension; ++j) {
          indexStr.push(["j", j, "*t", i, "p", order[j]].join(""));
        }
        code.push(["p", i, "=(", indexStr.join("+"), ")"].join(""));
      }
      code.push(innerFill(order, proc, body));
      for (var i = matched; i < dimension; ++i) {
        code.push("}");
      }
      return code.join("\n");
    }
    function countMatches(orders) {
      var matched = 0, dimension = orders[0].length;
      while (matched < dimension) {
        for (var j = 1; j < orders.length; ++j) {
          if (orders[j][matched] !== orders[0][matched]) {
            return matched;
          }
        }
        ++matched;
      }
      return matched;
    }
    function processBlock(block, proc, dtypes) {
      var code = block.body;
      var pre = [];
      var post = [];
      for (var i = 0; i < block.args.length; ++i) {
        var carg = block.args[i];
        if (carg.count <= 0) {
          continue;
        }
        var re = new RegExp(carg.name, "g");
        var ptrStr = "";
        var arrNum = proc.arrayArgs.indexOf(i);
        switch (proc.argTypes[i]) {
          case "offset":
            var offArgIndex = proc.offsetArgIndex.indexOf(i);
            var offArg = proc.offsetArgs[offArgIndex];
            arrNum = offArg.array;
            ptrStr = "+q" + offArgIndex;
          // Adds offset to the "pointer" in the array
          case "array":
            ptrStr = "p" + arrNum + ptrStr;
            var localStr = "l" + i;
            var arrStr = "a" + arrNum;
            if (proc.arrayBlockIndices[arrNum] === 0) {
              if (carg.count === 1) {
                if (dtypes[arrNum] === "generic") {
                  if (carg.lvalue) {
                    pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join(""));
                    code = code.replace(re, localStr);
                    post.push([arrStr, ".set(", ptrStr, ",", localStr, ")"].join(""));
                  } else {
                    code = code.replace(re, [arrStr, ".get(", ptrStr, ")"].join(""));
                  }
                } else {
                  code = code.replace(re, [arrStr, "[", ptrStr, "]"].join(""));
                }
              } else if (dtypes[arrNum] === "generic") {
                pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join(""));
                code = code.replace(re, localStr);
                if (carg.lvalue) {
                  post.push([arrStr, ".set(", ptrStr, ",", localStr, ")"].join(""));
                }
              } else {
                pre.push(["var ", localStr, "=", arrStr, "[", ptrStr, "]"].join(""));
                code = code.replace(re, localStr);
                if (carg.lvalue) {
                  post.push([arrStr, "[", ptrStr, "]=", localStr].join(""));
                }
              }
            } else {
              var reStrArr = [carg.name], ptrStrArr = [ptrStr];
              for (var j = 0; j < Math.abs(proc.arrayBlockIndices[arrNum]); j++) {
                reStrArr.push("\\s*\\[([^\\]]+)\\]");
                ptrStrArr.push("$" + (j + 1) + "*t" + arrNum + "b" + j);
              }
              re = new RegExp(reStrArr.join(""), "g");
              ptrStr = ptrStrArr.join("+");
              if (dtypes[arrNum] === "generic") {
                throw new Error("cwise: Generic arrays not supported in combination with blocks!");
              } else {
                code = code.replace(re, [arrStr, "[", ptrStr, "]"].join(""));
              }
            }
            break;
          case "scalar":
            code = code.replace(re, "Y" + proc.scalarArgs.indexOf(i));
            break;
          case "index":
            code = code.replace(re, "index");
            break;
          case "shape":
            code = code.replace(re, "shape");
            break;
        }
      }
      return [pre.join("\n"), code, post.join("\n")].join("\n").trim();
    }
    function typeSummary(dtypes) {
      var summary = new Array(dtypes.length);
      var allEqual = true;
      for (var i = 0; i < dtypes.length; ++i) {
        var t = dtypes[i];
        var digits = t.match(/\d+/);
        if (!digits) {
          digits = "";
        } else {
          digits = digits[0];
        }
        if (t.charAt(0) === 0) {
          summary[i] = "u" + t.charAt(1) + digits;
        } else {
          summary[i] = t.charAt(0) + digits;
        }
        if (i > 0) {
          allEqual = allEqual && summary[i] === summary[i - 1];
        }
      }
      if (allEqual) {
        return summary[0];
      }
      return summary.join("");
    }
    function generateCWiseOp(proc, typesig) {
      var dimension = typesig[1].length - Math.abs(proc.arrayBlockIndices[0]) | 0;
      var orders = new Array(proc.arrayArgs.length);
      var dtypes = new Array(proc.arrayArgs.length);
      for (var i = 0; i < proc.arrayArgs.length; ++i) {
        dtypes[i] = typesig[2 * i];
        orders[i] = typesig[2 * i + 1];
      }
      var blockBegin = [], blockEnd = [];
      var loopBegin = [], loopEnd = [];
      var loopOrders = [];
      for (var i = 0; i < proc.arrayArgs.length; ++i) {
        if (proc.arrayBlockIndices[i] < 0) {
          loopBegin.push(0);
          loopEnd.push(dimension);
          blockBegin.push(dimension);
          blockEnd.push(dimension + proc.arrayBlockIndices[i]);
        } else {
          loopBegin.push(proc.arrayBlockIndices[i]);
          loopEnd.push(proc.arrayBlockIndices[i] + dimension);
          blockBegin.push(0);
          blockEnd.push(proc.arrayBlockIndices[i]);
        }
        var newOrder = [];
        for (var j = 0; j < orders[i].length; j++) {
          if (loopBegin[i] <= orders[i][j] && orders[i][j] < loopEnd[i]) {
            newOrder.push(orders[i][j] - loopBegin[i]);
          }
        }
        loopOrders.push(newOrder);
      }
      var arglist = ["SS"];
      var code = ["'use strict'"];
      var vars = [];
      for (var j = 0; j < dimension; ++j) {
        vars.push(["s", j, "=SS[", j, "]"].join(""));
      }
      for (var i = 0; i < proc.arrayArgs.length; ++i) {
        arglist.push("a" + i);
        arglist.push("t" + i);
        arglist.push("p" + i);
        for (var j = 0; j < dimension; ++j) {
          vars.push(["t", i, "p", j, "=t", i, "[", loopBegin[i] + j, "]"].join(""));
        }
        for (var j = 0; j < Math.abs(proc.arrayBlockIndices[i]); ++j) {
          vars.push(["t", i, "b", j, "=t", i, "[", blockBegin[i] + j, "]"].join(""));
        }
      }
      for (var i = 0; i < proc.scalarArgs.length; ++i) {
        arglist.push("Y" + i);
      }
      if (proc.shapeArgs.length > 0) {
        vars.push("shape=SS.slice(0)");
      }
      if (proc.indexArgs.length > 0) {
        var zeros2 = new Array(dimension);
        for (var i = 0; i < dimension; ++i) {
          zeros2[i] = "0";
        }
        vars.push(["index=[", zeros2.join(","), "]"].join(""));
      }
      for (var i = 0; i < proc.offsetArgs.length; ++i) {
        var off_arg = proc.offsetArgs[i];
        var init_string = [];
        for (var j = 0; j < off_arg.offset.length; ++j) {
          if (off_arg.offset[j] === 0) {
            continue;
          } else if (off_arg.offset[j] === 1) {
            init_string.push(["t", off_arg.array, "p", j].join(""));
          } else {
            init_string.push([off_arg.offset[j], "*t", off_arg.array, "p", j].join(""));
          }
        }
        if (init_string.length === 0) {
          vars.push("q" + i + "=0");
        } else {
          vars.push(["q", i, "=", init_string.join("+")].join(""));
        }
      }
      var thisVars = uniq([].concat(proc.pre.thisVars).concat(proc.body.thisVars).concat(proc.post.thisVars));
      vars = vars.concat(thisVars);
      if (vars.length > 0) {
        code.push("var " + vars.join(","));
      }
      for (var i = 0; i < proc.arrayArgs.length; ++i) {
        code.push("p" + i + "|=0");
      }
      if (proc.pre.body.length > 3) {
        code.push(processBlock(proc.pre, proc, dtypes));
      }
      var body = processBlock(proc.body, proc, dtypes);
      var matched = countMatches(loopOrders);
      if (matched < dimension) {
        code.push(outerFill(matched, loopOrders[0], proc, body));
      } else {
        code.push(innerFill(loopOrders[0], proc, body));
      }
      if (proc.post.body.length > 3) {
        code.push(processBlock(proc.post, proc, dtypes));
      }
      if (proc.debug) {
        console.log("-----Generated cwise routine for ", typesig, ":\n" + code.join("\n") + "\n----------");
      }
      var loopName = [proc.funcName || "unnamed", "_cwise_loop_", orders[0].join("s"), "m", matched, typeSummary(dtypes)].join("");
      var f = new Function(["function ", loopName, "(", arglist.join(","), "){", code.join("\n"), "} return ", loopName].join(""));
      return f();
    }
    module2.exports = generateCWiseOp;
  }
});

// node_modules/cwise-compiler/lib/thunk.js
var require_thunk = __commonJS({
  "node_modules/cwise-compiler/lib/thunk.js"(exports2, module2) {
    "use strict";
    var compile = require_compile();
    function createThunk(proc) {
      var code = ["'use strict'", "var CACHED={}"];
      var vars = [];
      var thunkName = proc.funcName + "_cwise_thunk";
      code.push(["return function ", thunkName, "(", proc.shimArgs.join(","), "){"].join(""));
      var typesig = [];
      var string_typesig = [];
      var proc_args = [[
        "array",
        proc.arrayArgs[0],
        ".shape.slice(",
        // Slice shape so that we only retain the shape over which we iterate (which gets passed to the cwise operator as SS).
        Math.max(0, proc.arrayBlockIndices[0]),
        proc.arrayBlockIndices[0] < 0 ? "," + proc.arrayBlockIndices[0] + ")" : ")"
      ].join("")];
      var shapeLengthConditions = [], shapeConditions = [];
      for (var i = 0; i < proc.arrayArgs.length; ++i) {
        var j = proc.arrayArgs[i];
        vars.push([
          "t",
          j,
          "=array",
          j,
          ".dtype,",
          "r",
          j,
          "=array",
          j,
          ".order"
        ].join(""));
        typesig.push("t" + j);
        typesig.push("r" + j);
        string_typesig.push("t" + j);
        string_typesig.push("r" + j + ".join()");
        proc_args.push("array" + j + ".data");
        proc_args.push("array" + j + ".stride");
        proc_args.push("array" + j + ".offset|0");
        if (i > 0) {
          shapeLengthConditions.push("array" + proc.arrayArgs[0] + ".shape.length===array" + j + ".shape.length+" + (Math.abs(proc.arrayBlockIndices[0]) - Math.abs(proc.arrayBlockIndices[i])));
          shapeConditions.push("array" + proc.arrayArgs[0] + ".shape[shapeIndex+" + Math.max(0, proc.arrayBlockIndices[0]) + "]===array" + j + ".shape[shapeIndex+" + Math.max(0, proc.arrayBlockIndices[i]) + "]");
        }
      }
      if (proc.arrayArgs.length > 1) {
        code.push("if (!(" + shapeLengthConditions.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same dimensionality!')");
        code.push("for(var shapeIndex=array" + proc.arrayArgs[0] + ".shape.length-" + Math.abs(proc.arrayBlockIndices[0]) + "; shapeIndex-->0;) {");
        code.push("if (!(" + shapeConditions.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same shape!')");
        code.push("}");
      }
      for (var i = 0; i < proc.scalarArgs.length; ++i) {
        proc_args.push("scalar" + proc.scalarArgs[i]);
      }
      vars.push(["type=[", string_typesig.join(","), "].join()"].join(""));
      vars.push("proc=CACHED[type]");
      code.push("var " + vars.join(","));
      code.push([
        "if(!proc){",
        "CACHED[type]=proc=compile([",
        typesig.join(","),
        "])}",
        "return proc(",
        proc_args.join(","),
        ")}"
      ].join(""));
      if (proc.debug) {
        console.log("-----Generated thunk:\n" + code.join("\n") + "\n----------");
      }
      var thunk = new Function("compile", code.join("\n"));
      return thunk(compile.bind(void 0, proc));
    }
    module2.exports = createThunk;
  }
});

// node_modules/cwise-compiler/compiler.js
var require_compiler = __commonJS({
  "node_modules/cwise-compiler/compiler.js"(exports2, module2) {
    "use strict";
    var createThunk = require_thunk();
    function Procedure() {
      this.argTypes = [];
      this.shimArgs = [];
      this.arrayArgs = [];
      this.arrayBlockIndices = [];
      this.scalarArgs = [];
      this.offsetArgs = [];
      this.offsetArgIndex = [];
      this.indexArgs = [];
      this.shapeArgs = [];
      this.funcName = "";
      this.pre = null;
      this.body = null;
      this.post = null;
      this.debug = false;
    }
    function compileCwise(user_args) {
      var proc = new Procedure();
      proc.pre = user_args.pre;
      proc.body = user_args.body;
      proc.post = user_args.post;
      var proc_args = user_args.args.slice(0);
      proc.argTypes = proc_args;
      for (var i = 0; i < proc_args.length; ++i) {
        var arg_type = proc_args[i];
        if (arg_type === "array" || typeof arg_type === "object" && arg_type.blockIndices) {
          proc.argTypes[i] = "array";
          proc.arrayArgs.push(i);
          proc.arrayBlockIndices.push(arg_type.blockIndices ? arg_type.blockIndices : 0);
          proc.shimArgs.push("array" + i);
          if (i < proc.pre.args.length && proc.pre.args[i].count > 0) {
            throw new Error("cwise: pre() block may not reference array args");
          }
          if (i < proc.post.args.length && proc.post.args[i].count > 0) {
            throw new Error("cwise: post() block may not reference array args");
          }
        } else if (arg_type === "scalar") {
          proc.scalarArgs.push(i);
          proc.shimArgs.push("scalar" + i);
        } else if (arg_type === "index") {
          proc.indexArgs.push(i);
          if (i < proc.pre.args.length && proc.pre.args[i].count > 0) {
            throw new Error("cwise: pre() block may not reference array index");
          }
          if (i < proc.body.args.length && proc.body.args[i].lvalue) {
            throw new Error("cwise: body() block may not write to array index");
          }
          if (i < proc.post.args.length && proc.post.args[i].count > 0) {
            throw new Error("cwise: post() block may not reference array index");
          }
        } else if (arg_type === "shape") {
          proc.shapeArgs.push(i);
          if (i < proc.pre.args.length && proc.pre.args[i].lvalue) {
            throw new Error("cwise: pre() block may not write to array shape");
          }
          if (i < proc.body.args.length && proc.body.args[i].lvalue) {
            throw new Error("cwise: body() block may not write to array shape");
          }
          if (i < proc.post.args.length && proc.post.args[i].lvalue) {
            throw new Error("cwise: post() block may not write to array shape");
          }
        } else if (typeof arg_type === "object" && arg_type.offset) {
          proc.argTypes[i] = "offset";
          proc.offsetArgs.push({ array: arg_type.array, offset: arg_type.offset });
          proc.offsetArgIndex.push(i);
        } else {
          throw new Error("cwise: Unknown argument type " + proc_args[i]);
        }
      }
      if (proc.arrayArgs.length <= 0) {
        throw new Error("cwise: No array arguments specified");
      }
      if (proc.pre.args.length > proc_args.length) {
        throw new Error("cwise: Too many arguments in pre() block");
      }
      if (proc.body.args.length > proc_args.length) {
        throw new Error("cwise: Too many arguments in body() block");
      }
      if (proc.post.args.length > proc_args.length) {
        throw new Error("cwise: Too many arguments in post() block");
      }
      proc.debug = !!user_args.printCode || !!user_args.debug;
      proc.funcName = user_args.funcName || "cwise";
      proc.blockSize = user_args.blockSize || 64;
      return createThunk(proc);
    }
    module2.exports = compileCwise;
  }
});

// node_modules/ndarray-ops/ndarray-ops.js
var require_ndarray_ops = __commonJS({
  "node_modules/ndarray-ops/ndarray-ops.js"(exports2) {
    "use strict";
    var compile = require_compiler();
    var EmptyProc = {
      body: "",
      args: [],
      thisVars: [],
      localVars: []
    };
    function fixup(x) {
      if (!x) {
        return EmptyProc;
      }
      for (var i = 0; i < x.args.length; ++i) {
        var a = x.args[i];
        if (i === 0) {
          x.args[i] = { name: a, lvalue: true, rvalue: !!x.rvalue, count: x.count || 1 };
        } else {
          x.args[i] = { name: a, lvalue: false, rvalue: true, count: 1 };
        }
      }
      if (!x.thisVars) {
        x.thisVars = [];
      }
      if (!x.localVars) {
        x.localVars = [];
      }
      return x;
    }
    function pcompile(user_args) {
      return compile({
        args: user_args.args,
        pre: fixup(user_args.pre),
        body: fixup(user_args.body),
        post: fixup(user_args.proc),
        funcName: user_args.funcName
      });
    }
    function makeOp(user_args) {
      var args = [];
      for (var i = 0; i < user_args.args.length; ++i) {
        args.push("a" + i);
      }
      var wrapper = new Function("P", [
        "return function ",
        user_args.funcName,
        "_ndarrayops(",
        args.join(","),
        ") {P(",
        args.join(","),
        ");return a0}"
      ].join(""));
      return wrapper(pcompile(user_args));
    }
    var assign_ops = {
      add: "+",
      sub: "-",
      mul: "*",
      div: "/",
      mod: "%",
      band: "&",
      bor: "|",
      bxor: "^",
      lshift: "<<",
      rshift: ">>",
      rrshift: ">>>"
    };
    (function() {
      for (var id in assign_ops) {
        var op = assign_ops[id];
        exports2[id] = makeOp({
          args: ["array", "array", "array"],
          body: {
            args: ["a", "b", "c"],
            body: "a=b" + op + "c"
          },
          funcName: id
        });
        exports2[id + "eq"] = makeOp({
          args: ["array", "array"],
          body: {
            args: ["a", "b"],
            body: "a" + op + "=b"
          },
          rvalue: true,
          funcName: id + "eq"
        });
        exports2[id + "s"] = makeOp({
          args: ["array", "array", "scalar"],
          body: {
            args: ["a", "b", "s"],
            body: "a=b" + op + "s"
          },
          funcName: id + "s"
        });
        exports2[id + "seq"] = makeOp({
          args: ["array", "scalar"],
          body: {
            args: ["a", "s"],
            body: "a" + op + "=s"
          },
          rvalue: true,
          funcName: id + "seq"
        });
      }
    })();
    var unary_ops = {
      not: "!",
      bnot: "~",
      neg: "-",
      recip: "1.0/"
    };
    (function() {
      for (var id in unary_ops) {
        var op = unary_ops[id];
        exports2[id] = makeOp({
          args: ["array", "array"],
          body: {
            args: ["a", "b"],
            body: "a=" + op + "b"
          },
          funcName: id
        });
        exports2[id + "eq"] = makeOp({
          args: ["array"],
          body: {
            args: ["a"],
            body: "a=" + op + "a"
          },
          rvalue: true,
          count: 2,
          funcName: id + "eq"
        });
      }
    })();
    var binary_ops = {
      and: "&&",
      or: "||",
      eq: "===",
      neq: "!==",
      lt: "<",
      gt: ">",
      leq: "<=",
      geq: ">="
    };
    (function() {
      for (var id in binary_ops) {
        var op = binary_ops[id];
        exports2[id] = makeOp({
          args: ["array", "array", "array"],
          body: {
            args: ["a", "b", "c"],
            body: "a=b" + op + "c"
          },
          funcName: id
        });
        exports2[id + "s"] = makeOp({
          args: ["array", "array", "scalar"],
          body: {
            args: ["a", "b", "s"],
            body: "a=b" + op + "s"
          },
          funcName: id + "s"
        });
        exports2[id + "eq"] = makeOp({
          args: ["array", "array"],
          body: {
            args: ["a", "b"],
            body: "a=a" + op + "b"
          },
          rvalue: true,
          count: 2,
          funcName: id + "eq"
        });
        exports2[id + "seq"] = makeOp({
          args: ["array", "scalar"],
          body: {
            args: ["a", "s"],
            body: "a=a" + op + "s"
          },
          rvalue: true,
          count: 2,
          funcName: id + "seq"
        });
      }
    })();
    var math_unary = [
      "abs",
      "acos",
      "asin",
      "atan",
      "ceil",
      "cos",
      "exp",
      "floor",
      "log",
      "round",
      "sin",
      "sqrt",
      "tan"
    ];
    (function() {
      for (var i = 0; i < math_unary.length; ++i) {
        var f = math_unary[i];
        exports2[f] = makeOp({
          args: ["array", "array"],
          pre: { args: [], body: "this_f=Math." + f, thisVars: ["this_f"] },
          body: { args: ["a", "b"], body: "a=this_f(b)", thisVars: ["this_f"] },
          funcName: f
        });
        exports2[f + "eq"] = makeOp({
          args: ["array"],
          pre: { args: [], body: "this_f=Math." + f, thisVars: ["this_f"] },
          body: { args: ["a"], body: "a=this_f(a)", thisVars: ["this_f"] },
          rvalue: true,
          count: 2,
          funcName: f + "eq"
        });
      }
    })();
    var math_comm = [
      "max",
      "min",
      "atan2",
      "pow"
    ];
    (function() {
      for (var i = 0; i < math_comm.length; ++i) {
        var f = math_comm[i];
        exports2[f] = makeOp({
          args: ["array", "array", "array"],
          pre: { args: [], body: "this_f=Math." + f, thisVars: ["this_f"] },
          body: { args: ["a", "b", "c"], body: "a=this_f(b,c)", thisVars: ["this_f"] },
          funcName: f
        });
        exports2[f + "s"] = makeOp({
          args: ["array", "array", "scalar"],
          pre: { args: [], body: "this_f=Math." + f, thisVars: ["this_f"] },
          body: { args: ["a", "b", "c"], body: "a=this_f(b,c)", thisVars: ["this_f"] },
          funcName: f + "s"
        });
        exports2[f + "eq"] = makeOp({
          args: ["array", "array"],
          pre: { args: [], body: "this_f=Math." + f, thisVars: ["this_f"] },
          body: { args: ["a", "b"], body: "a=this_f(a,b)", thisVars: ["this_f"] },
          rvalue: true,
          count: 2,
          funcName: f + "eq"
        });
        exports2[f + "seq"] = makeOp({
          args: ["array", "scalar"],
          pre: { args: [], body: "this_f=Math." + f, thisVars: ["this_f"] },
          body: { args: ["a", "b"], body: "a=this_f(a,b)", thisVars: ["this_f"] },
          rvalue: true,
          count: 2,
          funcName: f + "seq"
        });
      }
    })();
    var math_noncomm = [
      "atan2",
      "pow"
    ];
    (function() {
      for (var i = 0; i < math_noncomm.length; ++i) {
        var f = math_noncomm[i];
        exports2[f + "op"] = makeOp({
          args: ["array", "array", "array"],
          pre: { args: [], body: "this_f=Math." + f, thisVars: ["this_f"] },
          body: { args: ["a", "b", "c"], body: "a=this_f(c,b)", thisVars: ["this_f"] },
          funcName: f + "op"
        });
        exports2[f + "ops"] = makeOp({
          args: ["array", "array", "scalar"],
          pre: { args: [], body: "this_f=Math." + f, thisVars: ["this_f"] },
          body: { args: ["a", "b", "c"], body: "a=this_f(c,b)", thisVars: ["this_f"] },
          funcName: f + "ops"
        });
        exports2[f + "opeq"] = makeOp({
          args: ["array", "array"],
          pre: { args: [], body: "this_f=Math." + f, thisVars: ["this_f"] },
          body: { args: ["a", "b"], body: "a=this_f(b,a)", thisVars: ["this_f"] },
          rvalue: true,
          count: 2,
          funcName: f + "opeq"
        });
        exports2[f + "opseq"] = makeOp({
          args: ["array", "scalar"],
          pre: { args: [], body: "this_f=Math." + f, thisVars: ["this_f"] },
          body: { args: ["a", "b"], body: "a=this_f(b,a)", thisVars: ["this_f"] },
          rvalue: true,
          count: 2,
          funcName: f + "opseq"
        });
      }
    })();
    exports2.any = compile({
      args: ["array"],
      pre: EmptyProc,
      body: { args: [{ name: "a", lvalue: false, rvalue: true, count: 1 }], body: "if(a){return true}", localVars: [], thisVars: [] },
      post: { args: [], localVars: [], thisVars: [], body: "return false" },
      funcName: "any"
    });
    exports2.all = compile({
      args: ["array"],
      pre: EmptyProc,
      body: { args: [{ name: "x", lvalue: false, rvalue: true, count: 1 }], body: "if(!x){return false}", localVars: [], thisVars: [] },
      post: { args: [], localVars: [], thisVars: [], body: "return true" },
      funcName: "all"
    });
    exports2.sum = compile({
      args: ["array"],
      pre: { args: [], localVars: [], thisVars: ["this_s"], body: "this_s=0" },
      body: { args: [{ name: "a", lvalue: false, rvalue: true, count: 1 }], body: "this_s+=a", localVars: [], thisVars: ["this_s"] },
      post: { args: [], localVars: [], thisVars: ["this_s"], body: "return this_s" },
      funcName: "sum"
    });
    exports2.prod = compile({
      args: ["array"],
      pre: { args: [], localVars: [], thisVars: ["this_s"], body: "this_s=1" },
      body: { args: [{ name: "a", lvalue: false, rvalue: true, count: 1 }], body: "this_s*=a", localVars: [], thisVars: ["this_s"] },
      post: { args: [], localVars: [], thisVars: ["this_s"], body: "return this_s" },
      funcName: "prod"
    });
    exports2.norm2squared = compile({
      args: ["array"],
      pre: { args: [], localVars: [], thisVars: ["this_s"], body: "this_s=0" },
      body: { args: [{ name: "a", lvalue: false, rvalue: true, count: 2 }], body: "this_s+=a*a", localVars: [], thisVars: ["this_s"] },
      post: { args: [], localVars: [], thisVars: ["this_s"], body: "return this_s" },
      funcName: "norm2squared"
    });
    exports2.norm2 = compile({
      args: ["array"],
      pre: { args: [], localVars: [], thisVars: ["this_s"], body: "this_s=0" },
      body: { args: [{ name: "a", lvalue: false, rvalue: true, count: 2 }], body: "this_s+=a*a", localVars: [], thisVars: ["this_s"] },
      post: { args: [], localVars: [], thisVars: ["this_s"], body: "return Math.sqrt(this_s)" },
      funcName: "norm2"
    });
    exports2.norminf = compile({
      args: ["array"],
      pre: { args: [], localVars: [], thisVars: ["this_s"], body: "this_s=0" },
      body: { args: [{ name: "a", lvalue: false, rvalue: true, count: 4 }], body: "if(-a>this_s){this_s=-a}else if(a>this_s){this_s=a}", localVars: [], thisVars: ["this_s"] },
      post: { args: [], localVars: [], thisVars: ["this_s"], body: "return this_s" },
      funcName: "norminf"
    });
    exports2.norm1 = compile({
      args: ["array"],
      pre: { args: [], localVars: [], thisVars: ["this_s"], body: "this_s=0" },
      body: { args: [{ name: "a", lvalue: false, rvalue: true, count: 3 }], body: "this_s+=a<0?-a:a", localVars: [], thisVars: ["this_s"] },
      post: { args: [], localVars: [], thisVars: ["this_s"], body: "return this_s" },
      funcName: "norm1"
    });
    exports2.sup = compile({
      args: ["array"],
      pre: {
        body: "this_h=-Infinity",
        args: [],
        thisVars: ["this_h"],
        localVars: []
      },
      body: {
        body: "if(_inline_1_arg0_>this_h)this_h=_inline_1_arg0_",
        args: [{ "name": "_inline_1_arg0_", "lvalue": false, "rvalue": true, "count": 2 }],
        thisVars: ["this_h"],
        localVars: []
      },
      post: {
        body: "return this_h",
        args: [],
        thisVars: ["this_h"],
        localVars: []
      }
    });
    exports2.inf = compile({
      args: ["array"],
      pre: {
        body: "this_h=Infinity",
        args: [],
        thisVars: ["this_h"],
        localVars: []
      },
      body: {
        body: "if(_inline_1_arg0_<this_h)this_h=_inline_1_arg0_",
        args: [{ "name": "_inline_1_arg0_", "lvalue": false, "rvalue": true, "count": 2 }],
        thisVars: ["this_h"],
        localVars: []
      },
      post: {
        body: "return this_h",
        args: [],
        thisVars: ["this_h"],
        localVars: []
      }
    });
    exports2.argmin = compile({
      args: ["index", "array", "shape"],
      pre: {
        body: "{this_v=Infinity;this_i=_inline_0_arg2_.slice(0)}",
        args: [
          { name: "_inline_0_arg0_", lvalue: false, rvalue: false, count: 0 },
          { name: "_inline_0_arg1_", lvalue: false, rvalue: false, count: 0 },
          { name: "_inline_0_arg2_", lvalue: false, rvalue: true, count: 1 }
        ],
        thisVars: ["this_i", "this_v"],
        localVars: []
      },
      body: {
        body: "{if(_inline_1_arg1_<this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}",
        args: [
          { name: "_inline_1_arg0_", lvalue: false, rvalue: true, count: 2 },
          { name: "_inline_1_arg1_", lvalue: false, rvalue: true, count: 2 }
        ],
        thisVars: ["this_i", "this_v"],
        localVars: ["_inline_1_k"]
      },
      post: {
        body: "{return this_i}",
        args: [],
        thisVars: ["this_i"],
        localVars: []
      }
    });
    exports2.argmax = compile({
      args: ["index", "array", "shape"],
      pre: {
        body: "{this_v=-Infinity;this_i=_inline_0_arg2_.slice(0)}",
        args: [
          { name: "_inline_0_arg0_", lvalue: false, rvalue: false, count: 0 },
          { name: "_inline_0_arg1_", lvalue: false, rvalue: false, count: 0 },
          { name: "_inline_0_arg2_", lvalue: false, rvalue: true, count: 1 }
        ],
        thisVars: ["this_i", "this_v"],
        localVars: []
      },
      body: {
        body: "{if(_inline_1_arg1_>this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}",
        args: [
          { name: "_inline_1_arg0_", lvalue: false, rvalue: true, count: 2 },
          { name: "_inline_1_arg1_", lvalue: false, rvalue: true, count: 2 }
        ],
        thisVars: ["this_i", "this_v"],
        localVars: ["_inline_1_k"]
      },
      post: {
        body: "{return this_i}",
        args: [],
        thisVars: ["this_i"],
        localVars: []
      }
    });
    exports2.random = makeOp({
      args: ["array"],
      pre: { args: [], body: "this_f=Math.random", thisVars: ["this_f"] },
      body: { args: ["a"], body: "a=this_f()", thisVars: ["this_f"] },
      funcName: "random"
    });
    exports2.assign = makeOp({
      args: ["array", "array"],
      body: { args: ["a", "b"], body: "a=b" },
      funcName: "assign"
    });
    exports2.assigns = makeOp({
      args: ["array", "scalar"],
      body: { args: ["a", "b"], body: "a=b" },
      funcName: "assigns"
    });
    exports2.equals = compile({
      args: ["array", "array"],
      pre: EmptyProc,
      body: {
        args: [
          { name: "x", lvalue: false, rvalue: true, count: 1 },
          { name: "y", lvalue: false, rvalue: true, count: 1 }
        ],
        body: "if(x!==y){return false}",
        localVars: [],
        thisVars: []
      },
      post: { args: [], localVars: [], thisVars: [], body: "return true" },
      funcName: "equals"
    });
  }
});

// node_modules/bit-twiddle/twiddle.js
var require_twiddle = __commonJS({
  "node_modules/bit-twiddle/twiddle.js"(exports2) {
    "use strict";
    "use restrict";
    var INT_BITS = 32;
    exports2.INT_BITS = INT_BITS;
    exports2.INT_MAX = 2147483647;
    exports2.INT_MIN = -1 << INT_BITS - 1;
    exports2.sign = function(v) {
      return (v > 0) - (v < 0);
    };
    exports2.abs = function(v) {
      var mask = v >> INT_BITS - 1;
      return (v ^ mask) - mask;
    };
    exports2.min = function(x, y) {
      return y ^ (x ^ y) & -(x < y);
    };
    exports2.max = function(x, y) {
      return x ^ (x ^ y) & -(x < y);
    };
    exports2.isPow2 = function(v) {
      return !(v & v - 1) && !!v;
    };
    exports2.log2 = function(v) {
      var r, shift;
      r = (v > 65535) << 4;
      v >>>= r;
      shift = (v > 255) << 3;
      v >>>= shift;
      r |= shift;
      shift = (v > 15) << 2;
      v >>>= shift;
      r |= shift;
      shift = (v > 3) << 1;
      v >>>= shift;
      r |= shift;
      return r | v >> 1;
    };
    exports2.log10 = function(v) {
      return v >= 1e9 ? 9 : v >= 1e8 ? 8 : v >= 1e7 ? 7 : v >= 1e6 ? 6 : v >= 1e5 ? 5 : v >= 1e4 ? 4 : v >= 1e3 ? 3 : v >= 100 ? 2 : v >= 10 ? 1 : 0;
    };
    exports2.popCount = function(v) {
      v = v - (v >>> 1 & 1431655765);
      v = (v & 858993459) + (v >>> 2 & 858993459);
      return (v + (v >>> 4) & 252645135) * 16843009 >>> 24;
    };
    function countTrailingZeros(v) {
      var c = 32;
      v &= -v;
      if (v) c--;
      if (v & 65535) c -= 16;
      if (v & 16711935) c -= 8;
      if (v & 252645135) c -= 4;
      if (v & 858993459) c -= 2;
      if (v & 1431655765) c -= 1;
      return c;
    }
    exports2.countTrailingZeros = countTrailingZeros;
    exports2.nextPow2 = function(v) {
      v += v === 0;
      --v;
      v |= v >>> 1;
      v |= v >>> 2;
      v |= v >>> 4;
      v |= v >>> 8;
      v |= v >>> 16;
      return v + 1;
    };
    exports2.prevPow2 = function(v) {
      v |= v >>> 1;
      v |= v >>> 2;
      v |= v >>> 4;
      v |= v >>> 8;
      v |= v >>> 16;
      return v - (v >>> 1);
    };
    exports2.parity = function(v) {
      v ^= v >>> 16;
      v ^= v >>> 8;
      v ^= v >>> 4;
      v &= 15;
      return 27030 >>> v & 1;
    };
    var REVERSE_TABLE = new Array(256);
    (function(tab) {
      for (var i = 0; i < 256; ++i) {
        var v = i, r = i, s = 7;
        for (v >>>= 1; v; v >>>= 1) {
          r <<= 1;
          r |= v & 1;
          --s;
        }
        tab[i] = r << s & 255;
      }
    })(REVERSE_TABLE);
    exports2.reverse = function(v) {
      return REVERSE_TABLE[v & 255] << 24 | REVERSE_TABLE[v >>> 8 & 255] << 16 | REVERSE_TABLE[v >>> 16 & 255] << 8 | REVERSE_TABLE[v >>> 24 & 255];
    };
    exports2.interleave2 = function(x, y) {
      x &= 65535;
      x = (x | x << 8) & 16711935;
      x = (x | x << 4) & 252645135;
      x = (x | x << 2) & 858993459;
      x = (x | x << 1) & 1431655765;
      y &= 65535;
      y = (y | y << 8) & 16711935;
      y = (y | y << 4) & 252645135;
      y = (y | y << 2) & 858993459;
      y = (y | y << 1) & 1431655765;
      return x | y << 1;
    };
    exports2.deinterleave2 = function(v, n) {
      v = v >>> n & 1431655765;
      v = (v | v >>> 1) & 858993459;
      v = (v | v >>> 2) & 252645135;
      v = (v | v >>> 4) & 16711935;
      v = (v | v >>> 16) & 65535;
      return v << 16 >> 16;
    };
    exports2.interleave3 = function(x, y, z) {
      x &= 1023;
      x = (x | x << 16) & 4278190335;
      x = (x | x << 8) & 251719695;
      x = (x | x << 4) & 3272356035;
      x = (x | x << 2) & 1227133513;
      y &= 1023;
      y = (y | y << 16) & 4278190335;
      y = (y | y << 8) & 251719695;
      y = (y | y << 4) & 3272356035;
      y = (y | y << 2) & 1227133513;
      x |= y << 1;
      z &= 1023;
      z = (z | z << 16) & 4278190335;
      z = (z | z << 8) & 251719695;
      z = (z | z << 4) & 3272356035;
      z = (z | z << 2) & 1227133513;
      return x | z << 2;
    };
    exports2.deinterleave3 = function(v, n) {
      v = v >>> n & 1227133513;
      v = (v | v >>> 2) & 3272356035;
      v = (v | v >>> 4) & 251719695;
      v = (v | v >>> 8) & 4278190335;
      v = (v | v >>> 16) & 1023;
      return v << 22 >> 22;
    };
    exports2.nextCombination = function(v) {
      var t = v | v - 1;
      return t + 1 | (~t & -~t) - 1 >>> countTrailingZeros(v) + 1;
    };
  }
});

// node_modules/dup/dup.js
var require_dup = __commonJS({
  "node_modules/dup/dup.js"(exports2, module2) {
    "use strict";
    function dupe_array(count, value, i) {
      var c = count[i] | 0;
      if (c <= 0) {
        return [];
      }
      var result = new Array(c), j;
      if (i === count.length - 1) {
        for (j = 0; j < c; ++j) {
          result[j] = value;
        }
      } else {
        for (j = 0; j < c; ++j) {
          result[j] = dupe_array(count, value, i + 1);
        }
      }
      return result;
    }
    function dupe_number(count, value) {
      var result, i;
      result = new Array(count);
      for (i = 0; i < count; ++i) {
        result[i] = value;
      }
      return result;
    }
    function dupe(count, value) {
      if (typeof value === "undefined") {
        value = 0;
      }
      switch (typeof count) {
        case "number":
          if (count > 0) {
            return dupe_number(count | 0, value);
          }
          break;
        case "object":
          if (typeof count.length === "number") {
            return dupe_array(count, value, 0);
          }
          break;
      }
      return [];
    }
    module2.exports = dupe;
  }
});

// browser-external:buffer
var require_buffer = __commonJS({
  "browser-external:buffer"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "buffer" has been externalized for browser compatibility. Cannot access "buffer.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/typedarray-pool/pool.js
var require_pool2 = __commonJS({
  "node_modules/typedarray-pool/pool.js"(exports2) {
    "use strict";
    var bits = require_twiddle();
    var dup = require_dup();
    var Buffer2 = require_buffer().Buffer;
    if (!global.__TYPEDARRAY_POOL) {
      global.__TYPEDARRAY_POOL = {
        UINT8: dup([32, 0]),
        UINT16: dup([32, 0]),
        UINT32: dup([32, 0]),
        BIGUINT64: dup([32, 0]),
        INT8: dup([32, 0]),
        INT16: dup([32, 0]),
        INT32: dup([32, 0]),
        BIGINT64: dup([32, 0]),
        FLOAT: dup([32, 0]),
        DOUBLE: dup([32, 0]),
        DATA: dup([32, 0]),
        UINT8C: dup([32, 0]),
        BUFFER: dup([32, 0])
      };
    }
    var hasUint8C = typeof Uint8ClampedArray !== "undefined";
    var hasBigUint64 = typeof BigUint64Array !== "undefined";
    var hasBigInt64 = typeof BigInt64Array !== "undefined";
    var POOL = global.__TYPEDARRAY_POOL;
    if (!POOL.UINT8C) {
      POOL.UINT8C = dup([32, 0]);
    }
    if (!POOL.BIGUINT64) {
      POOL.BIGUINT64 = dup([32, 0]);
    }
    if (!POOL.BIGINT64) {
      POOL.BIGINT64 = dup([32, 0]);
    }
    if (!POOL.BUFFER) {
      POOL.BUFFER = dup([32, 0]);
    }
    var DATA = POOL.DATA;
    var BUFFER = POOL.BUFFER;
    exports2.free = function free(array) {
      if (Buffer2.isBuffer(array)) {
        BUFFER[bits.log2(array.length)].push(array);
      } else {
        if (Object.prototype.toString.call(array) !== "[object ArrayBuffer]") {
          array = array.buffer;
        }
        if (!array) {
          return;
        }
        var n = array.length || array.byteLength;
        var log_n = bits.log2(n) | 0;
        DATA[log_n].push(array);
      }
    };
    function freeArrayBuffer(buffer2) {
      if (!buffer2) {
        return;
      }
      var n = buffer2.length || buffer2.byteLength;
      var log_n = bits.log2(n);
      DATA[log_n].push(buffer2);
    }
    function freeTypedArray(array) {
      freeArrayBuffer(array.buffer);
    }
    exports2.freeUint8 = exports2.freeUint16 = exports2.freeUint32 = exports2.freeBigUint64 = exports2.freeInt8 = exports2.freeInt16 = exports2.freeInt32 = exports2.freeBigInt64 = exports2.freeFloat32 = exports2.freeFloat = exports2.freeFloat64 = exports2.freeDouble = exports2.freeUint8Clamped = exports2.freeDataView = freeTypedArray;
    exports2.freeArrayBuffer = freeArrayBuffer;
    exports2.freeBuffer = function freeBuffer(array) {
      BUFFER[bits.log2(array.length)].push(array);
    };
    exports2.malloc = function malloc(n, dtype) {
      if (dtype === void 0 || dtype === "arraybuffer") {
        return mallocArrayBuffer(n);
      } else {
        switch (dtype) {
          case "uint8":
            return mallocUint8(n);
          case "uint16":
            return mallocUint16(n);
          case "uint32":
            return mallocUint32(n);
          case "int8":
            return mallocInt8(n);
          case "int16":
            return mallocInt16(n);
          case "int32":
            return mallocInt32(n);
          case "float":
          case "float32":
            return mallocFloat(n);
          case "double":
          case "float64":
            return mallocDouble(n);
          case "uint8_clamped":
            return mallocUint8Clamped(n);
          case "bigint64":
            return mallocBigInt64(n);
          case "biguint64":
            return mallocBigUint64(n);
          case "buffer":
            return mallocBuffer(n);
          case "data":
          case "dataview":
            return mallocDataView(n);
          default:
            return null;
        }
      }
      return null;
    };
    function mallocArrayBuffer(n) {
      var n = bits.nextPow2(n);
      var log_n = bits.log2(n);
      var d = DATA[log_n];
      if (d.length > 0) {
        return d.pop();
      }
      return new ArrayBuffer(n);
    }
    exports2.mallocArrayBuffer = mallocArrayBuffer;
    function mallocUint8(n) {
      return new Uint8Array(mallocArrayBuffer(n), 0, n);
    }
    exports2.mallocUint8 = mallocUint8;
    function mallocUint16(n) {
      return new Uint16Array(mallocArrayBuffer(2 * n), 0, n);
    }
    exports2.mallocUint16 = mallocUint16;
    function mallocUint32(n) {
      return new Uint32Array(mallocArrayBuffer(4 * n), 0, n);
    }
    exports2.mallocUint32 = mallocUint32;
    function mallocInt8(n) {
      return new Int8Array(mallocArrayBuffer(n), 0, n);
    }
    exports2.mallocInt8 = mallocInt8;
    function mallocInt16(n) {
      return new Int16Array(mallocArrayBuffer(2 * n), 0, n);
    }
    exports2.mallocInt16 = mallocInt16;
    function mallocInt32(n) {
      return new Int32Array(mallocArrayBuffer(4 * n), 0, n);
    }
    exports2.mallocInt32 = mallocInt32;
    function mallocFloat(n) {
      return new Float32Array(mallocArrayBuffer(4 * n), 0, n);
    }
    exports2.mallocFloat32 = exports2.mallocFloat = mallocFloat;
    function mallocDouble(n) {
      return new Float64Array(mallocArrayBuffer(8 * n), 0, n);
    }
    exports2.mallocFloat64 = exports2.mallocDouble = mallocDouble;
    function mallocUint8Clamped(n) {
      if (hasUint8C) {
        return new Uint8ClampedArray(mallocArrayBuffer(n), 0, n);
      } else {
        return mallocUint8(n);
      }
    }
    exports2.mallocUint8Clamped = mallocUint8Clamped;
    function mallocBigUint64(n) {
      if (hasBigUint64) {
        return new BigUint64Array(mallocArrayBuffer(8 * n), 0, n);
      } else {
        return null;
      }
    }
    exports2.mallocBigUint64 = mallocBigUint64;
    function mallocBigInt64(n) {
      if (hasBigInt64) {
        return new BigInt64Array(mallocArrayBuffer(8 * n), 0, n);
      } else {
        return null;
      }
    }
    exports2.mallocBigInt64 = mallocBigInt64;
    function mallocDataView(n) {
      return new DataView(mallocArrayBuffer(n), 0, n);
    }
    exports2.mallocDataView = mallocDataView;
    function mallocBuffer(n) {
      n = bits.nextPow2(n);
      var log_n = bits.log2(n);
      var cache = BUFFER[log_n];
      if (cache.length > 0) {
        return cache.pop();
      }
      return new Buffer2(n);
    }
    exports2.mallocBuffer = mallocBuffer;
    exports2.clearCache = function clearCache() {
      for (var i = 0; i < 32; ++i) {
        POOL.UINT8[i].length = 0;
        POOL.UINT16[i].length = 0;
        POOL.UINT32[i].length = 0;
        POOL.INT8[i].length = 0;
        POOL.INT16[i].length = 0;
        POOL.INT32[i].length = 0;
        POOL.FLOAT[i].length = 0;
        POOL.DOUBLE[i].length = 0;
        POOL.BIGUINT64[i].length = 0;
        POOL.BIGINT64[i].length = 0;
        POOL.UINT8C[i].length = 0;
        DATA[i].length = 0;
        BUFFER[i].length = 0;
      }
    };
  }
});

// node_modules/ndarray-fft/lib/fft-matrix.js
var require_fft_matrix = __commonJS({
  "node_modules/ndarray-fft/lib/fft-matrix.js"(exports2, module2) {
    var bits = require_twiddle();
    function fft2(dir, nrows, ncols, buffer2, x_ptr, y_ptr, scratch_ptr) {
      dir |= 0;
      nrows |= 0;
      ncols |= 0;
      x_ptr |= 0;
      y_ptr |= 0;
      if (bits.isPow2(ncols)) {
        fftRadix2(dir, nrows, ncols, buffer2, x_ptr, y_ptr);
      } else {
        fftBluestein(dir, nrows, ncols, buffer2, x_ptr, y_ptr, scratch_ptr);
      }
    }
    module2.exports = fft2;
    function scratchMemory(n) {
      if (bits.isPow2(n)) {
        return 0;
      }
      return 2 * n + 4 * bits.nextPow2(2 * n + 1);
    }
    module2.exports.scratchMemory = scratchMemory;
    function fftRadix2(dir, nrows, ncols, buffer2, x_ptr, y_ptr) {
      dir |= 0;
      nrows |= 0;
      ncols |= 0;
      x_ptr |= 0;
      y_ptr |= 0;
      var nn, m, i, i1, j, k, i2, l, l1, l2;
      var c1, c2, t, t1, t2, u1, u2, z, row, a, b, c, d, k1, k2, k3;
      nn = ncols;
      m = bits.log2(nn);
      for (row = 0; row < nrows; ++row) {
        i2 = nn >> 1;
        j = 0;
        for (i = 0; i < nn - 1; i++) {
          if (i < j) {
            t = buffer2[x_ptr + i];
            buffer2[x_ptr + i] = buffer2[x_ptr + j];
            buffer2[x_ptr + j] = t;
            t = buffer2[y_ptr + i];
            buffer2[y_ptr + i] = buffer2[y_ptr + j];
            buffer2[y_ptr + j] = t;
          }
          k = i2;
          while (k <= j) {
            j -= k;
            k >>= 1;
          }
          j += k;
        }
        c1 = -1;
        c2 = 0;
        l2 = 1;
        for (l = 0; l < m; l++) {
          l1 = l2;
          l2 <<= 1;
          u1 = 1;
          u2 = 0;
          for (j = 0; j < l1; j++) {
            for (i = j; i < nn; i += l2) {
              i1 = i + l1;
              a = buffer2[x_ptr + i1];
              b = buffer2[y_ptr + i1];
              c = buffer2[x_ptr + i];
              d = buffer2[y_ptr + i];
              k1 = u1 * (a + b);
              k2 = a * (u2 - u1);
              k3 = b * (u1 + u2);
              t1 = k1 - k3;
              t2 = k1 + k2;
              buffer2[x_ptr + i1] = c - t1;
              buffer2[y_ptr + i1] = d - t2;
              buffer2[x_ptr + i] += t1;
              buffer2[y_ptr + i] += t2;
            }
            k1 = c1 * (u1 + u2);
            k2 = u1 * (c2 - c1);
            k3 = u2 * (c1 + c2);
            u1 = k1 - k3;
            u2 = k1 + k2;
          }
          c2 = Math.sqrt((1 - c1) / 2);
          if (dir < 0) {
            c2 = -c2;
          }
          c1 = Math.sqrt((1 + c1) / 2);
        }
        if (dir < 0) {
          var scale_f = 1 / nn;
          for (i = 0; i < nn; i++) {
            buffer2[x_ptr + i] *= scale_f;
            buffer2[y_ptr + i] *= scale_f;
          }
        }
        x_ptr += ncols;
        y_ptr += ncols;
      }
    }
    function fftBluestein(dir, nrows, ncols, buffer2, x_ptr, y_ptr, scratch_ptr) {
      dir |= 0;
      nrows |= 0;
      ncols |= 0;
      x_ptr |= 0;
      y_ptr |= 0;
      scratch_ptr |= 0;
      var m = bits.nextPow2(2 * ncols + 1), cos_ptr = scratch_ptr, sin_ptr = cos_ptr + ncols, xs_ptr = sin_ptr + ncols, ys_ptr = xs_ptr + m, cft_ptr = ys_ptr + m, sft_ptr = cft_ptr + m, w = -dir * Math.PI / ncols, row, a, b, c, d, k1, k2, k3, i;
      for (i = 0; i < ncols; ++i) {
        a = w * (i * i % (ncols * 2));
        c = Math.cos(a);
        d = Math.sin(a);
        buffer2[cft_ptr + (m - i)] = buffer2[cft_ptr + i] = buffer2[cos_ptr + i] = c;
        buffer2[sft_ptr + (m - i)] = buffer2[sft_ptr + i] = buffer2[sin_ptr + i] = d;
      }
      for (i = ncols; i <= m - ncols; ++i) {
        buffer2[cft_ptr + i] = 0;
      }
      for (i = ncols; i <= m - ncols; ++i) {
        buffer2[sft_ptr + i] = 0;
      }
      fftRadix2(1, 1, m, buffer2, cft_ptr, sft_ptr);
      if (dir < 0) {
        w = 1 / ncols;
      } else {
        w = 1;
      }
      for (row = 0; row < nrows; ++row) {
        for (i = 0; i < ncols; ++i) {
          a = buffer2[x_ptr + i];
          b = buffer2[y_ptr + i];
          c = buffer2[cos_ptr + i];
          d = -buffer2[sin_ptr + i];
          k1 = c * (a + b);
          k2 = a * (d - c);
          k3 = b * (c + d);
          buffer2[xs_ptr + i] = k1 - k3;
          buffer2[ys_ptr + i] = k1 + k2;
        }
        for (i = ncols; i < m; ++i) {
          buffer2[xs_ptr + i] = 0;
        }
        for (i = ncols; i < m; ++i) {
          buffer2[ys_ptr + i] = 0;
        }
        fftRadix2(1, 1, m, buffer2, xs_ptr, ys_ptr);
        for (i = 0; i < m; ++i) {
          a = buffer2[xs_ptr + i];
          b = buffer2[ys_ptr + i];
          c = buffer2[cft_ptr + i];
          d = buffer2[sft_ptr + i];
          k1 = c * (a + b);
          k2 = a * (d - c);
          k3 = b * (c + d);
          buffer2[xs_ptr + i] = k1 - k3;
          buffer2[ys_ptr + i] = k1 + k2;
        }
        fftRadix2(-1, 1, m, buffer2, xs_ptr, ys_ptr);
        for (i = 0; i < ncols; ++i) {
          a = buffer2[xs_ptr + i];
          b = buffer2[ys_ptr + i];
          c = buffer2[cos_ptr + i];
          d = -buffer2[sin_ptr + i];
          k1 = c * (a + b);
          k2 = a * (d - c);
          k3 = b * (c + d);
          buffer2[x_ptr + i] = w * (k1 - k3);
          buffer2[y_ptr + i] = w * (k1 + k2);
        }
        x_ptr += ncols;
        y_ptr += ncols;
      }
    }
  }
});

// node_modules/ndarray-fft/fft.js
var require_fft2 = __commonJS({
  "node_modules/ndarray-fft/fft.js"(exports2, module2) {
    "use strict";
    var ops = require_ndarray_ops();
    var ndarray2 = require_ndarray();
    var pool2 = require_pool2();
    var fftm = require_fft_matrix();
    function ndfft(dir, x, y) {
      var shape = x.shape, d = shape.length, size = 1, stride = new Array(d), pad2 = 0, i, j;
      for (i = d - 1; i >= 0; --i) {
        stride[i] = size;
        size *= shape[i];
        pad2 = Math.max(pad2, fftm.scratchMemory(shape[i]));
        if (x.shape[i] !== y.shape[i]) {
          throw new Error("Shape mismatch, real and imaginary arrays must have same size");
        }
      }
      var buf_size = 4 * size + pad2;
      var buffer2;
      if (x.dtype === "array" || x.dtype === "float64" || x.dtype === "custom") {
        buffer2 = pool2.mallocDouble(buf_size);
      } else {
        buffer2 = pool2.mallocFloat(buf_size);
      }
      var x1 = ndarray2(buffer2, shape.slice(0), stride, 0), y1 = ndarray2(buffer2, shape.slice(0), stride.slice(0), size), x2 = ndarray2(buffer2, shape.slice(0), stride.slice(0), 2 * size), y2 = ndarray2(buffer2, shape.slice(0), stride.slice(0), 3 * size), tmp, n, s1, s2, scratch_ptr = 4 * size;
      ops.assign(x1, x);
      ops.assign(y1, y);
      for (i = d - 1; i >= 0; --i) {
        fftm(dir, size / shape[i], shape[i], buffer2, x1.offset, y1.offset, scratch_ptr);
        if (i === 0) {
          break;
        }
        n = 1;
        s1 = x2.stride;
        s2 = y2.stride;
        for (j = i - 1; j < d; ++j) {
          s2[j] = s1[j] = n;
          n *= shape[j];
        }
        for (j = i - 2; j >= 0; --j) {
          s2[j] = s1[j] = n;
          n *= shape[j];
        }
        ops.assign(x2, x1);
        ops.assign(y2, y1);
        tmp = x1;
        x1 = x2;
        x2 = tmp;
        tmp = y1;
        y1 = y2;
        y2 = tmp;
      }
      ops.assign(x, x1);
      ops.assign(y, y1);
      pool2.free(buffer2);
    }
    module2.exports = ndfft;
  }
});

// node_modules/ndarray-scratch/scratch.js
var require_scratch = __commonJS({
  "node_modules/ndarray-scratch/scratch.js"(exports2) {
    "use strict";
    var ndarray2 = require_ndarray();
    var ops = require_ndarray_ops();
    var pool2 = require_pool2();
    function clone2(array) {
      var dtype = array.dtype;
      if (dtype === "generic" || dtype === "array") {
        dtype = "double";
      }
      var data = pool2.malloc(array.size, dtype);
      var result = ndarray2(data, array.shape);
      ops.assign(result, array);
      return result;
    }
    exports2.clone = clone2;
    function malloc(shape, dtype) {
      if (!dtype) {
        dtype = "double";
      }
      var sz = 1;
      var stride = new Array(shape.length);
      for (var i = shape.length - 1; i >= 0; --i) {
        stride[i] = sz;
        sz *= shape[i];
      }
      return ndarray2(pool2.malloc(sz, dtype), shape, stride, 0);
    }
    exports2.malloc = malloc;
    function free(array) {
      if (array.dtype === "generic" || array.dtype === "array") {
        return;
      }
      pool2.free(array.data);
    }
    exports2.free = free;
    function zeros2(shape, dtype) {
      if (!dtype) {
        dtype = "double";
      }
      var sz = 1;
      var stride = new Array(shape.length);
      for (var i = shape.length - 1; i >= 0; --i) {
        stride[i] = sz;
        sz *= shape[i];
      }
      var buf = pool2.malloc(sz, dtype);
      for (var i = 0; i < sz; ++i) {
        buf[i] = 0;
      }
      return ndarray2(buf, shape, stride, 0);
    }
    exports2.zeros = zeros2;
    function ones2(shape, dtype) {
      if (!dtype) {
        dtype = "double";
      }
      var sz = 1;
      var stride = new Array(shape.length);
      for (var i = shape.length - 1; i >= 0; --i) {
        stride[i] = sz;
        sz *= shape[i];
      }
      var buf = pool2.malloc(sz, dtype);
      for (var i = 0; i < sz; ++i) {
        buf[i] = 1;
      }
      return ndarray2(buf, shape, stride, 0);
    }
    exports2.ones = ones2;
    function eye(shape, dtype) {
      var i, offset;
      if (!dtype) {
        dtype = "double";
      }
      var sz = 1;
      var stride = new Array(shape.length);
      for (i = shape.length - 1; i >= 0; --i) {
        stride[i] = sz;
        sz *= shape[i];
      }
      var buf = pool2.malloc(sz, dtype);
      for (i = 0; i < sz; ++i) {
        buf[i] = 0;
      }
      var mindim = Infinity;
      var offsum = 0;
      for (i = shape.length - 1; i >= 0; i--) {
        offsum += stride[i];
        mindim = Math.min(mindim, shape[i]);
      }
      for (i = 0, offset = 0; i < mindim; i++, offset += offsum) {
        buf[offset] = 1;
      }
      return ndarray2(buf, shape, stride, 0);
    }
    exports2.eye = eye;
  }
});

// node_modules/esprima/esprima.js
var require_esprima = __commonJS({
  "node_modules/esprima/esprima.js"(exports2) {
    (function(root, factory) {
      "use strict";
      if (typeof define === "function" && define.amd) {
        define(["exports"], factory);
      } else if (typeof exports2 !== "undefined") {
        factory(exports2);
      } else {
        factory(root.esprima = {});
      }
    })(exports2, function(exports3) {
      "use strict";
      var Token, TokenName, FnExprTokens, Syntax, PropertyKind, Messages, Regex, SyntaxTreeDelegate, source, strict, index, lineNumber, lineStart, length, delegate, lookahead, state, extra;
      Token = {
        BooleanLiteral: 1,
        EOF: 2,
        Identifier: 3,
        Keyword: 4,
        NullLiteral: 5,
        NumericLiteral: 6,
        Punctuator: 7,
        StringLiteral: 8,
        RegularExpression: 9
      };
      TokenName = {};
      TokenName[Token.BooleanLiteral] = "Boolean";
      TokenName[Token.EOF] = "<end>";
      TokenName[Token.Identifier] = "Identifier";
      TokenName[Token.Keyword] = "Keyword";
      TokenName[Token.NullLiteral] = "Null";
      TokenName[Token.NumericLiteral] = "Numeric";
      TokenName[Token.Punctuator] = "Punctuator";
      TokenName[Token.StringLiteral] = "String";
      TokenName[Token.RegularExpression] = "RegularExpression";
      FnExprTokens = [
        "(",
        "{",
        "[",
        "in",
        "typeof",
        "instanceof",
        "new",
        "return",
        "case",
        "delete",
        "throw",
        "void",
        // assignment operators
        "=",
        "+=",
        "-=",
        "*=",
        "/=",
        "%=",
        "<<=",
        ">>=",
        ">>>=",
        "&=",
        "|=",
        "^=",
        ",",
        // binary/unary operators
        "+",
        "-",
        "*",
        "/",
        "%",
        "++",
        "--",
        "<<",
        ">>",
        ">>>",
        "&",
        "|",
        "^",
        "!",
        "~",
        "&&",
        "||",
        "?",
        ":",
        "===",
        "==",
        ">=",
        "<=",
        "<",
        ">",
        "!=",
        "!=="
      ];
      Syntax = {
        AssignmentExpression: "AssignmentExpression",
        ArrayExpression: "ArrayExpression",
        BlockStatement: "BlockStatement",
        BinaryExpression: "BinaryExpression",
        BreakStatement: "BreakStatement",
        CallExpression: "CallExpression",
        CatchClause: "CatchClause",
        ConditionalExpression: "ConditionalExpression",
        ContinueStatement: "ContinueStatement",
        DoWhileStatement: "DoWhileStatement",
        DebuggerStatement: "DebuggerStatement",
        EmptyStatement: "EmptyStatement",
        ExpressionStatement: "ExpressionStatement",
        ForStatement: "ForStatement",
        ForInStatement: "ForInStatement",
        FunctionDeclaration: "FunctionDeclaration",
        FunctionExpression: "FunctionExpression",
        Identifier: "Identifier",
        IfStatement: "IfStatement",
        Literal: "Literal",
        LabeledStatement: "LabeledStatement",
        LogicalExpression: "LogicalExpression",
        MemberExpression: "MemberExpression",
        NewExpression: "NewExpression",
        ObjectExpression: "ObjectExpression",
        Program: "Program",
        Property: "Property",
        ReturnStatement: "ReturnStatement",
        SequenceExpression: "SequenceExpression",
        SwitchStatement: "SwitchStatement",
        SwitchCase: "SwitchCase",
        ThisExpression: "ThisExpression",
        ThrowStatement: "ThrowStatement",
        TryStatement: "TryStatement",
        UnaryExpression: "UnaryExpression",
        UpdateExpression: "UpdateExpression",
        VariableDeclaration: "VariableDeclaration",
        VariableDeclarator: "VariableDeclarator",
        WhileStatement: "WhileStatement",
        WithStatement: "WithStatement"
      };
      PropertyKind = {
        Data: 1,
        Get: 2,
        Set: 4
      };
      Messages = {
        UnexpectedToken: "Unexpected token %0",
        UnexpectedNumber: "Unexpected number",
        UnexpectedString: "Unexpected string",
        UnexpectedIdentifier: "Unexpected identifier",
        UnexpectedReserved: "Unexpected reserved word",
        UnexpectedEOS: "Unexpected end of input",
        NewlineAfterThrow: "Illegal newline after throw",
        InvalidRegExp: "Invalid regular expression",
        UnterminatedRegExp: "Invalid regular expression: missing /",
        InvalidLHSInAssignment: "Invalid left-hand side in assignment",
        InvalidLHSInForIn: "Invalid left-hand side in for-in",
        MultipleDefaultsInSwitch: "More than one default clause in switch statement",
        NoCatchOrFinally: "Missing catch or finally after try",
        UnknownLabel: "Undefined label '%0'",
        Redeclaration: "%0 '%1' has already been declared",
        IllegalContinue: "Illegal continue statement",
        IllegalBreak: "Illegal break statement",
        IllegalReturn: "Illegal return statement",
        StrictModeWith: "Strict mode code may not include a with statement",
        StrictCatchVariable: "Catch variable may not be eval or arguments in strict mode",
        StrictVarName: "Variable name may not be eval or arguments in strict mode",
        StrictParamName: "Parameter name eval or arguments is not allowed in strict mode",
        StrictParamDupe: "Strict mode function may not have duplicate parameter names",
        StrictFunctionName: "Function name may not be eval or arguments in strict mode",
        StrictOctalLiteral: "Octal literals are not allowed in strict mode.",
        StrictDelete: "Delete of an unqualified identifier in strict mode.",
        StrictDuplicateProperty: "Duplicate data property in object literal not allowed in strict mode",
        AccessorDataProperty: "Object literal may not have data and accessor property with the same name",
        AccessorGetSet: "Object literal may not have multiple get/set accessors with the same name",
        StrictLHSAssignment: "Assignment to eval or arguments is not allowed in strict mode",
        StrictLHSPostfix: "Postfix increment/decrement may not have eval or arguments operand in strict mode",
        StrictLHSPrefix: "Prefix increment/decrement may not have eval or arguments operand in strict mode",
        StrictReservedWord: "Use of future reserved word in strict mode"
      };
      Regex = {
        NonAsciiIdentifierStart: new RegExp("[------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------]"),
        NonAsciiIdentifierPart: new RegExp("[------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------]")
      };
      function assert2(condition, message) {
        if (!condition) {
          throw new Error("ASSERT: " + message);
        }
      }
      function isDecimalDigit(ch) {
        return ch >= 48 && ch <= 57;
      }
      function isHexDigit(ch) {
        return "0123456789abcdefABCDEF".indexOf(ch) >= 0;
      }
      function isOctalDigit(ch) {
        return "01234567".indexOf(ch) >= 0;
      }
      function isWhiteSpace(ch) {
        return ch === 32 || ch === 9 || ch === 11 || ch === 12 || ch === 160 || ch >= 5760 && [5760, 6158, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(ch) >= 0;
      }
      function isLineTerminator(ch) {
        return ch === 10 || ch === 13 || ch === 8232 || ch === 8233;
      }
      function isIdentifierStart(ch) {
        return ch === 36 || ch === 95 || // $ (dollar) and _ (underscore)
        ch >= 65 && ch <= 90 || // A..Z
        ch >= 97 && ch <= 122 || // a..z
        ch === 92 || // \ (backslash)
        ch >= 128 && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch));
      }
      function isIdentifierPart(ch) {
        return ch === 36 || ch === 95 || // $ (dollar) and _ (underscore)
        ch >= 65 && ch <= 90 || // A..Z
        ch >= 97 && ch <= 122 || // a..z
        ch >= 48 && ch <= 57 || // 0..9
        ch === 92 || // \ (backslash)
        ch >= 128 && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch));
      }
      function isFutureReservedWord(id) {
        switch (id) {
          case "class":
          case "enum":
          case "export":
          case "extends":
          case "import":
          case "super":
            return true;
          default:
            return false;
        }
      }
      function isStrictModeReservedWord(id) {
        switch (id) {
          case "implements":
          case "interface":
          case "package":
          case "private":
          case "protected":
          case "public":
          case "static":
          case "yield":
          case "let":
            return true;
          default:
            return false;
        }
      }
      function isRestrictedWord(id) {
        return id === "eval" || id === "arguments";
      }
      function isKeyword(id) {
        if (strict && isStrictModeReservedWord(id)) {
          return true;
        }
        switch (id.length) {
          case 2:
            return id === "if" || id === "in" || id === "do";
          case 3:
            return id === "var" || id === "for" || id === "new" || id === "try" || id === "let";
          case 4:
            return id === "this" || id === "else" || id === "case" || id === "void" || id === "with" || id === "enum";
          case 5:
            return id === "while" || id === "break" || id === "catch" || id === "throw" || id === "const" || id === "yield" || id === "class" || id === "super";
          case 6:
            return id === "return" || id === "typeof" || id === "delete" || id === "switch" || id === "export" || id === "import";
          case 7:
            return id === "default" || id === "finally" || id === "extends";
          case 8:
            return id === "function" || id === "continue" || id === "debugger";
          case 10:
            return id === "instanceof";
          default:
            return false;
        }
      }
      function addComment(type, value, start2, end, loc) {
        var comment, attacher;
        assert2(typeof start2 === "number", "Comment must have valid position");
        if (state.lastCommentStart >= start2) {
          return;
        }
        state.lastCommentStart = start2;
        comment = {
          type,
          value
        };
        if (extra.range) {
          comment.range = [start2, end];
        }
        if (extra.loc) {
          comment.loc = loc;
        }
        extra.comments.push(comment);
        if (extra.attachComment) {
          extra.leadingComments.push(comment);
          extra.trailingComments.push(comment);
        }
      }
      function skipSingleLineComment(offset) {
        var start2, loc, ch, comment;
        start2 = index - offset;
        loc = {
          start: {
            line: lineNumber,
            column: index - lineStart - offset
          }
        };
        while (index < length) {
          ch = source.charCodeAt(index);
          ++index;
          if (isLineTerminator(ch)) {
            if (extra.comments) {
              comment = source.slice(start2 + offset, index - 1);
              loc.end = {
                line: lineNumber,
                column: index - lineStart - 1
              };
              addComment("Line", comment, start2, index - 1, loc);
            }
            if (ch === 13 && source.charCodeAt(index) === 10) {
              ++index;
            }
            ++lineNumber;
            lineStart = index;
            return;
          }
        }
        if (extra.comments) {
          comment = source.slice(start2 + offset, index);
          loc.end = {
            line: lineNumber,
            column: index - lineStart
          };
          addComment("Line", comment, start2, index, loc);
        }
      }
      function skipMultiLineComment() {
        var start2, loc, ch, comment;
        if (extra.comments) {
          start2 = index - 2;
          loc = {
            start: {
              line: lineNumber,
              column: index - lineStart - 2
            }
          };
        }
        while (index < length) {
          ch = source.charCodeAt(index);
          if (isLineTerminator(ch)) {
            if (ch === 13 && source.charCodeAt(index + 1) === 10) {
              ++index;
            }
            ++lineNumber;
            ++index;
            lineStart = index;
            if (index >= length) {
              throwError({}, Messages.UnexpectedToken, "ILLEGAL");
            }
          } else if (ch === 42) {
            if (source.charCodeAt(index + 1) === 47) {
              ++index;
              ++index;
              if (extra.comments) {
                comment = source.slice(start2 + 2, index - 2);
                loc.end = {
                  line: lineNumber,
                  column: index - lineStart
                };
                addComment("Block", comment, start2, index, loc);
              }
              return;
            }
            ++index;
          } else {
            ++index;
          }
        }
        throwError({}, Messages.UnexpectedToken, "ILLEGAL");
      }
      function skipComment() {
        var ch, start2;
        start2 = index === 0;
        while (index < length) {
          ch = source.charCodeAt(index);
          if (isWhiteSpace(ch)) {
            ++index;
          } else if (isLineTerminator(ch)) {
            ++index;
            if (ch === 13 && source.charCodeAt(index) === 10) {
              ++index;
            }
            ++lineNumber;
            lineStart = index;
            start2 = true;
          } else if (ch === 47) {
            ch = source.charCodeAt(index + 1);
            if (ch === 47) {
              ++index;
              ++index;
              skipSingleLineComment(2);
              start2 = true;
            } else if (ch === 42) {
              ++index;
              ++index;
              skipMultiLineComment();
            } else {
              break;
            }
          } else if (start2 && ch === 45) {
            if (source.charCodeAt(index + 1) === 45 && source.charCodeAt(index + 2) === 62) {
              index += 3;
              skipSingleLineComment(3);
            } else {
              break;
            }
          } else if (ch === 60) {
            if (source.slice(index + 1, index + 4) === "!--") {
              ++index;
              ++index;
              ++index;
              ++index;
              skipSingleLineComment(4);
            } else {
              break;
            }
          } else {
            break;
          }
        }
      }
      function scanHexEscape(prefix) {
        var i, len, ch, code = 0;
        len = prefix === "u" ? 4 : 2;
        for (i = 0; i < len; ++i) {
          if (index < length && isHexDigit(source[index])) {
            ch = source[index++];
            code = code * 16 + "0123456789abcdef".indexOf(ch.toLowerCase());
          } else {
            return "";
          }
        }
        return String.fromCharCode(code);
      }
      function getEscapedIdentifier() {
        var ch, id;
        ch = source.charCodeAt(index++);
        id = String.fromCharCode(ch);
        if (ch === 92) {
          if (source.charCodeAt(index) !== 117) {
            throwError({}, Messages.UnexpectedToken, "ILLEGAL");
          }
          ++index;
          ch = scanHexEscape("u");
          if (!ch || ch === "\\" || !isIdentifierStart(ch.charCodeAt(0))) {
            throwError({}, Messages.UnexpectedToken, "ILLEGAL");
          }
          id = ch;
        }
        while (index < length) {
          ch = source.charCodeAt(index);
          if (!isIdentifierPart(ch)) {
            break;
          }
          ++index;
          id += String.fromCharCode(ch);
          if (ch === 92) {
            id = id.substr(0, id.length - 1);
            if (source.charCodeAt(index) !== 117) {
              throwError({}, Messages.UnexpectedToken, "ILLEGAL");
            }
            ++index;
            ch = scanHexEscape("u");
            if (!ch || ch === "\\" || !isIdentifierPart(ch.charCodeAt(0))) {
              throwError({}, Messages.UnexpectedToken, "ILLEGAL");
            }
            id += ch;
          }
        }
        return id;
      }
      function getIdentifier() {
        var start2, ch;
        start2 = index++;
        while (index < length) {
          ch = source.charCodeAt(index);
          if (ch === 92) {
            index = start2;
            return getEscapedIdentifier();
          }
          if (isIdentifierPart(ch)) {
            ++index;
          } else {
            break;
          }
        }
        return source.slice(start2, index);
      }
      function scanIdentifier() {
        var start2, id, type;
        start2 = index;
        id = source.charCodeAt(index) === 92 ? getEscapedIdentifier() : getIdentifier();
        if (id.length === 1) {
          type = Token.Identifier;
        } else if (isKeyword(id)) {
          type = Token.Keyword;
        } else if (id === "null") {
          type = Token.NullLiteral;
        } else if (id === "true" || id === "false") {
          type = Token.BooleanLiteral;
        } else {
          type = Token.Identifier;
        }
        return {
          type,
          value: id,
          lineNumber,
          lineStart,
          start: start2,
          end: index
        };
      }
      function scanPunctuator() {
        var start2 = index, code = source.charCodeAt(index), code2, ch1 = source[index], ch2, ch3, ch4;
        switch (code) {
          // Check for most common single-character punctuators.
          case 46:
          // . dot
          case 40:
          // ( open bracket
          case 41:
          // ) close bracket
          case 59:
          // ; semicolon
          case 44:
          // , comma
          case 123:
          // { open curly brace
          case 125:
          // } close curly brace
          case 91:
          // [
          case 93:
          // ]
          case 58:
          // :
          case 63:
          // ?
          case 126:
            ++index;
            if (extra.tokenize) {
              if (code === 40) {
                extra.openParenToken = extra.tokens.length;
              } else if (code === 123) {
                extra.openCurlyToken = extra.tokens.length;
              }
            }
            return {
              type: Token.Punctuator,
              value: String.fromCharCode(code),
              lineNumber,
              lineStart,
              start: start2,
              end: index
            };
          default:
            code2 = source.charCodeAt(index + 1);
            if (code2 === 61) {
              switch (code) {
                case 43:
                // +
                case 45:
                // -
                case 47:
                // /
                case 60:
                // <
                case 62:
                // >
                case 94:
                // ^
                case 124:
                // |
                case 37:
                // %
                case 38:
                // &
                case 42:
                  index += 2;
                  return {
                    type: Token.Punctuator,
                    value: String.fromCharCode(code) + String.fromCharCode(code2),
                    lineNumber,
                    lineStart,
                    start: start2,
                    end: index
                  };
                case 33:
                // !
                case 61:
                  index += 2;
                  if (source.charCodeAt(index) === 61) {
                    ++index;
                  }
                  return {
                    type: Token.Punctuator,
                    value: source.slice(start2, index),
                    lineNumber,
                    lineStart,
                    start: start2,
                    end: index
                  };
              }
            }
        }
        ch4 = source.substr(index, 4);
        if (ch4 === ">>>=") {
          index += 4;
          return {
            type: Token.Punctuator,
            value: ch4,
            lineNumber,
            lineStart,
            start: start2,
            end: index
          };
        }
        ch3 = ch4.substr(0, 3);
        if (ch3 === ">>>" || ch3 === "<<=" || ch3 === ">>=") {
          index += 3;
          return {
            type: Token.Punctuator,
            value: ch3,
            lineNumber,
            lineStart,
            start: start2,
            end: index
          };
        }
        ch2 = ch3.substr(0, 2);
        if (ch1 === ch2[1] && "+-<>&|".indexOf(ch1) >= 0 || ch2 === "=>") {
          index += 2;
          return {
            type: Token.Punctuator,
            value: ch2,
            lineNumber,
            lineStart,
            start: start2,
            end: index
          };
        }
        if ("<>=!+-*%&|^/".indexOf(ch1) >= 0) {
          ++index;
          return {
            type: Token.Punctuator,
            value: ch1,
            lineNumber,
            lineStart,
            start: start2,
            end: index
          };
        }
        throwError({}, Messages.UnexpectedToken, "ILLEGAL");
      }
      function scanHexLiteral(start2) {
        var number = "";
        while (index < length) {
          if (!isHexDigit(source[index])) {
            break;
          }
          number += source[index++];
        }
        if (number.length === 0) {
          throwError({}, Messages.UnexpectedToken, "ILLEGAL");
        }
        if (isIdentifierStart(source.charCodeAt(index))) {
          throwError({}, Messages.UnexpectedToken, "ILLEGAL");
        }
        return {
          type: Token.NumericLiteral,
          value: parseInt("0x" + number, 16),
          lineNumber,
          lineStart,
          start: start2,
          end: index
        };
      }
      function scanOctalLiteral(start2) {
        var number = "0" + source[index++];
        while (index < length) {
          if (!isOctalDigit(source[index])) {
            break;
          }
          number += source[index++];
        }
        if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {
          throwError({}, Messages.UnexpectedToken, "ILLEGAL");
        }
        return {
          type: Token.NumericLiteral,
          value: parseInt(number, 8),
          octal: true,
          lineNumber,
          lineStart,
          start: start2,
          end: index
        };
      }
      function isImplicitOctalLiteral() {
        var i, ch;
        for (i = index + 1; i < length; ++i) {
          ch = source[i];
          if (ch === "8" || ch === "9") {
            return false;
          }
          if (!isOctalDigit(ch)) {
            return true;
          }
        }
        return true;
      }
      function scanNumericLiteral() {
        var number, start2, ch;
        ch = source[index];
        assert2(
          isDecimalDigit(ch.charCodeAt(0)) || ch === ".",
          "Numeric literal must start with a decimal digit or a decimal point"
        );
        start2 = index;
        number = "";
        if (ch !== ".") {
          number = source[index++];
          ch = source[index];
          if (number === "0") {
            if (ch === "x" || ch === "X") {
              ++index;
              return scanHexLiteral(start2);
            }
            if (isOctalDigit(ch)) {
              if (isImplicitOctalLiteral()) {
                return scanOctalLiteral(start2);
              }
            }
          }
          while (isDecimalDigit(source.charCodeAt(index))) {
            number += source[index++];
          }
          ch = source[index];
        }
        if (ch === ".") {
          number += source[index++];
          while (isDecimalDigit(source.charCodeAt(index))) {
            number += source[index++];
          }
          ch = source[index];
        }
        if (ch === "e" || ch === "E") {
          number += source[index++];
          ch = source[index];
          if (ch === "+" || ch === "-") {
            number += source[index++];
          }
          if (isDecimalDigit(source.charCodeAt(index))) {
            while (isDecimalDigit(source.charCodeAt(index))) {
              number += source[index++];
            }
          } else {
            throwError({}, Messages.UnexpectedToken, "ILLEGAL");
          }
        }
        if (isIdentifierStart(source.charCodeAt(index))) {
          throwError({}, Messages.UnexpectedToken, "ILLEGAL");
        }
        return {
          type: Token.NumericLiteral,
          value: parseFloat(number),
          lineNumber,
          lineStart,
          start: start2,
          end: index
        };
      }
      function scanStringLiteral() {
        var str = "", quote, start2, ch, code, unescaped, restore, octal = false, startLineNumber, startLineStart;
        startLineNumber = lineNumber;
        startLineStart = lineStart;
        quote = source[index];
        assert2(
          quote === "'" || quote === '"',
          "String literal must starts with a quote"
        );
        start2 = index;
        ++index;
        while (index < length) {
          ch = source[index++];
          if (ch === quote) {
            quote = "";
            break;
          } else if (ch === "\\") {
            ch = source[index++];
            if (!ch || !isLineTerminator(ch.charCodeAt(0))) {
              switch (ch) {
                case "u":
                case "x":
                  restore = index;
                  unescaped = scanHexEscape(ch);
                  if (unescaped) {
                    str += unescaped;
                  } else {
                    index = restore;
                    str += ch;
                  }
                  break;
                case "n":
                  str += "\n";
                  break;
                case "r":
                  str += "\r";
                  break;
                case "t":
                  str += "	";
                  break;
                case "b":
                  str += "\b";
                  break;
                case "f":
                  str += "\f";
                  break;
                case "v":
                  str += "\v";
                  break;
                default:
                  if (isOctalDigit(ch)) {
                    code = "01234567".indexOf(ch);
                    if (code !== 0) {
                      octal = true;
                    }
                    if (index < length && isOctalDigit(source[index])) {
                      octal = true;
                      code = code * 8 + "01234567".indexOf(source[index++]);
                      if ("0123".indexOf(ch) >= 0 && index < length && isOctalDigit(source[index])) {
                        code = code * 8 + "01234567".indexOf(source[index++]);
                      }
                    }
                    str += String.fromCharCode(code);
                  } else {
                    str += ch;
                  }
                  break;
              }
            } else {
              ++lineNumber;
              if (ch === "\r" && source[index] === "\n") {
                ++index;
              }
              lineStart = index;
            }
          } else if (isLineTerminator(ch.charCodeAt(0))) {
            break;
          } else {
            str += ch;
          }
        }
        if (quote !== "") {
          throwError({}, Messages.UnexpectedToken, "ILLEGAL");
        }
        return {
          type: Token.StringLiteral,
          value: str,
          octal,
          startLineNumber,
          startLineStart,
          lineNumber,
          lineStart,
          start: start2,
          end: index
        };
      }
      function testRegExp(pattern, flags) {
        var value;
        try {
          value = new RegExp(pattern, flags);
        } catch (e) {
          throwError({}, Messages.InvalidRegExp);
        }
        return value;
      }
      function scanRegExpBody() {
        var ch, str, classMarker, terminated, body;
        ch = source[index];
        assert2(ch === "/", "Regular expression literal must start with a slash");
        str = source[index++];
        classMarker = false;
        terminated = false;
        while (index < length) {
          ch = source[index++];
          str += ch;
          if (ch === "\\") {
            ch = source[index++];
            if (isLineTerminator(ch.charCodeAt(0))) {
              throwError({}, Messages.UnterminatedRegExp);
            }
            str += ch;
          } else if (isLineTerminator(ch.charCodeAt(0))) {
            throwError({}, Messages.UnterminatedRegExp);
          } else if (classMarker) {
            if (ch === "]") {
              classMarker = false;
            }
          } else {
            if (ch === "/") {
              terminated = true;
              break;
            } else if (ch === "[") {
              classMarker = true;
            }
          }
        }
        if (!terminated) {
          throwError({}, Messages.UnterminatedRegExp);
        }
        body = str.substr(1, str.length - 2);
        return {
          value: body,
          literal: str
        };
      }
      function scanRegExpFlags() {
        var ch, str, flags, restore;
        str = "";
        flags = "";
        while (index < length) {
          ch = source[index];
          if (!isIdentifierPart(ch.charCodeAt(0))) {
            break;
          }
          ++index;
          if (ch === "\\" && index < length) {
            ch = source[index];
            if (ch === "u") {
              ++index;
              restore = index;
              ch = scanHexEscape("u");
              if (ch) {
                flags += ch;
                for (str += "\\u"; restore < index; ++restore) {
                  str += source[restore];
                }
              } else {
                index = restore;
                flags += "u";
                str += "\\u";
              }
              throwErrorTolerant({}, Messages.UnexpectedToken, "ILLEGAL");
            } else {
              str += "\\";
              throwErrorTolerant({}, Messages.UnexpectedToken, "ILLEGAL");
            }
          } else {
            flags += ch;
            str += ch;
          }
        }
        return {
          value: flags,
          literal: str
        };
      }
      function scanRegExp() {
        var start2, body, flags, pattern, value;
        lookahead = null;
        skipComment();
        start2 = index;
        body = scanRegExpBody();
        flags = scanRegExpFlags();
        value = testRegExp(body.value, flags.value);
        if (extra.tokenize) {
          return {
            type: Token.RegularExpression,
            value,
            lineNumber,
            lineStart,
            start: start2,
            end: index
          };
        }
        return {
          literal: body.literal + flags.literal,
          value,
          start: start2,
          end: index
        };
      }
      function collectRegex() {
        var pos, loc, regex, token;
        skipComment();
        pos = index;
        loc = {
          start: {
            line: lineNumber,
            column: index - lineStart
          }
        };
        regex = scanRegExp();
        loc.end = {
          line: lineNumber,
          column: index - lineStart
        };
        if (!extra.tokenize) {
          if (extra.tokens.length > 0) {
            token = extra.tokens[extra.tokens.length - 1];
            if (token.range[0] === pos && token.type === "Punctuator") {
              if (token.value === "/" || token.value === "/=") {
                extra.tokens.pop();
              }
            }
          }
          extra.tokens.push({
            type: "RegularExpression",
            value: regex.literal,
            range: [pos, index],
            loc
          });
        }
        return regex;
      }
      function isIdentifierName(token) {
        return token.type === Token.Identifier || token.type === Token.Keyword || token.type === Token.BooleanLiteral || token.type === Token.NullLiteral;
      }
      function advanceSlash() {
        var prevToken, checkToken;
        prevToken = extra.tokens[extra.tokens.length - 1];
        if (!prevToken) {
          return collectRegex();
        }
        if (prevToken.type === "Punctuator") {
          if (prevToken.value === "]") {
            return scanPunctuator();
          }
          if (prevToken.value === ")") {
            checkToken = extra.tokens[extra.openParenToken - 1];
            if (checkToken && checkToken.type === "Keyword" && (checkToken.value === "if" || checkToken.value === "while" || checkToken.value === "for" || checkToken.value === "with")) {
              return collectRegex();
            }
            return scanPunctuator();
          }
          if (prevToken.value === "}") {
            if (extra.tokens[extra.openCurlyToken - 3] && extra.tokens[extra.openCurlyToken - 3].type === "Keyword") {
              checkToken = extra.tokens[extra.openCurlyToken - 4];
              if (!checkToken) {
                return scanPunctuator();
              }
            } else if (extra.tokens[extra.openCurlyToken - 4] && extra.tokens[extra.openCurlyToken - 4].type === "Keyword") {
              checkToken = extra.tokens[extra.openCurlyToken - 5];
              if (!checkToken) {
                return collectRegex();
              }
            } else {
              return scanPunctuator();
            }
            if (FnExprTokens.indexOf(checkToken.value) >= 0) {
              return scanPunctuator();
            }
            return collectRegex();
          }
          return collectRegex();
        }
        if (prevToken.type === "Keyword" && prevToken.value !== "this") {
          return collectRegex();
        }
        return scanPunctuator();
      }
      function advance() {
        var ch;
        skipComment();
        if (index >= length) {
          return {
            type: Token.EOF,
            lineNumber,
            lineStart,
            start: index,
            end: index
          };
        }
        ch = source.charCodeAt(index);
        if (isIdentifierStart(ch)) {
          return scanIdentifier();
        }
        if (ch === 40 || ch === 41 || ch === 59) {
          return scanPunctuator();
        }
        if (ch === 39 || ch === 34) {
          return scanStringLiteral();
        }
        if (ch === 46) {
          if (isDecimalDigit(source.charCodeAt(index + 1))) {
            return scanNumericLiteral();
          }
          return scanPunctuator();
        }
        if (isDecimalDigit(ch)) {
          return scanNumericLiteral();
        }
        if (extra.tokenize && ch === 47) {
          return advanceSlash();
        }
        return scanPunctuator();
      }
      function collectToken() {
        var loc, token, range2, value;
        skipComment();
        loc = {
          start: {
            line: lineNumber,
            column: index - lineStart
          }
        };
        token = advance();
        loc.end = {
          line: lineNumber,
          column: index - lineStart
        };
        if (token.type !== Token.EOF) {
          value = source.slice(token.start, token.end);
          extra.tokens.push({
            type: TokenName[token.type],
            value,
            range: [token.start, token.end],
            loc
          });
        }
        return token;
      }
      function lex() {
        var token;
        token = lookahead;
        index = token.end;
        lineNumber = token.lineNumber;
        lineStart = token.lineStart;
        lookahead = typeof extra.tokens !== "undefined" ? collectToken() : advance();
        index = token.end;
        lineNumber = token.lineNumber;
        lineStart = token.lineStart;
        return token;
      }
      function peek() {
        var pos, line, start2;
        pos = index;
        line = lineNumber;
        start2 = lineStart;
        lookahead = typeof extra.tokens !== "undefined" ? collectToken() : advance();
        index = pos;
        lineNumber = line;
        lineStart = start2;
      }
      function Position(line, column) {
        this.line = line;
        this.column = column;
      }
      function SourceLocation(startLine, startColumn, line, column) {
        this.start = new Position(startLine, startColumn);
        this.end = new Position(line, column);
      }
      SyntaxTreeDelegate = {
        name: "SyntaxTree",
        processComment: function(node) {
          var lastChild, trailingComments;
          if (node.type === Syntax.Program) {
            if (node.body.length > 0) {
              return;
            }
          }
          if (extra.trailingComments.length > 0) {
            if (extra.trailingComments[0].range[0] >= node.range[1]) {
              trailingComments = extra.trailingComments;
              extra.trailingComments = [];
            } else {
              extra.trailingComments.length = 0;
            }
          } else {
            if (extra.bottomRightStack.length > 0 && extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments && extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments[0].range[0] >= node.range[1]) {
              trailingComments = extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments;
              delete extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments;
            }
          }
          while (extra.bottomRightStack.length > 0 && extra.bottomRightStack[extra.bottomRightStack.length - 1].range[0] >= node.range[0]) {
            lastChild = extra.bottomRightStack.pop();
          }
          if (lastChild) {
            if (lastChild.leadingComments && lastChild.leadingComments[lastChild.leadingComments.length - 1].range[1] <= node.range[0]) {
              node.leadingComments = lastChild.leadingComments;
              delete lastChild.leadingComments;
            }
          } else if (extra.leadingComments.length > 0 && extra.leadingComments[extra.leadingComments.length - 1].range[1] <= node.range[0]) {
            node.leadingComments = extra.leadingComments;
            extra.leadingComments = [];
          }
          if (trailingComments) {
            node.trailingComments = trailingComments;
          }
          extra.bottomRightStack.push(node);
        },
        markEnd: function(node, startToken) {
          if (extra.range) {
            node.range = [startToken.start, index];
          }
          if (extra.loc) {
            node.loc = new SourceLocation(
              startToken.startLineNumber === void 0 ? startToken.lineNumber : startToken.startLineNumber,
              startToken.start - (startToken.startLineStart === void 0 ? startToken.lineStart : startToken.startLineStart),
              lineNumber,
              index - lineStart
            );
            this.postProcess(node);
          }
          if (extra.attachComment) {
            this.processComment(node);
          }
          return node;
        },
        postProcess: function(node) {
          if (extra.source) {
            node.loc.source = extra.source;
          }
          return node;
        },
        createArrayExpression: function(elements) {
          return {
            type: Syntax.ArrayExpression,
            elements
          };
        },
        createAssignmentExpression: function(operator, left, right) {
          return {
            type: Syntax.AssignmentExpression,
            operator,
            left,
            right
          };
        },
        createBinaryExpression: function(operator, left, right) {
          var type = operator === "||" || operator === "&&" ? Syntax.LogicalExpression : Syntax.BinaryExpression;
          return {
            type,
            operator,
            left,
            right
          };
        },
        createBlockStatement: function(body) {
          return {
            type: Syntax.BlockStatement,
            body
          };
        },
        createBreakStatement: function(label) {
          return {
            type: Syntax.BreakStatement,
            label
          };
        },
        createCallExpression: function(callee, args) {
          return {
            type: Syntax.CallExpression,
            callee,
            "arguments": args
          };
        },
        createCatchClause: function(param, body) {
          return {
            type: Syntax.CatchClause,
            param,
            body
          };
        },
        createConditionalExpression: function(test, consequent, alternate) {
          return {
            type: Syntax.ConditionalExpression,
            test,
            consequent,
            alternate
          };
        },
        createContinueStatement: function(label) {
          return {
            type: Syntax.ContinueStatement,
            label
          };
        },
        createDebuggerStatement: function() {
          return {
            type: Syntax.DebuggerStatement
          };
        },
        createDoWhileStatement: function(body, test) {
          return {
            type: Syntax.DoWhileStatement,
            body,
            test
          };
        },
        createEmptyStatement: function() {
          return {
            type: Syntax.EmptyStatement
          };
        },
        createExpressionStatement: function(expression) {
          return {
            type: Syntax.ExpressionStatement,
            expression
          };
        },
        createForStatement: function(init, test, update, body) {
          return {
            type: Syntax.ForStatement,
            init,
            test,
            update,
            body
          };
        },
        createForInStatement: function(left, right, body) {
          return {
            type: Syntax.ForInStatement,
            left,
            right,
            body,
            each: false
          };
        },
        createFunctionDeclaration: function(id, params, defaults, body) {
          return {
            type: Syntax.FunctionDeclaration,
            id,
            params,
            defaults,
            body,
            rest: null,
            generator: false,
            expression: false
          };
        },
        createFunctionExpression: function(id, params, defaults, body) {
          return {
            type: Syntax.FunctionExpression,
            id,
            params,
            defaults,
            body,
            rest: null,
            generator: false,
            expression: false
          };
        },
        createIdentifier: function(name) {
          return {
            type: Syntax.Identifier,
            name
          };
        },
        createIfStatement: function(test, consequent, alternate) {
          return {
            type: Syntax.IfStatement,
            test,
            consequent,
            alternate
          };
        },
        createLabeledStatement: function(label, body) {
          return {
            type: Syntax.LabeledStatement,
            label,
            body
          };
        },
        createLiteral: function(token) {
          return {
            type: Syntax.Literal,
            value: token.value,
            raw: source.slice(token.start, token.end)
          };
        },
        createMemberExpression: function(accessor, object, property) {
          return {
            type: Syntax.MemberExpression,
            computed: accessor === "[",
            object,
            property
          };
        },
        createNewExpression: function(callee, args) {
          return {
            type: Syntax.NewExpression,
            callee,
            "arguments": args
          };
        },
        createObjectExpression: function(properties) {
          return {
            type: Syntax.ObjectExpression,
            properties
          };
        },
        createPostfixExpression: function(operator, argument) {
          return {
            type: Syntax.UpdateExpression,
            operator,
            argument,
            prefix: false
          };
        },
        createProgram: function(body) {
          return {
            type: Syntax.Program,
            body
          };
        },
        createProperty: function(kind, key, value) {
          return {
            type: Syntax.Property,
            key,
            value,
            kind
          };
        },
        createReturnStatement: function(argument) {
          return {
            type: Syntax.ReturnStatement,
            argument
          };
        },
        createSequenceExpression: function(expressions) {
          return {
            type: Syntax.SequenceExpression,
            expressions
          };
        },
        createSwitchCase: function(test, consequent) {
          return {
            type: Syntax.SwitchCase,
            test,
            consequent
          };
        },
        createSwitchStatement: function(discriminant, cases) {
          return {
            type: Syntax.SwitchStatement,
            discriminant,
            cases
          };
        },
        createThisExpression: function() {
          return {
            type: Syntax.ThisExpression
          };
        },
        createThrowStatement: function(argument) {
          return {
            type: Syntax.ThrowStatement,
            argument
          };
        },
        createTryStatement: function(block, guardedHandlers, handlers, finalizer) {
          return {
            type: Syntax.TryStatement,
            block,
            guardedHandlers,
            handlers,
            finalizer
          };
        },
        createUnaryExpression: function(operator, argument) {
          if (operator === "++" || operator === "--") {
            return {
              type: Syntax.UpdateExpression,
              operator,
              argument,
              prefix: true
            };
          }
          return {
            type: Syntax.UnaryExpression,
            operator,
            argument,
            prefix: true
          };
        },
        createVariableDeclaration: function(declarations, kind) {
          return {
            type: Syntax.VariableDeclaration,
            declarations,
            kind
          };
        },
        createVariableDeclarator: function(id, init) {
          return {
            type: Syntax.VariableDeclarator,
            id,
            init
          };
        },
        createWhileStatement: function(test, body) {
          return {
            type: Syntax.WhileStatement,
            test,
            body
          };
        },
        createWithStatement: function(object, body) {
          return {
            type: Syntax.WithStatement,
            object,
            body
          };
        }
      };
      function peekLineTerminator() {
        var pos, line, start2, found;
        pos = index;
        line = lineNumber;
        start2 = lineStart;
        skipComment();
        found = lineNumber !== line;
        index = pos;
        lineNumber = line;
        lineStart = start2;
        return found;
      }
      function throwError(token, messageFormat) {
        var error, args = Array.prototype.slice.call(arguments, 2), msg = messageFormat.replace(
          /%(\d)/g,
          function(whole, index2) {
            assert2(index2 < args.length, "Message reference must be in range");
            return args[index2];
          }
        );
        if (typeof token.lineNumber === "number") {
          error = new Error("Line " + token.lineNumber + ": " + msg);
          error.index = token.start;
          error.lineNumber = token.lineNumber;
          error.column = token.start - lineStart + 1;
        } else {
          error = new Error("Line " + lineNumber + ": " + msg);
          error.index = index;
          error.lineNumber = lineNumber;
          error.column = index - lineStart + 1;
        }
        error.description = msg;
        throw error;
      }
      function throwErrorTolerant() {
        try {
          throwError.apply(null, arguments);
        } catch (e) {
          if (extra.errors) {
            extra.errors.push(e);
          } else {
            throw e;
          }
        }
      }
      function throwUnexpected(token) {
        if (token.type === Token.EOF) {
          throwError(token, Messages.UnexpectedEOS);
        }
        if (token.type === Token.NumericLiteral) {
          throwError(token, Messages.UnexpectedNumber);
        }
        if (token.type === Token.StringLiteral) {
          throwError(token, Messages.UnexpectedString);
        }
        if (token.type === Token.Identifier) {
          throwError(token, Messages.UnexpectedIdentifier);
        }
        if (token.type === Token.Keyword) {
          if (isFutureReservedWord(token.value)) {
            throwError(token, Messages.UnexpectedReserved);
          } else if (strict && isStrictModeReservedWord(token.value)) {
            throwErrorTolerant(token, Messages.StrictReservedWord);
            return;
          }
          throwError(token, Messages.UnexpectedToken, token.value);
        }
        throwError(token, Messages.UnexpectedToken, token.value);
      }
      function expect(value) {
        var token = lex();
        if (token.type !== Token.Punctuator || token.value !== value) {
          throwUnexpected(token);
        }
      }
      function expectKeyword(keyword) {
        var token = lex();
        if (token.type !== Token.Keyword || token.value !== keyword) {
          throwUnexpected(token);
        }
      }
      function match(value) {
        return lookahead.type === Token.Punctuator && lookahead.value === value;
      }
      function matchKeyword(keyword) {
        return lookahead.type === Token.Keyword && lookahead.value === keyword;
      }
      function matchAssign() {
        var op;
        if (lookahead.type !== Token.Punctuator) {
          return false;
        }
        op = lookahead.value;
        return op === "=" || op === "*=" || op === "/=" || op === "%=" || op === "+=" || op === "-=" || op === "<<=" || op === ">>=" || op === ">>>=" || op === "&=" || op === "^=" || op === "|=";
      }
      function consumeSemicolon() {
        var line, oldIndex = index, oldLineNumber = lineNumber, oldLineStart = lineStart, oldLookahead = lookahead;
        if (source.charCodeAt(index) === 59 || match(";")) {
          lex();
          return;
        }
        line = lineNumber;
        skipComment();
        if (lineNumber !== line) {
          index = oldIndex;
          lineNumber = oldLineNumber;
          lineStart = oldLineStart;
          lookahead = oldLookahead;
          return;
        }
        if (lookahead.type !== Token.EOF && !match("}")) {
          throwUnexpected(lookahead);
        }
      }
      function isLeftHandSide(expr) {
        return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;
      }
      function parseArrayInitialiser() {
        var elements = [], startToken;
        startToken = lookahead;
        expect("[");
        while (!match("]")) {
          if (match(",")) {
            lex();
            elements.push(null);
          } else {
            elements.push(parseAssignmentExpression());
            if (!match("]")) {
              expect(",");
            }
          }
        }
        lex();
        return delegate.markEnd(delegate.createArrayExpression(elements), startToken);
      }
      function parsePropertyFunction(param, first) {
        var previousStrict, body, startToken;
        previousStrict = strict;
        startToken = lookahead;
        body = parseFunctionSourceElements();
        if (first && strict && isRestrictedWord(param[0].name)) {
          throwErrorTolerant(first, Messages.StrictParamName);
        }
        strict = previousStrict;
        return delegate.markEnd(delegate.createFunctionExpression(null, param, [], body), startToken);
      }
      function parseObjectPropertyKey() {
        var token, startToken;
        startToken = lookahead;
        token = lex();
        if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {
          if (strict && token.octal) {
            throwErrorTolerant(token, Messages.StrictOctalLiteral);
          }
          return delegate.markEnd(delegate.createLiteral(token), startToken);
        }
        return delegate.markEnd(delegate.createIdentifier(token.value), startToken);
      }
      function parseObjectProperty() {
        var token, key, id, value, param, startToken;
        token = lookahead;
        startToken = lookahead;
        if (token.type === Token.Identifier) {
          id = parseObjectPropertyKey();
          if (token.value === "get" && !match(":")) {
            key = parseObjectPropertyKey();
            expect("(");
            expect(")");
            value = parsePropertyFunction([]);
            return delegate.markEnd(delegate.createProperty("get", key, value), startToken);
          }
          if (token.value === "set" && !match(":")) {
            key = parseObjectPropertyKey();
            expect("(");
            token = lookahead;
            if (token.type !== Token.Identifier) {
              expect(")");
              throwErrorTolerant(token, Messages.UnexpectedToken, token.value);
              value = parsePropertyFunction([]);
            } else {
              param = [parseVariableIdentifier()];
              expect(")");
              value = parsePropertyFunction(param, token);
            }
            return delegate.markEnd(delegate.createProperty("set", key, value), startToken);
          }
          expect(":");
          value = parseAssignmentExpression();
          return delegate.markEnd(delegate.createProperty("init", id, value), startToken);
        }
        if (token.type === Token.EOF || token.type === Token.Punctuator) {
          throwUnexpected(token);
        } else {
          key = parseObjectPropertyKey();
          expect(":");
          value = parseAssignmentExpression();
          return delegate.markEnd(delegate.createProperty("init", key, value), startToken);
        }
      }
      function parseObjectInitialiser() {
        var properties = [], property, name, key, kind, map = {}, toString = String, startToken;
        startToken = lookahead;
        expect("{");
        while (!match("}")) {
          property = parseObjectProperty();
          if (property.key.type === Syntax.Identifier) {
            name = property.key.name;
          } else {
            name = toString(property.key.value);
          }
          kind = property.kind === "init" ? PropertyKind.Data : property.kind === "get" ? PropertyKind.Get : PropertyKind.Set;
          key = "$" + name;
          if (Object.prototype.hasOwnProperty.call(map, key)) {
            if (map[key] === PropertyKind.Data) {
              if (strict && kind === PropertyKind.Data) {
                throwErrorTolerant({}, Messages.StrictDuplicateProperty);
              } else if (kind !== PropertyKind.Data) {
                throwErrorTolerant({}, Messages.AccessorDataProperty);
              }
            } else {
              if (kind === PropertyKind.Data) {
                throwErrorTolerant({}, Messages.AccessorDataProperty);
              } else if (map[key] & kind) {
                throwErrorTolerant({}, Messages.AccessorGetSet);
              }
            }
            map[key] |= kind;
          } else {
            map[key] = kind;
          }
          properties.push(property);
          if (!match("}")) {
            expect(",");
          }
        }
        expect("}");
        return delegate.markEnd(delegate.createObjectExpression(properties), startToken);
      }
      function parseGroupExpression() {
        var expr;
        expect("(");
        expr = parseExpression();
        expect(")");
        return expr;
      }
      function parsePrimaryExpression() {
        var type, token, expr, startToken;
        if (match("(")) {
          return parseGroupExpression();
        }
        if (match("[")) {
          return parseArrayInitialiser();
        }
        if (match("{")) {
          return parseObjectInitialiser();
        }
        type = lookahead.type;
        startToken = lookahead;
        if (type === Token.Identifier) {
          expr = delegate.createIdentifier(lex().value);
        } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {
          if (strict && lookahead.octal) {
            throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);
          }
          expr = delegate.createLiteral(lex());
        } else if (type === Token.Keyword) {
          if (matchKeyword("function")) {
            return parseFunctionExpression();
          }
          if (matchKeyword("this")) {
            lex();
            expr = delegate.createThisExpression();
          } else {
            throwUnexpected(lex());
          }
        } else if (type === Token.BooleanLiteral) {
          token = lex();
          token.value = token.value === "true";
          expr = delegate.createLiteral(token);
        } else if (type === Token.NullLiteral) {
          token = lex();
          token.value = null;
          expr = delegate.createLiteral(token);
        } else if (match("/") || match("/=")) {
          if (typeof extra.tokens !== "undefined") {
            expr = delegate.createLiteral(collectRegex());
          } else {
            expr = delegate.createLiteral(scanRegExp());
          }
          peek();
        } else {
          throwUnexpected(lex());
        }
        return delegate.markEnd(expr, startToken);
      }
      function parseArguments() {
        var args = [];
        expect("(");
        if (!match(")")) {
          while (index < length) {
            args.push(parseAssignmentExpression());
            if (match(")")) {
              break;
            }
            expect(",");
          }
        }
        expect(")");
        return args;
      }
      function parseNonComputedProperty() {
        var token, startToken;
        startToken = lookahead;
        token = lex();
        if (!isIdentifierName(token)) {
          throwUnexpected(token);
        }
        return delegate.markEnd(delegate.createIdentifier(token.value), startToken);
      }
      function parseNonComputedMember() {
        expect(".");
        return parseNonComputedProperty();
      }
      function parseComputedMember() {
        var expr;
        expect("[");
        expr = parseExpression();
        expect("]");
        return expr;
      }
      function parseNewExpression() {
        var callee, args, startToken;
        startToken = lookahead;
        expectKeyword("new");
        callee = parseLeftHandSideExpression();
        args = match("(") ? parseArguments() : [];
        return delegate.markEnd(delegate.createNewExpression(callee, args), startToken);
      }
      function parseLeftHandSideExpressionAllowCall() {
        var expr, args, property, startToken, previousAllowIn = state.allowIn;
        startToken = lookahead;
        state.allowIn = true;
        expr = matchKeyword("new") ? parseNewExpression() : parsePrimaryExpression();
        for (; ; ) {
          if (match(".")) {
            property = parseNonComputedMember();
            expr = delegate.createMemberExpression(".", expr, property);
          } else if (match("(")) {
            args = parseArguments();
            expr = delegate.createCallExpression(expr, args);
          } else if (match("[")) {
            property = parseComputedMember();
            expr = delegate.createMemberExpression("[", expr, property);
          } else {
            break;
          }
          delegate.markEnd(expr, startToken);
        }
        state.allowIn = previousAllowIn;
        return expr;
      }
      function parseLeftHandSideExpression() {
        var expr, property, startToken;
        assert2(state.allowIn, "callee of new expression always allow in keyword.");
        startToken = lookahead;
        expr = matchKeyword("new") ? parseNewExpression() : parsePrimaryExpression();
        while (match(".") || match("[")) {
          if (match("[")) {
            property = parseComputedMember();
            expr = delegate.createMemberExpression("[", expr, property);
          } else {
            property = parseNonComputedMember();
            expr = delegate.createMemberExpression(".", expr, property);
          }
          delegate.markEnd(expr, startToken);
        }
        return expr;
      }
      function parsePostfixExpression() {
        var expr, token, startToken = lookahead;
        expr = parseLeftHandSideExpressionAllowCall();
        if (lookahead.type === Token.Punctuator) {
          if ((match("++") || match("--")) && !peekLineTerminator()) {
            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
              throwErrorTolerant({}, Messages.StrictLHSPostfix);
            }
            if (!isLeftHandSide(expr)) {
              throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
            }
            token = lex();
            expr = delegate.markEnd(delegate.createPostfixExpression(token.value, expr), startToken);
          }
        }
        return expr;
      }
      function parseUnaryExpression() {
        var token, expr, startToken;
        if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {
          expr = parsePostfixExpression();
        } else if (match("++") || match("--")) {
          startToken = lookahead;
          token = lex();
          expr = parseUnaryExpression();
          if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
            throwErrorTolerant({}, Messages.StrictLHSPrefix);
          }
          if (!isLeftHandSide(expr)) {
            throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
          }
          expr = delegate.createUnaryExpression(token.value, expr);
          expr = delegate.markEnd(expr, startToken);
        } else if (match("+") || match("-") || match("~") || match("!")) {
          startToken = lookahead;
          token = lex();
          expr = parseUnaryExpression();
          expr = delegate.createUnaryExpression(token.value, expr);
          expr = delegate.markEnd(expr, startToken);
        } else if (matchKeyword("delete") || matchKeyword("void") || matchKeyword("typeof")) {
          startToken = lookahead;
          token = lex();
          expr = parseUnaryExpression();
          expr = delegate.createUnaryExpression(token.value, expr);
          expr = delegate.markEnd(expr, startToken);
          if (strict && expr.operator === "delete" && expr.argument.type === Syntax.Identifier) {
            throwErrorTolerant({}, Messages.StrictDelete);
          }
        } else {
          expr = parsePostfixExpression();
        }
        return expr;
      }
      function binaryPrecedence(token, allowIn) {
        var prec = 0;
        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {
          return 0;
        }
        switch (token.value) {
          case "||":
            prec = 1;
            break;
          case "&&":
            prec = 2;
            break;
          case "|":
            prec = 3;
            break;
          case "^":
            prec = 4;
            break;
          case "&":
            prec = 5;
            break;
          case "==":
          case "!=":
          case "===":
          case "!==":
            prec = 6;
            break;
          case "<":
          case ">":
          case "<=":
          case ">=":
          case "instanceof":
            prec = 7;
            break;
          case "in":
            prec = allowIn ? 7 : 0;
            break;
          case "<<":
          case ">>":
          case ">>>":
            prec = 8;
            break;
          case "+":
          case "-":
            prec = 9;
            break;
          case "*":
          case "/":
          case "%":
            prec = 11;
            break;
          default:
            break;
        }
        return prec;
      }
      function parseBinaryExpression() {
        var marker, markers, expr, token, prec, stack2, right, operator, left, i;
        marker = lookahead;
        left = parseUnaryExpression();
        token = lookahead;
        prec = binaryPrecedence(token, state.allowIn);
        if (prec === 0) {
          return left;
        }
        token.prec = prec;
        lex();
        markers = [marker, lookahead];
        right = parseUnaryExpression();
        stack2 = [left, token, right];
        while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {
          while (stack2.length > 2 && prec <= stack2[stack2.length - 2].prec) {
            right = stack2.pop();
            operator = stack2.pop().value;
            left = stack2.pop();
            expr = delegate.createBinaryExpression(operator, left, right);
            markers.pop();
            marker = markers[markers.length - 1];
            delegate.markEnd(expr, marker);
            stack2.push(expr);
          }
          token = lex();
          token.prec = prec;
          stack2.push(token);
          markers.push(lookahead);
          expr = parseUnaryExpression();
          stack2.push(expr);
        }
        i = stack2.length - 1;
        expr = stack2[i];
        markers.pop();
        while (i > 1) {
          expr = delegate.createBinaryExpression(stack2[i - 1].value, stack2[i - 2], expr);
          i -= 2;
          marker = markers.pop();
          delegate.markEnd(expr, marker);
        }
        return expr;
      }
      function parseConditionalExpression() {
        var expr, previousAllowIn, consequent, alternate, startToken;
        startToken = lookahead;
        expr = parseBinaryExpression();
        if (match("?")) {
          lex();
          previousAllowIn = state.allowIn;
          state.allowIn = true;
          consequent = parseAssignmentExpression();
          state.allowIn = previousAllowIn;
          expect(":");
          alternate = parseAssignmentExpression();
          expr = delegate.createConditionalExpression(expr, consequent, alternate);
          delegate.markEnd(expr, startToken);
        }
        return expr;
      }
      function parseAssignmentExpression() {
        var token, left, right, node, startToken;
        token = lookahead;
        startToken = lookahead;
        node = left = parseConditionalExpression();
        if (matchAssign()) {
          if (!isLeftHandSide(left)) {
            throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
          }
          if (strict && left.type === Syntax.Identifier && isRestrictedWord(left.name)) {
            throwErrorTolerant(token, Messages.StrictLHSAssignment);
          }
          token = lex();
          right = parseAssignmentExpression();
          node = delegate.markEnd(delegate.createAssignmentExpression(token.value, left, right), startToken);
        }
        return node;
      }
      function parseExpression() {
        var expr, startToken = lookahead;
        expr = parseAssignmentExpression();
        if (match(",")) {
          expr = delegate.createSequenceExpression([expr]);
          while (index < length) {
            if (!match(",")) {
              break;
            }
            lex();
            expr.expressions.push(parseAssignmentExpression());
          }
          delegate.markEnd(expr, startToken);
        }
        return expr;
      }
      function parseStatementList() {
        var list = [], statement;
        while (index < length) {
          if (match("}")) {
            break;
          }
          statement = parseSourceElement();
          if (typeof statement === "undefined") {
            break;
          }
          list.push(statement);
        }
        return list;
      }
      function parseBlock() {
        var block, startToken;
        startToken = lookahead;
        expect("{");
        block = parseStatementList();
        expect("}");
        return delegate.markEnd(delegate.createBlockStatement(block), startToken);
      }
      function parseVariableIdentifier() {
        var token, startToken;
        startToken = lookahead;
        token = lex();
        if (token.type !== Token.Identifier) {
          throwUnexpected(token);
        }
        return delegate.markEnd(delegate.createIdentifier(token.value), startToken);
      }
      function parseVariableDeclaration(kind) {
        var init = null, id, startToken;
        startToken = lookahead;
        id = parseVariableIdentifier();
        if (strict && isRestrictedWord(id.name)) {
          throwErrorTolerant({}, Messages.StrictVarName);
        }
        if (kind === "const") {
          expect("=");
          init = parseAssignmentExpression();
        } else if (match("=")) {
          lex();
          init = parseAssignmentExpression();
        }
        return delegate.markEnd(delegate.createVariableDeclarator(id, init), startToken);
      }
      function parseVariableDeclarationList(kind) {
        var list = [];
        do {
          list.push(parseVariableDeclaration(kind));
          if (!match(",")) {
            break;
          }
          lex();
        } while (index < length);
        return list;
      }
      function parseVariableStatement() {
        var declarations;
        expectKeyword("var");
        declarations = parseVariableDeclarationList();
        consumeSemicolon();
        return delegate.createVariableDeclaration(declarations, "var");
      }
      function parseConstLetDeclaration(kind) {
        var declarations, startToken;
        startToken = lookahead;
        expectKeyword(kind);
        declarations = parseVariableDeclarationList(kind);
        consumeSemicolon();
        return delegate.markEnd(delegate.createVariableDeclaration(declarations, kind), startToken);
      }
      function parseEmptyStatement() {
        expect(";");
        return delegate.createEmptyStatement();
      }
      function parseExpressionStatement() {
        var expr = parseExpression();
        consumeSemicolon();
        return delegate.createExpressionStatement(expr);
      }
      function parseIfStatement() {
        var test, consequent, alternate;
        expectKeyword("if");
        expect("(");
        test = parseExpression();
        expect(")");
        consequent = parseStatement();
        if (matchKeyword("else")) {
          lex();
          alternate = parseStatement();
        } else {
          alternate = null;
        }
        return delegate.createIfStatement(test, consequent, alternate);
      }
      function parseDoWhileStatement() {
        var body, test, oldInIteration;
        expectKeyword("do");
        oldInIteration = state.inIteration;
        state.inIteration = true;
        body = parseStatement();
        state.inIteration = oldInIteration;
        expectKeyword("while");
        expect("(");
        test = parseExpression();
        expect(")");
        if (match(";")) {
          lex();
        }
        return delegate.createDoWhileStatement(body, test);
      }
      function parseWhileStatement() {
        var test, body, oldInIteration;
        expectKeyword("while");
        expect("(");
        test = parseExpression();
        expect(")");
        oldInIteration = state.inIteration;
        state.inIteration = true;
        body = parseStatement();
        state.inIteration = oldInIteration;
        return delegate.createWhileStatement(test, body);
      }
      function parseForVariableDeclaration() {
        var token, declarations, startToken;
        startToken = lookahead;
        token = lex();
        declarations = parseVariableDeclarationList();
        return delegate.markEnd(delegate.createVariableDeclaration(declarations, token.value), startToken);
      }
      function parseForStatement() {
        var init, test, update, left, right, body, oldInIteration, previousAllowIn = state.allowIn;
        init = test = update = null;
        expectKeyword("for");
        expect("(");
        if (match(";")) {
          lex();
        } else {
          if (matchKeyword("var") || matchKeyword("let")) {
            state.allowIn = false;
            init = parseForVariableDeclaration();
            state.allowIn = previousAllowIn;
            if (init.declarations.length === 1 && matchKeyword("in")) {
              lex();
              left = init;
              right = parseExpression();
              init = null;
            }
          } else {
            state.allowIn = false;
            init = parseExpression();
            state.allowIn = previousAllowIn;
            if (matchKeyword("in")) {
              if (!isLeftHandSide(init)) {
                throwErrorTolerant({}, Messages.InvalidLHSInForIn);
              }
              lex();
              left = init;
              right = parseExpression();
              init = null;
            }
          }
          if (typeof left === "undefined") {
            expect(";");
          }
        }
        if (typeof left === "undefined") {
          if (!match(";")) {
            test = parseExpression();
          }
          expect(";");
          if (!match(")")) {
            update = parseExpression();
          }
        }
        expect(")");
        oldInIteration = state.inIteration;
        state.inIteration = true;
        body = parseStatement();
        state.inIteration = oldInIteration;
        return typeof left === "undefined" ? delegate.createForStatement(init, test, update, body) : delegate.createForInStatement(left, right, body);
      }
      function parseContinueStatement() {
        var label = null, key;
        expectKeyword("continue");
        if (source.charCodeAt(index) === 59) {
          lex();
          if (!state.inIteration) {
            throwError({}, Messages.IllegalContinue);
          }
          return delegate.createContinueStatement(null);
        }
        if (peekLineTerminator()) {
          if (!state.inIteration) {
            throwError({}, Messages.IllegalContinue);
          }
          return delegate.createContinueStatement(null);
        }
        if (lookahead.type === Token.Identifier) {
          label = parseVariableIdentifier();
          key = "$" + label.name;
          if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
            throwError({}, Messages.UnknownLabel, label.name);
          }
        }
        consumeSemicolon();
        if (label === null && !state.inIteration) {
          throwError({}, Messages.IllegalContinue);
        }
        return delegate.createContinueStatement(label);
      }
      function parseBreakStatement() {
        var label = null, key;
        expectKeyword("break");
        if (source.charCodeAt(index) === 59) {
          lex();
          if (!(state.inIteration || state.inSwitch)) {
            throwError({}, Messages.IllegalBreak);
          }
          return delegate.createBreakStatement(null);
        }
        if (peekLineTerminator()) {
          if (!(state.inIteration || state.inSwitch)) {
            throwError({}, Messages.IllegalBreak);
          }
          return delegate.createBreakStatement(null);
        }
        if (lookahead.type === Token.Identifier) {
          label = parseVariableIdentifier();
          key = "$" + label.name;
          if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
            throwError({}, Messages.UnknownLabel, label.name);
          }
        }
        consumeSemicolon();
        if (label === null && !(state.inIteration || state.inSwitch)) {
          throwError({}, Messages.IllegalBreak);
        }
        return delegate.createBreakStatement(label);
      }
      function parseReturnStatement() {
        var argument = null;
        expectKeyword("return");
        if (!state.inFunctionBody) {
          throwErrorTolerant({}, Messages.IllegalReturn);
        }
        if (source.charCodeAt(index) === 32) {
          if (isIdentifierStart(source.charCodeAt(index + 1))) {
            argument = parseExpression();
            consumeSemicolon();
            return delegate.createReturnStatement(argument);
          }
        }
        if (peekLineTerminator()) {
          return delegate.createReturnStatement(null);
        }
        if (!match(";")) {
          if (!match("}") && lookahead.type !== Token.EOF) {
            argument = parseExpression();
          }
        }
        consumeSemicolon();
        return delegate.createReturnStatement(argument);
      }
      function parseWithStatement() {
        var object, body;
        if (strict) {
          skipComment();
          throwErrorTolerant({}, Messages.StrictModeWith);
        }
        expectKeyword("with");
        expect("(");
        object = parseExpression();
        expect(")");
        body = parseStatement();
        return delegate.createWithStatement(object, body);
      }
      function parseSwitchCase() {
        var test, consequent = [], statement, startToken;
        startToken = lookahead;
        if (matchKeyword("default")) {
          lex();
          test = null;
        } else {
          expectKeyword("case");
          test = parseExpression();
        }
        expect(":");
        while (index < length) {
          if (match("}") || matchKeyword("default") || matchKeyword("case")) {
            break;
          }
          statement = parseStatement();
          consequent.push(statement);
        }
        return delegate.markEnd(delegate.createSwitchCase(test, consequent), startToken);
      }
      function parseSwitchStatement() {
        var discriminant, cases, clause, oldInSwitch, defaultFound;
        expectKeyword("switch");
        expect("(");
        discriminant = parseExpression();
        expect(")");
        expect("{");
        cases = [];
        if (match("}")) {
          lex();
          return delegate.createSwitchStatement(discriminant, cases);
        }
        oldInSwitch = state.inSwitch;
        state.inSwitch = true;
        defaultFound = false;
        while (index < length) {
          if (match("}")) {
            break;
          }
          clause = parseSwitchCase();
          if (clause.test === null) {
            if (defaultFound) {
              throwError({}, Messages.MultipleDefaultsInSwitch);
            }
            defaultFound = true;
          }
          cases.push(clause);
        }
        state.inSwitch = oldInSwitch;
        expect("}");
        return delegate.createSwitchStatement(discriminant, cases);
      }
      function parseThrowStatement() {
        var argument;
        expectKeyword("throw");
        if (peekLineTerminator()) {
          throwError({}, Messages.NewlineAfterThrow);
        }
        argument = parseExpression();
        consumeSemicolon();
        return delegate.createThrowStatement(argument);
      }
      function parseCatchClause() {
        var param, body, startToken;
        startToken = lookahead;
        expectKeyword("catch");
        expect("(");
        if (match(")")) {
          throwUnexpected(lookahead);
        }
        param = parseVariableIdentifier();
        if (strict && isRestrictedWord(param.name)) {
          throwErrorTolerant({}, Messages.StrictCatchVariable);
        }
        expect(")");
        body = parseBlock();
        return delegate.markEnd(delegate.createCatchClause(param, body), startToken);
      }
      function parseTryStatement() {
        var block, handlers = [], finalizer = null;
        expectKeyword("try");
        block = parseBlock();
        if (matchKeyword("catch")) {
          handlers.push(parseCatchClause());
        }
        if (matchKeyword("finally")) {
          lex();
          finalizer = parseBlock();
        }
        if (handlers.length === 0 && !finalizer) {
          throwError({}, Messages.NoCatchOrFinally);
        }
        return delegate.createTryStatement(block, [], handlers, finalizer);
      }
      function parseDebuggerStatement() {
        expectKeyword("debugger");
        consumeSemicolon();
        return delegate.createDebuggerStatement();
      }
      function parseStatement() {
        var type = lookahead.type, expr, labeledBody, key, startToken;
        if (type === Token.EOF) {
          throwUnexpected(lookahead);
        }
        if (type === Token.Punctuator && lookahead.value === "{") {
          return parseBlock();
        }
        startToken = lookahead;
        if (type === Token.Punctuator) {
          switch (lookahead.value) {
            case ";":
              return delegate.markEnd(parseEmptyStatement(), startToken);
            case "(":
              return delegate.markEnd(parseExpressionStatement(), startToken);
            default:
              break;
          }
        }
        if (type === Token.Keyword) {
          switch (lookahead.value) {
            case "break":
              return delegate.markEnd(parseBreakStatement(), startToken);
            case "continue":
              return delegate.markEnd(parseContinueStatement(), startToken);
            case "debugger":
              return delegate.markEnd(parseDebuggerStatement(), startToken);
            case "do":
              return delegate.markEnd(parseDoWhileStatement(), startToken);
            case "for":
              return delegate.markEnd(parseForStatement(), startToken);
            case "function":
              return delegate.markEnd(parseFunctionDeclaration(), startToken);
            case "if":
              return delegate.markEnd(parseIfStatement(), startToken);
            case "return":
              return delegate.markEnd(parseReturnStatement(), startToken);
            case "switch":
              return delegate.markEnd(parseSwitchStatement(), startToken);
            case "throw":
              return delegate.markEnd(parseThrowStatement(), startToken);
            case "try":
              return delegate.markEnd(parseTryStatement(), startToken);
            case "var":
              return delegate.markEnd(parseVariableStatement(), startToken);
            case "while":
              return delegate.markEnd(parseWhileStatement(), startToken);
            case "with":
              return delegate.markEnd(parseWithStatement(), startToken);
            default:
              break;
          }
        }
        expr = parseExpression();
        if (expr.type === Syntax.Identifier && match(":")) {
          lex();
          key = "$" + expr.name;
          if (Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
            throwError({}, Messages.Redeclaration, "Label", expr.name);
          }
          state.labelSet[key] = true;
          labeledBody = parseStatement();
          delete state.labelSet[key];
          return delegate.markEnd(delegate.createLabeledStatement(expr, labeledBody), startToken);
        }
        consumeSemicolon();
        return delegate.markEnd(delegate.createExpressionStatement(expr), startToken);
      }
      function parseFunctionSourceElements() {
        var sourceElement, sourceElements = [], token, directive, firstRestricted, oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody, startToken;
        startToken = lookahead;
        expect("{");
        while (index < length) {
          if (lookahead.type !== Token.StringLiteral) {
            break;
          }
          token = lookahead;
          sourceElement = parseSourceElement();
          sourceElements.push(sourceElement);
          if (sourceElement.expression.type !== Syntax.Literal) {
            break;
          }
          directive = source.slice(token.start + 1, token.end - 1);
          if (directive === "use strict") {
            strict = true;
            if (firstRestricted) {
              throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);
            }
          } else {
            if (!firstRestricted && token.octal) {
              firstRestricted = token;
            }
          }
        }
        oldLabelSet = state.labelSet;
        oldInIteration = state.inIteration;
        oldInSwitch = state.inSwitch;
        oldInFunctionBody = state.inFunctionBody;
        state.labelSet = {};
        state.inIteration = false;
        state.inSwitch = false;
        state.inFunctionBody = true;
        while (index < length) {
          if (match("}")) {
            break;
          }
          sourceElement = parseSourceElement();
          if (typeof sourceElement === "undefined") {
            break;
          }
          sourceElements.push(sourceElement);
        }
        expect("}");
        state.labelSet = oldLabelSet;
        state.inIteration = oldInIteration;
        state.inSwitch = oldInSwitch;
        state.inFunctionBody = oldInFunctionBody;
        return delegate.markEnd(delegate.createBlockStatement(sourceElements), startToken);
      }
      function parseParams(firstRestricted) {
        var param, params = [], token, stricted, paramSet, key, message;
        expect("(");
        if (!match(")")) {
          paramSet = {};
          while (index < length) {
            token = lookahead;
            param = parseVariableIdentifier();
            key = "$" + token.value;
            if (strict) {
              if (isRestrictedWord(token.value)) {
                stricted = token;
                message = Messages.StrictParamName;
              }
              if (Object.prototype.hasOwnProperty.call(paramSet, key)) {
                stricted = token;
                message = Messages.StrictParamDupe;
              }
            } else if (!firstRestricted) {
              if (isRestrictedWord(token.value)) {
                firstRestricted = token;
                message = Messages.StrictParamName;
              } else if (isStrictModeReservedWord(token.value)) {
                firstRestricted = token;
                message = Messages.StrictReservedWord;
              } else if (Object.prototype.hasOwnProperty.call(paramSet, key)) {
                firstRestricted = token;
                message = Messages.StrictParamDupe;
              }
            }
            params.push(param);
            paramSet[key] = true;
            if (match(")")) {
              break;
            }
            expect(",");
          }
        }
        expect(")");
        return {
          params,
          stricted,
          firstRestricted,
          message
        };
      }
      function parseFunctionDeclaration() {
        var id, params = [], body, token, stricted, tmp, firstRestricted, message, previousStrict, startToken;
        startToken = lookahead;
        expectKeyword("function");
        token = lookahead;
        id = parseVariableIdentifier();
        if (strict) {
          if (isRestrictedWord(token.value)) {
            throwErrorTolerant(token, Messages.StrictFunctionName);
          }
        } else {
          if (isRestrictedWord(token.value)) {
            firstRestricted = token;
            message = Messages.StrictFunctionName;
          } else if (isStrictModeReservedWord(token.value)) {
            firstRestricted = token;
            message = Messages.StrictReservedWord;
          }
        }
        tmp = parseParams(firstRestricted);
        params = tmp.params;
        stricted = tmp.stricted;
        firstRestricted = tmp.firstRestricted;
        if (tmp.message) {
          message = tmp.message;
        }
        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (strict && firstRestricted) {
          throwError(firstRestricted, message);
        }
        if (strict && stricted) {
          throwErrorTolerant(stricted, message);
        }
        strict = previousStrict;
        return delegate.markEnd(delegate.createFunctionDeclaration(id, params, [], body), startToken);
      }
      function parseFunctionExpression() {
        var token, id = null, stricted, firstRestricted, message, tmp, params = [], body, previousStrict, startToken;
        startToken = lookahead;
        expectKeyword("function");
        if (!match("(")) {
          token = lookahead;
          id = parseVariableIdentifier();
          if (strict) {
            if (isRestrictedWord(token.value)) {
              throwErrorTolerant(token, Messages.StrictFunctionName);
            }
          } else {
            if (isRestrictedWord(token.value)) {
              firstRestricted = token;
              message = Messages.StrictFunctionName;
            } else if (isStrictModeReservedWord(token.value)) {
              firstRestricted = token;
              message = Messages.StrictReservedWord;
            }
          }
        }
        tmp = parseParams(firstRestricted);
        params = tmp.params;
        stricted = tmp.stricted;
        firstRestricted = tmp.firstRestricted;
        if (tmp.message) {
          message = tmp.message;
        }
        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (strict && firstRestricted) {
          throwError(firstRestricted, message);
        }
        if (strict && stricted) {
          throwErrorTolerant(stricted, message);
        }
        strict = previousStrict;
        return delegate.markEnd(delegate.createFunctionExpression(id, params, [], body), startToken);
      }
      function parseSourceElement() {
        if (lookahead.type === Token.Keyword) {
          switch (lookahead.value) {
            case "const":
            case "let":
              return parseConstLetDeclaration(lookahead.value);
            case "function":
              return parseFunctionDeclaration();
            default:
              return parseStatement();
          }
        }
        if (lookahead.type !== Token.EOF) {
          return parseStatement();
        }
      }
      function parseSourceElements() {
        var sourceElement, sourceElements = [], token, directive, firstRestricted;
        while (index < length) {
          token = lookahead;
          if (token.type !== Token.StringLiteral) {
            break;
          }
          sourceElement = parseSourceElement();
          sourceElements.push(sourceElement);
          if (sourceElement.expression.type !== Syntax.Literal) {
            break;
          }
          directive = source.slice(token.start + 1, token.end - 1);
          if (directive === "use strict") {
            strict = true;
            if (firstRestricted) {
              throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);
            }
          } else {
            if (!firstRestricted && token.octal) {
              firstRestricted = token;
            }
          }
        }
        while (index < length) {
          sourceElement = parseSourceElement();
          if (typeof sourceElement === "undefined") {
            break;
          }
          sourceElements.push(sourceElement);
        }
        return sourceElements;
      }
      function parseProgram() {
        var body, startToken;
        skipComment();
        peek();
        startToken = lookahead;
        strict = false;
        body = parseSourceElements();
        return delegate.markEnd(delegate.createProgram(body), startToken);
      }
      function filterTokenLocation() {
        var i, entry, token, tokens = [];
        for (i = 0; i < extra.tokens.length; ++i) {
          entry = extra.tokens[i];
          token = {
            type: entry.type,
            value: entry.value
          };
          if (extra.range) {
            token.range = entry.range;
          }
          if (extra.loc) {
            token.loc = entry.loc;
          }
          tokens.push(token);
        }
        extra.tokens = tokens;
      }
      function tokenize(code, options) {
        var toString, token, tokens;
        toString = String;
        if (typeof code !== "string" && !(code instanceof String)) {
          code = toString(code);
        }
        delegate = SyntaxTreeDelegate;
        source = code;
        index = 0;
        lineNumber = source.length > 0 ? 1 : 0;
        lineStart = 0;
        length = source.length;
        lookahead = null;
        state = {
          allowIn: true,
          labelSet: {},
          inFunctionBody: false,
          inIteration: false,
          inSwitch: false,
          lastCommentStart: -1
        };
        extra = {};
        options = options || {};
        options.tokens = true;
        extra.tokens = [];
        extra.tokenize = true;
        extra.openParenToken = -1;
        extra.openCurlyToken = -1;
        extra.range = typeof options.range === "boolean" && options.range;
        extra.loc = typeof options.loc === "boolean" && options.loc;
        if (typeof options.comment === "boolean" && options.comment) {
          extra.comments = [];
        }
        if (typeof options.tolerant === "boolean" && options.tolerant) {
          extra.errors = [];
        }
        try {
          peek();
          if (lookahead.type === Token.EOF) {
            return extra.tokens;
          }
          token = lex();
          while (lookahead.type !== Token.EOF) {
            try {
              token = lex();
            } catch (lexError) {
              token = lookahead;
              if (extra.errors) {
                extra.errors.push(lexError);
                break;
              } else {
                throw lexError;
              }
            }
          }
          filterTokenLocation();
          tokens = extra.tokens;
          if (typeof extra.comments !== "undefined") {
            tokens.comments = extra.comments;
          }
          if (typeof extra.errors !== "undefined") {
            tokens.errors = extra.errors;
          }
        } catch (e) {
          throw e;
        } finally {
          extra = {};
        }
        return tokens;
      }
      function parse(code, options) {
        var program, toString;
        toString = String;
        if (typeof code !== "string" && !(code instanceof String)) {
          code = toString(code);
        }
        delegate = SyntaxTreeDelegate;
        source = code;
        index = 0;
        lineNumber = source.length > 0 ? 1 : 0;
        lineStart = 0;
        length = source.length;
        lookahead = null;
        state = {
          allowIn: true,
          labelSet: {},
          inFunctionBody: false,
          inIteration: false,
          inSwitch: false,
          lastCommentStart: -1
        };
        extra = {};
        if (typeof options !== "undefined") {
          extra.range = typeof options.range === "boolean" && options.range;
          extra.loc = typeof options.loc === "boolean" && options.loc;
          extra.attachComment = typeof options.attachComment === "boolean" && options.attachComment;
          if (extra.loc && options.source !== null && options.source !== void 0) {
            extra.source = toString(options.source);
          }
          if (typeof options.tokens === "boolean" && options.tokens) {
            extra.tokens = [];
          }
          if (typeof options.comment === "boolean" && options.comment) {
            extra.comments = [];
          }
          if (typeof options.tolerant === "boolean" && options.tolerant) {
            extra.errors = [];
          }
          if (extra.attachComment) {
            extra.range = true;
            extra.comments = [];
            extra.bottomRightStack = [];
            extra.trailingComments = [];
            extra.leadingComments = [];
          }
        }
        try {
          program = parseProgram();
          if (typeof extra.comments !== "undefined") {
            program.comments = extra.comments;
          }
          if (typeof extra.tokens !== "undefined") {
            filterTokenLocation();
            program.tokens = extra.tokens;
          }
          if (typeof extra.errors !== "undefined") {
            program.errors = extra.errors;
          }
        } catch (e) {
          throw e;
        } finally {
          extra = {};
        }
        return program;
      }
      exports3.version = "1.2.5";
      exports3.tokenize = tokenize;
      exports3.parse = parse;
      exports3.Syntax = (function() {
        var name, types = {};
        if (typeof Object.create === "function") {
          types = /* @__PURE__ */ Object.create(null);
        }
        for (name in Syntax) {
          if (Syntax.hasOwnProperty(name)) {
            types[name] = Syntax[name];
          }
        }
        if (typeof Object.freeze === "function") {
          Object.freeze(types);
        }
        return types;
      })();
    });
  }
});

// node_modules/cwise-parser/index.js
var require_cwise_parser = __commonJS({
  "node_modules/cwise-parser/index.js"(exports2, module2) {
    "use strict";
    var esprima = require_esprima();
    var uniq = require_uniq();
    var PREFIX_COUNTER = 0;
    function CompiledArgument(name, lvalue, rvalue) {
      this.name = name;
      this.lvalue = lvalue;
      this.rvalue = rvalue;
      this.count = 0;
    }
    function CompiledRoutine(body, args, thisVars, localVars) {
      this.body = body;
      this.args = args;
      this.thisVars = thisVars;
      this.localVars = localVars;
    }
    function isGlobal(identifier) {
      if (identifier === "eval") {
        throw new Error("cwise-parser: eval() not allowed");
      }
      if (typeof window !== "undefined") {
        return identifier in window;
      } else if (typeof global !== "undefined") {
        return identifier in global;
      } else if (typeof self !== "undefined") {
        return identifier in self;
      } else {
        return false;
      }
    }
    function getArgNames(ast) {
      var params = ast.body[0].expression.callee.params;
      var names = new Array(params.length);
      for (var i = 0; i < params.length; ++i) {
        names[i] = params[i].name;
      }
      return names;
    }
    function preprocess(func) {
      var src = ["(", func, ")()"].join("");
      var ast = esprima.parse(src, { range: true });
      var prefix = "_inline_" + PREFIX_COUNTER++ + "_";
      var argNames = getArgNames(ast);
      var compiledArgs = new Array(argNames.length);
      for (var i = 0; i < argNames.length; ++i) {
        compiledArgs[i] = new CompiledArgument([prefix, "arg", i, "_"].join(""), false, false);
      }
      var exploded = new Array(src.length);
      for (var i = 0, n = src.length; i < n; ++i) {
        exploded[i] = src.charAt(i);
      }
      var localVars = [];
      var thisVars = [];
      var computedThis = false;
      function createLocal(id) {
        var nstr = prefix + id.replace(/\_/g, "__");
        localVars.push(nstr);
        return nstr;
      }
      function createThisVar(id) {
        var nstr = "this_" + id.replace(/\_/g, "__");
        thisVars.push(nstr);
        return nstr;
      }
      function rewrite(node, nstr) {
        var lo = node.range[0], hi = node.range[1];
        for (var i2 = lo + 1; i2 < hi; ++i2) {
          exploded[i2] = "";
        }
        exploded[lo] = nstr;
      }
      function escapeString(str) {
        return "'" + str.replace(/\_/g, "\\_").replace(/\'/g, "'") + "'";
      }
      function source(node) {
        return exploded.slice(node.range[0], node.range[1]).join("");
      }
      var LVALUE = 1;
      var RVALUE = 2;
      function getUsage(node) {
        if (node.parent.type === "AssignmentExpression") {
          if (node.parent.left === node) {
            if (node.parent.operator === "=") {
              return LVALUE;
            }
            return LVALUE | RVALUE;
          }
        }
        if (node.parent.type === "UpdateExpression") {
          return LVALUE | RVALUE;
        }
        return RVALUE;
      }
      (function visit(node, parent) {
        node.parent = parent;
        if (node.type === "MemberExpression") {
          if (node.computed) {
            visit(node.object, node);
            visit(node.property, node);
          } else if (node.object.type === "ThisExpression") {
            rewrite(node, createThisVar(node.property.name));
          } else {
            visit(node.object, node);
          }
        } else if (node.type === "ThisExpression") {
          throw new Error("cwise-parser: Computed this is not allowed");
        } else if (node.type === "Identifier") {
          var name = node.name;
          var argNo = argNames.indexOf(name);
          if (argNo >= 0) {
            var carg = compiledArgs[argNo];
            var usage = getUsage(node);
            if (usage & LVALUE) {
              carg.lvalue = true;
            }
            if (usage & RVALUE) {
              carg.rvalue = true;
            }
            ++carg.count;
            rewrite(node, carg.name);
          } else if (isGlobal(name)) {
          } else {
            rewrite(node, createLocal(name));
          }
        } else if (node.type === "Literal") {
          if (typeof node.value === "string") {
            rewrite(node, escapeString(node.value));
          }
        } else if (node.type === "WithStatement") {
          throw new Error("cwise-parser: with() statements not allowed");
        } else {
          var keys = Object.keys(node);
          for (var i2 = 0, n2 = keys.length; i2 < n2; ++i2) {
            if (keys[i2] === "parent") {
              continue;
            }
            var value = node[keys[i2]];
            if (value) {
              if (value instanceof Array) {
                for (var j = 0; j < value.length; ++j) {
                  if (value[j] && typeof value[j].type === "string") {
                    visit(value[j], node);
                  }
                }
              } else if (typeof value.type === "string") {
                visit(value, node);
              }
            }
          }
        }
      })(ast.body[0].expression.callee.body, void 0);
      uniq(localVars);
      uniq(thisVars);
      var routine = new CompiledRoutine(source(ast.body[0].expression.callee.body), compiledArgs, thisVars, localVars);
      return routine;
    }
    module2.exports = preprocess;
  }
});

// node_modules/cwise/lib/cwise-esprima.js
var require_cwise_esprima = __commonJS({
  "node_modules/cwise/lib/cwise-esprima.js"(exports2, module2) {
    "use strict";
    var parse = require_cwise_parser();
    var compile = require_compiler();
    var REQUIRED_FIELDS = ["args", "body"];
    var OPTIONAL_FIELDS = ["pre", "post", "printCode", "funcName", "blockSize"];
    function createCWise(user_args) {
      for (var id in user_args) {
        if (REQUIRED_FIELDS.indexOf(id) < 0 && OPTIONAL_FIELDS.indexOf(id) < 0) {
          console.warn("cwise: Unknown argument '" + id + "' passed to expression compiler");
        }
      }
      for (var i = 0; i < REQUIRED_FIELDS.length; ++i) {
        if (!user_args[REQUIRED_FIELDS[i]]) {
          throw new Error("cwise: Missing argument: " + REQUIRED_FIELDS[i]);
        }
      }
      return compile({
        args: user_args.args,
        pre: parse(user_args.pre || function() {
        }),
        body: parse(user_args.body),
        post: parse(user_args.post || function() {
        }),
        debug: !!user_args.printCode,
        funcName: user_args.funcName || user_args.body.name || "cwise",
        blockSize: user_args.blockSize || 64
      });
    }
    module2.exports = createCWise;
  }
});

// node_modules/ndarray-resample/resample.js
var require_resample = __commonJS({
  "node_modules/ndarray-resample/resample.js"(exports2, module2) {
    "use strict";
    var fft2 = require_fft2();
    var pool2 = require_scratch();
    var ops = require_ndarray_ops();
    var cwise = require_cwise_esprima();
    var clampScale = cwise({
      args: ["array", "array", "scalar", "scalar", "scalar"],
      body: function clampScale2(out, inp, s, l, h) {
        var x = inp * s;
        if (x < l) {
          x = l;
        }
        if (x > h) {
          x = h;
        }
        out = x;
      }
    });
    function resample2(out, inp, clamp_lo, clamp_hi) {
      if (typeof clamp_lo === "undefined") {
        clamp_lo = -Infinity;
      }
      if (typeof clamp_hi === "undefined") {
        clamp_hi = Infinity;
      }
      var ishp = inp.shape;
      var oshp = out.shape;
      if (inp.shape.length !== out.shape.length) throw new Error("ndarray-resample: input and output arrays should have the same dimensions");
      var v, zeroInds = ishp.map(function() {
        return 0;
      });
      if (out.size === 1) {
        v = ops.sum(inp) / inp.size;
        if (v < clamp_lo) {
          v = clamp_lo;
        }
        if (v > clamp_hi) {
          v = clamp_hi;
        }
        out.set.apply(out, zeroInds.concat(v));
        return;
      } else if (inp.size === 1) {
        v = inp.get.apply(inp, zeroInds);
        if (v < clamp_lo) {
          v = clamp_lo;
        }
        if (v > clamp_hi) {
          v = clamp_hi;
        }
        ops.assigns(out, v);
        return;
      }
      var d = ishp.length;
      var mshp = new Array(d), initToZero = false;
      for (var i = 0; i < d; i++) {
        mshp[i] = Math.min(oshp[i], ishp[i]);
        if (oshp[i] > ishp[i]) initToZero = true;
      }
      var x = pool2.malloc(ishp), y = pool2.malloc(ishp);
      ops.assign(x, inp);
      ops.assigns(y, 0);
      fft2(1, x, y);
      var lo = x.lo, hi = x.hi;
      var s = pool2.malloc(oshp), t = pool2.malloc(oshp);
      if (initToZero) {
        ops.assigns(s, 0);
        ops.assigns(t, 0);
      }
      var nr = new Array(d), a = new Array(d), b = new Array(d), io = new Array(d);
      for (var i = 0; i < 1 << d; ++i) {
        for (var j = 0; j < d; ++j) {
          if (!(i & 1 << j)) {
            nr[j] = mshp[j] + 1 >>> 1;
            a[j] = 0;
            b[j] = 0;
            io[j] = 0;
          } else {
            nr[j] = mshp[j] - (mshp[j] + 1 >>> 1);
            if (nr[j] === 0) {
              continue;
            }
            a[j] = oshp[j] - nr[j];
            b[j] = ishp[j] - nr[j];
            io[j] = mshp[j] & 1 ? 0 : 1;
          }
        }
        ops.assign(hi.apply(lo.apply(s, a), nr), hi.apply(lo.apply(x, b), nr));
        ops.assign(lo.apply(hi.apply(lo.apply(t, a), nr), io), lo.apply(hi.apply(lo.apply(y, b), nr), io));
        ops.assigns(hi.apply(hi.apply(lo.apply(t, a), nr), io), 0);
      }
      fft2(-1, s, t);
      clampScale(out, s, out.size / inp.size, clamp_lo, clamp_hi);
      pool2.free(x);
      pool2.free(y);
      pool2.free(s);
      pool2.free(t);
    }
    module2.exports = resample2;
  }
});

// node_modules/@magenta/music/esm/core/aux_inputs.js
var aux_inputs_exports = {};
__export(aux_inputs_exports, {
  AuxiliaryInput: () => AuxiliaryInput,
  BinaryCounter: () => BinaryCounter,
  auxiliaryInputFromSpec: () => auxiliaryInputFromSpec
});
function auxiliaryInputFromSpec(spec) {
  switch (spec.type) {
    case "BinaryCounter":
      return new BinaryCounter(spec.args);
    default:
      throw new Error(`Unknown auxiliary input: ${spec}`);
  }
}
var AuxiliaryInput = class {
  constructor(depth) {
    this.depth = depth;
  }
};
var BinaryCounter = class extends AuxiliaryInput {
  constructor(args) {
    super(args.numBits);
  }
  getTensors(numSteps) {
    const buffer2 = buffer([numSteps, this.depth]);
    for (let step = 0; step < numSteps; ++step) {
      for (let i = 0; i < this.depth; ++i) {
        buffer2.set(Math.floor((step + 1) / Math.pow(2, i)) % 2 ? 1 : -1, step, i);
      }
    }
    return buffer2.toTensor().as2D(numSteps, this.depth);
  }
};

// node_modules/@magenta/music/esm/core/chords.js
var chords_exports = {};
__export(chords_exports, {
  ChordEncoder: () => ChordEncoder,
  ChordEncodingException: () => ChordEncodingException,
  ChordQuality: () => ChordQuality,
  ChordSymbolException: () => ChordSymbolException,
  ChordSymbols: () => ChordSymbols,
  MajorMinorChordEncoder: () => MajorMinorChordEncoder,
  PitchChordEncoder: () => PitchChordEncoder,
  TriadChordEncoder: () => TriadChordEncoder,
  chordEncoderFromType: () => chordEncoderFromType
});

// node_modules/@magenta/music/esm/core/constants.js
var constants_exports = {};
__export(constants_exports, {
  DEFAULT_CHANNEL: () => DEFAULT_CHANNEL,
  DEFAULT_DRUM_PITCH_CLASSES: () => DEFAULT_DRUM_PITCH_CLASSES,
  DEFAULT_PROGRAM: () => DEFAULT_PROGRAM,
  DEFAULT_QUARTERS_PER_MINUTE: () => DEFAULT_QUARTERS_PER_MINUTE,
  DEFAULT_STEPS_PER_BAR: () => DEFAULT_STEPS_PER_BAR,
  DEFAULT_STEPS_PER_QUARTER: () => DEFAULT_STEPS_PER_QUARTER,
  DEFAULT_STEPS_PER_SECOND: () => DEFAULT_STEPS_PER_SECOND,
  DEFAULT_TICKS_PER_QUARTER: () => DEFAULT_TICKS_PER_QUARTER,
  DEFAULT_VELOCITY: () => DEFAULT_VELOCITY,
  DRUM_CHANNEL: () => DRUM_CHANNEL,
  HI_CLICK_CLASS: () => HI_CLICK_CLASS,
  HI_CLICK_PITCH: () => HI_CLICK_PITCH,
  LO_CLICK_CLASS: () => LO_CLICK_CLASS,
  LO_CLICK_PITCH: () => LO_CLICK_PITCH,
  MAX_DRUM_PITCH: () => MAX_DRUM_PITCH,
  MAX_MIDI_PITCH: () => MAX_MIDI_PITCH,
  MAX_MIDI_PROGRAM: () => MAX_MIDI_PROGRAM,
  MAX_MIDI_VELOCITY: () => MAX_MIDI_VELOCITY,
  MAX_PIANO_PITCH: () => MAX_PIANO_PITCH,
  MIDI_PITCHES: () => MIDI_PITCHES,
  MIDI_VELOCITIES: () => MIDI_VELOCITIES,
  MIN_DRUM_PITCH: () => MIN_DRUM_PITCH,
  MIN_MIDI_PITCH: () => MIN_MIDI_PITCH,
  MIN_MIDI_PROGRAM: () => MIN_MIDI_PROGRAM,
  MIN_MIDI_VELOCITY: () => MIN_MIDI_VELOCITY,
  MIN_PIANO_PITCH: () => MIN_PIANO_PITCH,
  NON_DRUM_CHANNELS: () => NON_DRUM_CHANNELS,
  NO_CHORD: () => NO_CHORD,
  NUM_PITCH_CLASSES: () => NUM_PITCH_CLASSES
});
var DEFAULT_QUARTERS_PER_MINUTE = 120;
var DEFAULT_STEPS_PER_BAR = 16;
var DEFAULT_STEPS_PER_QUARTER = 4;
var DEFAULT_STEPS_PER_SECOND = 100;
var DEFAULT_VELOCITY = 80;
var DEFAULT_PROGRAM = 0;
var DEFAULT_TICKS_PER_QUARTER = 220;
var DEFAULT_CHANNEL = 0;
var DRUM_CHANNEL = 9;
var NON_DRUM_CHANNELS = [0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 13, 14, 15];
var DEFAULT_DRUM_PITCH_CLASSES = [
  [36, 35],
  [38, 27, 28, 31, 32, 33, 34, 37, 39, 40, 56, 65, 66, 75, 85],
  [42, 44, 54, 68, 69, 70, 71, 73, 78, 80],
  [46, 67, 72, 74, 79, 81],
  [45, 29, 41, 61, 64, 84],
  [48, 47, 60, 63, 77, 86, 87],
  [50, 30, 43, 62, 76, 83],
  [49, 55, 57, 58],
  [51, 52, 53, 59, 82]
];
var MIN_MIDI_VELOCITY = 0;
var MAX_MIDI_VELOCITY = 127;
var MIDI_VELOCITIES = MAX_MIDI_VELOCITY - MIN_MIDI_VELOCITY + 1;
var NO_CHORD = "N.C.";
var NUM_PITCH_CLASSES = 12;
var MIN_MIDI_PITCH = 0;
var MAX_MIDI_PITCH = 127;
var MIDI_PITCHES = MAX_MIDI_PITCH - MIN_MIDI_PITCH + 1;
var MIN_PIANO_PITCH = 21;
var MAX_PIANO_PITCH = 108;
var MIN_DRUM_PITCH = 35;
var MAX_DRUM_PITCH = 81;
var MIN_MIDI_PROGRAM = 0;
var MAX_MIDI_PROGRAM = 127;
var LO_CLICK_PITCH = 89;
var HI_CLICK_PITCH = 90;
var LO_CLICK_CLASS = 9;
var HI_CLICK_CLASS = 10;

// node_modules/@magenta/music/esm/core/chords.js
var CHORD_QUALITY_INTERVALS = [
  ["1P", "3M", "5P"],
  ["1P", "3m", "5P"],
  ["1P", "3M", "5A"],
  ["1P", "3m", "5d"]
];
var ChordQuality;
(function(ChordQuality2) {
  ChordQuality2[ChordQuality2["Major"] = 0] = "Major";
  ChordQuality2[ChordQuality2["Minor"] = 1] = "Minor";
  ChordQuality2[ChordQuality2["Augmented"] = 2] = "Augmented";
  ChordQuality2[ChordQuality2["Diminished"] = 3] = "Diminished";
  ChordQuality2[ChordQuality2["Other"] = 4] = "Other";
})(ChordQuality || (ChordQuality = {}));
var ChordSymbolException = class extends Error {
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, new.target.prototype);
  }
};
var ChordEncodingException = class extends Error {
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, new.target.prototype);
  }
};
var ChordSymbols = class {
  static pitches(chord) {
    const root = es6_exports2.tokenize(chord)[0];
    if (!root || !es6_exports2.exists(chord)) {
      throw new ChordSymbolException(`Unrecognized chord symbol: ${chord}`);
    }
    const notes = es6_exports2.notes(chord);
    return notes.map(es6_exports.chroma);
  }
  static root(chord) {
    const root = es6_exports2.tokenize(chord)[0];
    if (!root) {
      throw new ChordSymbolException(`Chord symbol has unknown root: ${chord}`);
    }
    return es6_exports.chroma(root);
  }
  static quality(chord) {
    if (!es6_exports2.exists(chord)) {
      throw new ChordSymbolException(`Unrecognized chord symbol: ${chord}`);
    }
    const intervals = es6_exports2.intervals(chord);
    const qualities = CHORD_QUALITY_INTERVALS.map((cqis) => cqis.every((cqi) => intervals.includes(cqi)));
    const i = qualities.indexOf(true);
    const j = qualities.lastIndexOf(true);
    if (i >= 0 && i === j) {
      return i;
    } else {
      return ChordQuality.Other;
    }
  }
};
var ChordEncoder = class {
  encodeProgression(chords, numSteps) {
    const encodedChords = chords.map((chord) => this.encode(chord));
    const indices = Array.from(Array(numSteps).keys()).map((step) => Math.floor(step * encodedChords.length / numSteps));
    return stack(indices.map((i) => encodedChords[i]));
  }
};
function chordEncoderFromType(type) {
  switch (type) {
    case "MajorMinorChordEncoder":
      return new MajorMinorChordEncoder();
    case "TriadChordEncoder":
      return new TriadChordEncoder();
    case "PitchChordEncoder":
      return new PitchChordEncoder();
    default:
      throw new Error(`Unknown chord encoder type: ${type}`);
  }
}
var MajorMinorChordEncoder = class extends ChordEncoder {
  constructor() {
    super(...arguments);
    this.depth = 1 + 2 * NUM_PITCH_CLASSES;
  }
  index(chord) {
    if (chord === NO_CHORD) {
      return 0;
    }
    const root = ChordSymbols.root(chord);
    const quality = ChordSymbols.quality(chord);
    const index = 1 + quality * NUM_PITCH_CLASSES + root;
    if (index >= this.depth) {
      throw new ChordEncodingException(`Chord is neither major nor minor: ${chord}`);
    }
    return index;
  }
  encode(chord) {
    return tidy(() => oneHot(tensor1d([this.index(chord)], "int32"), this.depth).as1D());
  }
};
var TriadChordEncoder = class extends ChordEncoder {
  constructor() {
    super(...arguments);
    this.depth = 1 + 4 * NUM_PITCH_CLASSES;
  }
  index(chord) {
    if (chord === NO_CHORD) {
      return 0;
    }
    const root = ChordSymbols.root(chord);
    const quality = ChordSymbols.quality(chord);
    const index = 1 + quality * NUM_PITCH_CLASSES + root;
    if (index >= this.depth) {
      throw new ChordEncodingException(`Chord is not a standard triad: ${chord}`);
    }
    return index;
  }
  encode(chord) {
    return tidy(() => oneHot(tensor1d([this.index(chord)], "int32"), this.depth).as1D());
  }
};
var PitchChordEncoder = class extends ChordEncoder {
  constructor() {
    super(...arguments);
    this.depth = 1 + 3 * NUM_PITCH_CLASSES;
  }
  encode(chord) {
    return tidy(() => {
      if (chord === NO_CHORD) {
        return oneHot(tensor1d([0], "int32"), this.depth).as1D();
      }
      const root = ChordSymbols.root(chord);
      const rootEncoding = oneHot(tensor1d([root], "int32"), NUM_PITCH_CLASSES).as1D();
      const pitchBuffer = buffer([NUM_PITCH_CLASSES]);
      ChordSymbols.pitches(chord).forEach((pitch) => pitchBuffer.set(1, pitch));
      const pitchEncoding = pitchBuffer.toTensor().as1D();
      const bassEncoding = rootEncoding;
      return concat1d([tensor1d([0]), rootEncoding, pitchEncoding, bassEncoding]);
    });
  }
};

// node_modules/@magenta/music/esm/core/data.js
var data_exports = {};
__export(data_exports, {
  DEFAULT_DRUM_PITCH_CLASSES: () => DEFAULT_DRUM_PITCH_CLASSES,
  DataConverter: () => DataConverter,
  DrumRollConverter: () => DrumRollConverter,
  DrumsConverter: () => DrumsConverter,
  DrumsOneHotConverter: () => DrumsOneHotConverter,
  GrooveConverter: () => GrooveConverter,
  MelodyConverter: () => MelodyConverter,
  MelodyRhythmConverter: () => MelodyRhythmConverter,
  MelodyShapeConverter: () => MelodyShapeConverter,
  MultitrackConverter: () => MultitrackConverter,
  TrioConverter: () => TrioConverter,
  TrioRhythmConverter: () => TrioRhythmConverter,
  converterFromSpec: () => converterFromSpec
});

// node_modules/@magenta/music/esm/protobuf/index.js
var import_proto = __toESM(require_proto());
var NoteSequence = import_proto.tensorflow.magenta.NoteSequence;

// node_modules/@magenta/music/esm/core/logging.js
var logging_exports = {};
__export(logging_exports, {
  Level: () => Level,
  log: () => log2,
  logWithDuration: () => logWithDuration,
  setVerbosity: () => setVerbosity,
  verbosity: () => verbosity
});

// node_modules/@magenta/music/esm/core/compat/global_browser.js
function getGlobalObject() {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw new Error("cannot find the global object");
}
var globalObject = getGlobalObject();
var fetch2 = globalObject.fetch.bind(globalObject);
var performance = globalObject.performance;
var navigator2 = globalObject.navigator;
var isSafari = !!globalObject.webkitOfflineAudioContext;
var isWorker = typeof globalObject.WorkerGlobalScope !== "undefined";
function getOfflineAudioContext(sampleRate) {
  const WEBKIT_SAMPLE_RATE = 44100;
  sampleRate = isSafari ? WEBKIT_SAMPLE_RATE : sampleRate;
  if (isWorker) {
    throw new Error("Cannot use offline audio context in a web worker.");
  }
  const SafariOfflineCtx = globalObject.webkitOfflineAudioContext;
  return isSafari ? new SafariOfflineCtx(1, sampleRate, sampleRate) : new globalObject.OfflineAudioContext(1, sampleRate, sampleRate);
}

// node_modules/@magenta/music/esm/core/compat/global.js
var isNode = typeof global !== "undefined" && typeof global.process !== "undefined";
var fetch3 = isNode ? require_browser() : window.fetch.bind(window);
var performance2 = isNode ? (init_performance_node(), __toCommonJS(performance_node_exports)) : window.performance;
var navigator3 = isNode ? (init_navigator_node(), __toCommonJS(navigator_node_exports)) : window.navigator;

// node_modules/@magenta/music/esm/core/logging.js
var Level;
(function(Level2) {
  Level2[Level2["NONE"] = 0] = "NONE";
  Level2[Level2["WARN"] = 5] = "WARN";
  Level2[Level2["INFO"] = 10] = "INFO";
  Level2[Level2["DEBUG"] = 20] = "DEBUG";
})(Level || (Level = {}));
var verbosity = 10;
function setVerbosity(verbosity2) {
  verbosity2 = verbosity2;
}
function log2(msg, prefix = "Magenta.js", level = 10) {
  if (level === 0) {
    throw Error("Logging level cannot be NONE.");
  }
  if (verbosity >= level) {
    const logMethod = level === 5 ? console.warn : console.log;
    logMethod(`%c ${prefix} `, "background:magenta; color:white", msg);
  }
}
function logWithDuration(msg, startTime, prefix = "Magenta.js", level = 10) {
  const durationSeconds = (performance2.now() - startTime) / 1e3;
  log2(`${msg} in ${durationSeconds.toPrecision(3)}s`, prefix, level);
}

// node_modules/@magenta/music/esm/core/melodies.js
var melodies_exports = {};
__export(melodies_exports, {
  Melody: () => Melody,
  MelodyRegister: () => MelodyRegister,
  MelodyRhythm: () => MelodyRhythm,
  MelodyShape: () => MelodyShape,
  NOTE_OFF: () => NOTE_OFF,
  NO_EVENT: () => NO_EVENT
});

// node_modules/@magenta/music/esm/core/sequences.js
var sequences_exports = {};
__export(sequences_exports, {
  BadTimeSignatureException: () => BadTimeSignatureException,
  MultipleTempoException: () => MultipleTempoException,
  MultipleTimeSignatureException: () => MultipleTimeSignatureException,
  NegativeTimeException: () => NegativeTimeException,
  QuantizationStatusException: () => QuantizationStatusException,
  applySustainControlChanges: () => applySustainControlChanges,
  assertIsAbsoluteQuantizedSequence: () => assertIsAbsoluteQuantizedSequence,
  assertIsQuantizedSequence: () => assertIsQuantizedSequence,
  assertIsRelativeQuantizedSequence: () => assertIsRelativeQuantizedSequence,
  clone: () => clone,
  concatenate: () => concatenate,
  createQuantizedNoteSequence: () => createQuantizedNoteSequence,
  isAbsoluteQuantizedSequence: () => isAbsoluteQuantizedSequence,
  isQuantizedSequence: () => isQuantizedSequence,
  isRelativeQuantizedSequence: () => isRelativeQuantizedSequence,
  mergeConsecutiveNotes: () => mergeConsecutiveNotes,
  mergeInstruments: () => mergeInstruments,
  quantizeNoteSequence: () => quantizeNoteSequence,
  quantizeToStep: () => quantizeToStep,
  replaceInstruments: () => replaceInstruments,
  split: () => split2,
  stepsPerQuarterToStepsPerSecond: () => stepsPerQuarterToStepsPerSecond,
  trim: () => trim,
  unquantizeSequence: () => unquantizeSequence
});
var QUANTIZE_CUTOFF = 0.5;
var MultipleTimeSignatureException = class extends Error {
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, new.target.prototype);
  }
};
var BadTimeSignatureException = class extends Error {
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, new.target.prototype);
  }
};
var NegativeTimeException = class extends Error {
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, new.target.prototype);
  }
};
var MultipleTempoException = class extends Error {
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, new.target.prototype);
  }
};
var QuantizationStatusException = class extends Error {
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, new.target.prototype);
  }
};
function isPowerOf2(n) {
  return n && (n & n - 1) === 0;
}
function clone(ns) {
  return NoteSequence.decode(NoteSequence.encode(ns).finish());
}
function stepsPerQuarterToStepsPerSecond(stepsPerQuarter, qpm) {
  return stepsPerQuarter * qpm / 60;
}
function quantizeToStep(unquantizedSeconds, stepsPerSecond, quantizeCutoff = QUANTIZE_CUTOFF) {
  const unquantizedSteps = unquantizedSeconds * stepsPerSecond;
  return Math.floor(unquantizedSteps + (1 - quantizeCutoff));
}
function getQuantizedTimeEvents(ns) {
  return ns.controlChanges.concat(ns.textAnnotations);
}
function quantizeNotesAndEvents(ns, stepsPerSecond) {
  for (const note of ns.notes) {
    note.quantizedStartStep = quantizeToStep(note.startTime, stepsPerSecond);
    note.quantizedEndStep = quantizeToStep(note.endTime, stepsPerSecond);
    if (note.quantizedEndStep === note.quantizedStartStep) {
      note.quantizedEndStep += 1;
    }
    if (note.quantizedStartStep < 0 || note.quantizedEndStep < 0) {
      throw new NegativeTimeException(`Got negative note time: start_step = ${note.quantizedStartStep}, end_step = ${note.quantizedEndStep}`);
    }
    if (note.quantizedEndStep > ns.totalQuantizedSteps) {
      ns.totalQuantizedSteps = note.quantizedEndStep;
    }
  }
  getQuantizedTimeEvents(ns).forEach((event) => {
    event.quantizedStep = quantizeToStep(event.time, stepsPerSecond);
    if (event.quantizedStep < 0) {
      throw new NegativeTimeException(`Got negative event time: step = ${event.quantizedStep}`);
    }
  });
}
function assertSingleTempo(ns) {
  if (!ns.tempos || ns.tempos.length === 0) {
    return;
  }
  ns.tempos.sort((a, b) => a.time - b.time);
  if (ns.tempos[0].time !== 0 && ns.tempos[0].qpm !== DEFAULT_QUARTERS_PER_MINUTE) {
    throw new MultipleTempoException(`NoteSequence has an implicit tempo change from initial ${DEFAULT_QUARTERS_PER_MINUTE} qpm to ${ns.tempos[0].qpm} qpm at ${ns.tempos[0].time} seconds.`);
  }
  for (let i = 1; i < ns.tempos.length; i++) {
    if (ns.tempos[i].qpm !== ns.tempos[0].qpm) {
      throw new MultipleTempoException(`NoteSequence has at least one tempo change from ${ns.tempos[0].qpm} qpm to ${ns.tempos[i].qpm}qpm at ${ns.tempos[i].time} seconds.`);
    }
  }
}
function quantizeNoteSequence(ns, stepsPerQuarter) {
  const qns = clone(ns);
  qns.quantizationInfo = NoteSequence.QuantizationInfo.create({ stepsPerQuarter });
  if (qns.timeSignatures.length > 0) {
    qns.timeSignatures.sort((a, b) => a.time - b.time);
    if (qns.timeSignatures[0].time !== 0 && !(qns.timeSignatures[0].numerator === 4 && qns.timeSignatures[0].denominator === 4)) {
      throw new MultipleTimeSignatureException(`NoteSequence has an implicit change from initial 4/4 time signature to ${qns.timeSignatures[0].numerator}/${qns.timeSignatures[0].denominator} at ${qns.timeSignatures[0].time} seconds.`);
    }
    for (let i = 1; i < qns.timeSignatures.length; i++) {
      const timeSignature = qns.timeSignatures[i];
      if (timeSignature.numerator !== qns.timeSignatures[0].numerator || timeSignature.denominator !== qns.timeSignatures[0].denominator) {
        throw new MultipleTimeSignatureException(`NoteSequence has at least one time signature change from ${qns.timeSignatures[0].numerator}/${qns.timeSignatures[0].denominator} to ${timeSignature.numerator}/${timeSignature.denominator} at ${timeSignature.time} seconds`);
      }
    }
    qns.timeSignatures[0].time = 0;
    qns.timeSignatures = [qns.timeSignatures[0]];
  } else {
    const timeSignature = NoteSequence.TimeSignature.create({ numerator: 4, denominator: 4, time: 0 });
    qns.timeSignatures.push(timeSignature);
  }
  const firstTS = qns.timeSignatures[0];
  if (!isPowerOf2(firstTS.denominator)) {
    throw new BadTimeSignatureException(`Denominator is not a power of 2. Time signature: ${firstTS.numerator}/${firstTS.denominator}`);
  }
  if (firstTS.numerator === 0) {
    throw new BadTimeSignatureException(`Numerator is 0. Time signature: ${firstTS.numerator}/${firstTS.denominator}`);
  }
  if (qns.tempos.length > 0) {
    assertSingleTempo(qns);
    qns.tempos[0].time = 0;
    qns.tempos = [qns.tempos[0]];
  } else {
    const tempo = NoteSequence.Tempo.create({ qpm: DEFAULT_QUARTERS_PER_MINUTE, time: 0 });
    qns.tempos.push(tempo);
  }
  const stepsPerSecond = stepsPerQuarterToStepsPerSecond(stepsPerQuarter, qns.tempos[0].qpm);
  qns.totalQuantizedSteps = quantizeToStep(ns.totalTime, stepsPerSecond);
  quantizeNotesAndEvents(qns, stepsPerSecond);
  return qns;
}
function isQuantizedSequence(ns) {
  return ns.quantizationInfo && (ns.quantizationInfo.stepsPerQuarter > 0 || ns.quantizationInfo.stepsPerSecond > 0);
}
function assertIsQuantizedSequence(ns) {
  if (!isQuantizedSequence(ns)) {
    throw new QuantizationStatusException(`NoteSequence ${ns.id} is not quantized (missing quantizationInfo)`);
  }
}
function isRelativeQuantizedSequence(ns) {
  return ns.quantizationInfo && ns.quantizationInfo.stepsPerQuarter > 0;
}
function assertIsRelativeQuantizedSequence(ns) {
  if (!isRelativeQuantizedSequence(ns)) {
    throw new QuantizationStatusException(`NoteSequence ${ns.id} is not quantized or is quantized based on absolute timing`);
  }
}
function isAbsoluteQuantizedSequence(ns) {
  return ns.quantizationInfo && ns.quantizationInfo.stepsPerSecond > 0;
}
function assertIsAbsoluteQuantizedSequence(ns) {
  if (!isAbsoluteQuantizedSequence(ns)) {
    throw new QuantizationStatusException(`NoteSequence ${ns.id} is not quantized or is quantized based on relative timing`);
  }
}
function unquantizeSequence(qns, qpm) {
  assertIsRelativeQuantizedSequence(qns);
  assertSingleTempo(qns);
  const ns = clone(qns);
  if (qpm) {
    if (ns.tempos && ns.tempos.length > 0) {
      ns.tempos[0].qpm = qpm;
    } else {
      ns.tempos.push(NoteSequence.Tempo.create({ time: 0, qpm }));
    }
  } else {
    qpm = qns.tempos && qns.tempos.length > 0 ? ns.tempos[0].qpm : DEFAULT_QUARTERS_PER_MINUTE;
  }
  const stepToSeconds = (step) => step / ns.quantizationInfo.stepsPerQuarter * (60 / qpm);
  ns.totalTime = stepToSeconds(ns.totalQuantizedSteps);
  ns.notes.forEach((n) => {
    n.startTime = stepToSeconds(n.quantizedStartStep);
    n.endTime = stepToSeconds(n.quantizedEndStep);
    ns.totalTime = Math.max(ns.totalTime, n.endTime);
    delete n.quantizedStartStep;
    delete n.quantizedEndStep;
  });
  getQuantizedTimeEvents(ns).forEach((event) => {
    event.time = stepToSeconds(event.time);
  });
  delete ns.totalQuantizedSteps;
  delete ns.quantizationInfo;
  return ns;
}
function createQuantizedNoteSequence(stepsPerQuarter = DEFAULT_STEPS_PER_QUARTER, qpm = DEFAULT_QUARTERS_PER_MINUTE) {
  return NoteSequence.create({ quantizationInfo: { stepsPerQuarter }, tempos: [{ qpm }] });
}
function mergeInstruments(ns) {
  const result = clone(ns);
  const events = result.notes.concat(result.pitchBends).concat(result.controlChanges);
  const programs = Array.from(new Set(events.filter((e) => !e.isDrum).map((e) => e.program)));
  events.forEach((e) => {
    if (e.isDrum) {
      e.program = 0;
      e.instrument = programs.length;
    } else {
      e.instrument = programs.indexOf(e.program);
    }
  });
  return result;
}
function replaceInstruments(originalSequence, replaceSequence) {
  const instrumentsInOriginal = new Set(originalSequence.notes.map((n) => n.instrument));
  const instrumentsInReplace = new Set(replaceSequence.notes.map((n) => n.instrument));
  const newNotes = [];
  originalSequence.notes.forEach((n) => {
    if (!instrumentsInReplace.has(n.instrument)) {
      newNotes.push(NoteSequence.Note.create(n));
    }
  });
  replaceSequence.notes.forEach((n) => {
    if (instrumentsInOriginal.has(n.instrument)) {
      newNotes.push(NoteSequence.Note.create(n));
    }
  });
  const output = clone(originalSequence);
  output.notes = newNotes.sort((a, b) => {
    const voiceCompare = a.instrument - b.instrument;
    if (voiceCompare) {
      return voiceCompare;
    }
    return a.quantizedStartStep - b.quantizedStartStep;
  });
  return output;
}
function mergeConsecutiveNotes(sequence) {
  assertIsQuantizedSequence(sequence);
  const output = clone(sequence);
  output.notes = [];
  const newNotes = sequence.notes.sort((a, b) => {
    const voiceCompare = a.instrument - b.instrument;
    if (voiceCompare) {
      return voiceCompare;
    }
    return a.quantizedStartStep - b.quantizedStartStep;
  });
  const note = new NoteSequence.Note();
  note.pitch = newNotes[0].pitch;
  note.instrument = newNotes[0].instrument;
  note.quantizedStartStep = newNotes[0].quantizedStartStep;
  note.quantizedEndStep = newNotes[0].quantizedEndStep;
  output.notes.push(note);
  let o = 0;
  for (let i = 1; i < newNotes.length; i++) {
    const thisNote = newNotes[i];
    const previousNote = output.notes[o];
    if (previousNote.instrument === thisNote.instrument && previousNote.pitch === thisNote.pitch && thisNote.quantizedStartStep === previousNote.quantizedEndStep && thisNote.quantizedStartStep % 16 !== 0) {
      output.notes[o].quantizedEndStep += thisNote.quantizedEndStep - thisNote.quantizedStartStep;
    } else {
      const note2 = new NoteSequence.Note();
      note2.pitch = newNotes[i].pitch;
      note2.instrument = newNotes[i].instrument;
      note2.quantizedStartStep = newNotes[i].quantizedStartStep;
      note2.quantizedEndStep = newNotes[i].quantizedEndStep;
      output.notes.push(note2);
      o++;
    }
  }
  return output;
}
function applySustainControlChanges(noteSequence, sustainControlNumber = 64) {
  let MessageType;
  (function(MessageType2) {
    MessageType2[MessageType2["SUSTAIN_ON"] = 0] = "SUSTAIN_ON";
    MessageType2[MessageType2["SUSTAIN_OFF"] = 1] = "SUSTAIN_OFF";
    MessageType2[MessageType2["NOTE_ON"] = 2] = "NOTE_ON";
    MessageType2[MessageType2["NOTE_OFF"] = 3] = "NOTE_OFF";
  })(MessageType || (MessageType = {}));
  const isQuantized = isQuantizedSequence(noteSequence);
  if (isQuantized) {
    throw new Error("Can only apply sustain to unquantized NoteSequence.");
  }
  const sequence = clone(noteSequence);
  const events = [];
  for (const note of sequence.notes) {
    if (note.isDrum === false) {
      if (note.startTime !== null) {
        events.push({
          time: note.startTime,
          type: MessageType.NOTE_ON,
          event: note
        });
      }
      if (note.endTime !== null) {
        events.push({
          time: note.endTime,
          type: MessageType.NOTE_OFF,
          event: note
        });
      }
    }
  }
  for (const cc of sequence.controlChanges) {
    if (cc.controlNumber === sustainControlNumber) {
      const value = cc.controlValue;
      if (value < 0 || value > 127) {
      }
      if (value >= 64) {
        events.push({
          time: cc.time,
          type: MessageType.SUSTAIN_ON,
          event: cc
        });
      } else if (value < 64) {
        events.push({
          time: cc.time,
          type: MessageType.SUSTAIN_OFF,
          event: cc
        });
      }
    }
  }
  events.sort((a, b) => a.time - b.time);
  const activeNotes = {};
  const susActive = {};
  let time2 = 0;
  for (const item of events) {
    time2 = item.time;
    const type = item.type;
    const event = item.event;
    if (type === MessageType.SUSTAIN_ON) {
      susActive[event.instrument] = true;
    } else if (type === MessageType.SUSTAIN_OFF) {
      susActive[event.instrument] = false;
      const newActiveNotes = [];
      if (!(event.instrument in activeNotes)) {
        activeNotes[event.instrument] = [];
      }
      for (const note of activeNotes[event.instrument]) {
        if (note.endTime < time2) {
          note.endTime = time2;
          if (time2 > sequence.totalTime) {
            sequence.totalTime = time2;
          }
        } else {
          newActiveNotes.push(note);
        }
      }
      activeNotes[event.instrument] = newActiveNotes;
    } else if (type === MessageType.NOTE_ON) {
      if (susActive[event.instrument] === true) {
        const newActiveNotes = [];
        if (!(event.instrument in activeNotes)) {
          activeNotes[event.instrument] = [];
        }
        for (const note of activeNotes[event.instrument]) {
          if (note.pitch === event.pitch) {
            note.endTime = time2;
            if (note.startTime === note.endTime) {
              sequence.notes.push(note);
            }
          } else {
            newActiveNotes.push(note);
          }
        }
        activeNotes[event.instrument] = newActiveNotes;
      }
      if (!(event.instrument in activeNotes)) {
        activeNotes[event.instrument] = [];
      }
      activeNotes[event.instrument].push(event);
    } else if (type === MessageType.NOTE_OFF) {
      if (susActive[event.instrument] === true) {
      } else {
        const index = activeNotes[event.instrument].indexOf(event);
        if (index > -1) {
          activeNotes[event.instrument].splice(index, 1);
        }
      }
    }
  }
  for (const instrument of Object.values(activeNotes)) {
    for (const note of instrument) {
      note.endTime = time2;
      sequence.totalTime = time2;
    }
  }
  return sequence;
}
function concatenate(concatenateSequences, sequenceDurations) {
  if (sequenceDurations && sequenceDurations.length !== concatenateSequences.length) {
    throw new Error(`Number of sequences to concatenate and their individual
 durations does not match.`);
  }
  if (isQuantizedSequence(concatenateSequences[0])) {
    for (let i = 0; i < concatenateSequences.length; ++i) {
      assertIsQuantizedSequence(concatenateSequences[i]);
      if (concatenateSequences[i].quantizationInfo.stepsPerQuarter !== concatenateSequences[0].quantizationInfo.stepsPerQuarter) {
        throw new Error("Not all sequences have the same quantizationInfo");
      }
    }
    return concatenateHelper(concatenateSequences, "totalQuantizedSteps", "quantizedStartStep", "quantizedEndStep", sequenceDurations);
  } else {
    return concatenateHelper(concatenateSequences, "totalTime", "startTime", "endTime", sequenceDurations);
  }
}
function trim(ns, start2, end, truncateEndNotes) {
  return isQuantizedSequence(ns) ? trimHelper(ns, start2, end, "totalQuantizedSteps", "quantizedStartStep", "quantizedEndStep", truncateEndNotes) : trimHelper(ns, start2, end, "totalTime", "startTime", "endTime", truncateEndNotes);
}
function concatenateHelper(seqs, totalKey, startKey, endKey, sequenceDurations) {
  let concatSeq;
  let totalDuration = 0;
  for (let i = 0; i < seqs.length; ++i) {
    const seqDuration = sequenceDurations ? sequenceDurations[i] : seqs[i][totalKey];
    if (seqDuration === 0) {
      throw Error(`Sequence ${seqs[i].id} has no ${totalKey}, and no individual duration was provided.`);
    }
    if (i === 0) {
      concatSeq = clone(seqs[0]);
    } else {
      Array.prototype.push.apply(concatSeq.notes, seqs[i].notes.map((n) => {
        const newN = NoteSequence.Note.create(n);
        newN[startKey] += totalDuration;
        newN[endKey] += totalDuration;
        return newN;
      }));
    }
    totalDuration += seqDuration;
  }
  concatSeq[totalKey] = totalDuration;
  return concatSeq;
}
function trimHelper(ns, start2, end, totalKey, startKey, endKey, truncateEndNotes) {
  const result = clone(ns);
  result[totalKey] = end;
  result.notes = result.notes.filter((n) => n[startKey] >= start2 && n[startKey] <= end && (truncateEndNotes || n[endKey] <= end));
  result[totalKey] -= start2;
  for (let i = 0; i < result.notes.length; i++) {
    result.notes[i][startKey] -= start2;
    result.notes[i][endKey] -= start2;
    if (truncateEndNotes) {
      result.notes[i][endKey] = Math.min(result.notes[i][endKey], result[totalKey]);
    }
  }
  return result;
}
function split2(seq, chunkSize) {
  assertIsQuantizedSequence(seq);
  const ns = clone(seq);
  const notesBystartStep = ns.notes.sort((a, b) => a.quantizedStartStep - b.quantizedStartStep);
  const chunks = [];
  let startStep = 0;
  let currentNotes = [];
  for (let i = 0; i < notesBystartStep.length; i++) {
    const note = notesBystartStep[i];
    const originalStartStep = note.quantizedStartStep;
    const originalEndStep = note.quantizedEndStep;
    note.quantizedStartStep -= startStep;
    note.quantizedEndStep -= startStep;
    if (note.quantizedStartStep < 0) {
      continue;
    }
    if (note.quantizedEndStep <= chunkSize) {
      currentNotes.push(note);
    } else {
      if (note.quantizedStartStep < chunkSize) {
        const newNote = NoteSequence.Note.create(note);
        newNote.quantizedEndStep = chunkSize;
        newNote.startTime = newNote.endTime = void 0;
        currentNotes.push(newNote);
        note.quantizedStartStep = startStep + chunkSize;
        note.quantizedEndStep = originalEndStep;
      } else {
        note.quantizedStartStep = originalStartStep;
        note.quantizedEndStep = originalEndStep;
      }
      if (note.quantizedEndStep > chunkSize || note.quantizedStartStep > chunkSize) {
        i = i - 1;
      }
      if (currentNotes.length !== 0) {
        const newSequence = clone(ns);
        newSequence.notes = currentNotes;
        newSequence.totalQuantizedSteps = chunkSize;
        chunks.push(newSequence);
      }
      currentNotes = [];
      startStep += chunkSize;
    }
  }
  if (currentNotes.length !== 0) {
    const newSequence = clone(ns);
    newSequence.notes = currentNotes;
    newSequence.totalQuantizedSteps = chunkSize;
    chunks.push(newSequence);
  }
  return chunks;
}

// node_modules/@magenta/music/esm/core/melodies.js
var NO_EVENT = 0;
var NOTE_OFF = 1;
var FIRST_PITCH = 2;
var Melody = class _Melody {
  constructor(events, minPitch, maxPitch) {
    this.events = events;
    this.minPitch = minPitch;
    this.maxPitch = maxPitch;
  }
  static fromNoteSequence(noteSequence, minPitch, maxPitch, ignorePolyphony = true, numSteps) {
    assertIsQuantizedSequence(noteSequence);
    const sortedNotes = noteSequence.notes.sort((n1, n2) => {
      if (n1.quantizedStartStep === n2.quantizedStartStep) {
        return n2.pitch - n1.pitch;
      }
      return n1.quantizedStartStep - n2.quantizedStartStep;
    });
    const events = new Int32Array(numSteps || noteSequence.totalQuantizedSteps);
    let lastStart = -1;
    sortedNotes.forEach((n) => {
      if (n.quantizedStartStep === lastStart) {
        if (!ignorePolyphony) {
          throw new Error("`NoteSequence` is not monophonic.");
        } else {
          return;
        }
      }
      if (n.pitch < minPitch || n.pitch > maxPitch) {
        throw Error(`\`NoteSequence\` has a pitch outside of the valid range: ${n.pitch}`);
      }
      events[n.quantizedStartStep] = n.pitch - minPitch + FIRST_PITCH;
      events[n.quantizedEndStep] = NOTE_OFF;
      lastStart = n.quantizedStartStep;
    });
    return new _Melody(events, minPitch, maxPitch);
  }
  toNoteSequence(stepsPerQuarter, qpm) {
    const noteSequence = createQuantizedNoteSequence(stepsPerQuarter, qpm);
    let currNote = null;
    for (let s = 0; s < this.events.length; ++s) {
      const event = this.events[s];
      switch (event) {
        case NO_EVENT:
          break;
        case NOTE_OFF:
          if (currNote) {
            currNote.quantizedEndStep = s;
            noteSequence.notes.push(currNote);
            currNote = null;
          }
          break;
        default:
          if (currNote) {
            currNote.quantizedEndStep = s;
            noteSequence.notes.push(currNote);
          }
          currNote = NoteSequence.Note.create({
            pitch: event - FIRST_PITCH + this.minPitch,
            quantizedStartStep: s
          });
      }
    }
    if (currNote) {
      currNote.quantizedEndStep = this.events.length;
      noteSequence.notes.push(currNote);
    }
    noteSequence.totalQuantizedSteps = this.events.length;
    return noteSequence;
  }
};
var MelodyRhythm = class {
  constructor() {
    this.depth = 1;
  }
  extract(melody) {
    const numSteps = melody.events.length;
    const buffer2 = buffer([numSteps, 1]);
    for (let step = 0; step < numSteps; ++step) {
      buffer2.set(melody.events[step] >= FIRST_PITCH ? 1 : 0, step, 0);
    }
    return buffer2.toTensor().as2D(numSteps, 1);
  }
};
var MelodyShape = class {
  constructor() {
    this.depth = 3;
  }
  extract(melody) {
    const numSteps = melody.events.length;
    const buffer2 = buffer([numSteps, 3]);
    let lastIndex = null;
    let lastPitch = null;
    for (let step = 0; step < numSteps; ++step) {
      if (melody.events[step] >= FIRST_PITCH) {
        if (lastIndex !== null) {
          if (buffer2.get(lastIndex, 0) === 0 && buffer2.get(lastIndex, 1) === 0 && buffer2.get(lastIndex, 2) === 0) {
            lastIndex = -1;
          }
          let direction;
          if (melody.events[step] < lastPitch) {
            direction = 0;
          } else if (melody.events[step] > lastPitch) {
            direction = 2;
          } else {
            direction = 1;
          }
          for (let i = step; i > lastIndex; --i) {
            buffer2.set(1, i, direction);
          }
        }
        lastIndex = step;
        lastPitch = melody.events[step];
      }
    }
    if (lastIndex !== numSteps - 1) {
      if (lastIndex === null || buffer2.get(lastIndex, 0) === 0 && buffer2.get(lastIndex, 1) === 0 && buffer2.get(lastIndex, 2) === 0) {
        for (let i = 0; i < numSteps; ++i) {
          buffer2.set(1, i, 1);
        }
      } else {
        for (let i = numSteps - 1; i > lastIndex; --i) {
          for (let j = 0; j < 3; j++) {
            buffer2.set(buffer2.get(lastIndex, j), i, j);
          }
        }
      }
    }
    return buffer2.toTensor().as2D(numSteps, 3);
  }
};
var MelodyRegister = class {
  constructor(boundaryPitches) {
    this.boundaryPitches = boundaryPitches;
    this.depth = boundaryPitches.length + 1;
  }
  meanMelodyPitch(melody) {
    let total = 0;
    let count = 0;
    let currentPitch = null;
    for (let step = 0; step < melody.events.length; ++step) {
      if (melody.events[step] === NOTE_OFF) {
        currentPitch = null;
      } else if (melody.events[step] >= FIRST_PITCH) {
        currentPitch = melody.minPitch + melody.events[step] - FIRST_PITCH;
      }
      if (currentPitch !== null) {
        total += currentPitch;
        count += 1;
      }
    }
    if (count) {
      return total / count;
    } else {
      return null;
    }
  }
  extract(melody) {
    const numSteps = melody.events.length;
    const meanPitch = this.meanMelodyPitch(melody);
    if (meanPitch === null) {
      return zeros([numSteps, this.depth]);
    }
    let bin = 0;
    while (bin < this.boundaryPitches.length && meanPitch >= this.boundaryPitches[bin]) {
      bin++;
    }
    const buffer2 = buffer([numSteps, this.depth]);
    for (let step = 0; step < numSteps; ++step) {
      buffer2.set(1, step, bin);
    }
    return buffer2.toTensor().as2D(numSteps, this.depth);
  }
};

// node_modules/@magenta/music/esm/core/performance.js
var performance_exports = {};
__export(performance_exports, {
  Performance: () => Performance
});
var Performance = class _Performance {
  constructor(events, maxShiftSteps, numVelocityBins, program, isDrum) {
    this.events = events;
    this.maxShiftSteps = maxShiftSteps;
    this.numVelocityBins = numVelocityBins;
    this.program = program;
    this.isDrum = isDrum;
  }
  static fromNoteSequence(noteSequence, maxShiftSteps, numVelocityBins, instrument) {
    assertIsQuantizedSequence(noteSequence);
    const notes = noteSequence.notes.filter((note, _) => instrument !== void 0 ? note.instrument === instrument : true);
    const sortedNotes = notes.sort((a, b) => a.startTime === b.startTime ? a.pitch - b.pitch : a.startTime - b.startTime);
    const onsets = sortedNotes.map((note, i) => ({ step: note.quantizedStartStep, index: i, isOffset: 0 }));
    const offsets = sortedNotes.map((note, i) => ({ step: note.quantizedEndStep, index: i, isOffset: 1 }));
    const noteEvents = onsets.concat(offsets).sort((a, b) => a.step === b.step ? a.index === b.index ? a.isOffset - b.isOffset : a.index - b.index : a.step - b.step);
    const velocityBinSize = numVelocityBins ? Math.ceil((MIDI_VELOCITIES - 1) / numVelocityBins) : void 0;
    const events = [];
    let currentStep = 0;
    let currentVelocityBin = numVelocityBins;
    for (const e of noteEvents) {
      if (e.step > currentStep) {
        while (e.step > currentStep + maxShiftSteps) {
          events.push({ type: "time-shift", steps: maxShiftSteps });
          currentStep += maxShiftSteps;
        }
        events.push({ type: "time-shift", steps: e.step - currentStep });
        currentStep = e.step;
      }
      if (e.isOffset) {
        events.push({ type: "note-off", pitch: sortedNotes[e.index].pitch });
      } else {
        if (velocityBinSize) {
          const velocityBin = Math.floor((sortedNotes[e.index].velocity - MIN_MIDI_VELOCITY - 1) / velocityBinSize) + 1;
          if (velocityBin !== currentVelocityBin) {
            events.push({ type: "velocity-change", velocityBin });
            currentVelocityBin = velocityBin;
          }
        }
        events.push({ type: "note-on", pitch: sortedNotes[e.index].pitch });
      }
    }
    const isDrum = notes.some((note) => note.isDrum) ? notes.some((note) => !note.isDrum) ? void 0 : true : false;
    const programs = Array.from(new Set(notes.map((note) => note.program)));
    const program = !isDrum && programs.length === 1 ? programs[0] : void 0;
    const performance3 = new _Performance(events, maxShiftSteps, numVelocityBins, program, isDrum);
    performance3.setNumSteps(noteSequence.totalQuantizedSteps);
    return performance3;
  }
  getNumSteps() {
    return this.events.filter((event) => event.type === "time-shift").map((event) => event.steps).reduce((a, b) => a + b, 0);
  }
  setNumSteps(numSteps) {
    let currentNumSteps = this.getNumSteps();
    if (currentNumSteps < numSteps) {
      if (this.events.length) {
        const event = this.events[this.events.length - 1];
        if (event.type === "time-shift") {
          const steps = Math.min(numSteps - currentNumSteps, this.maxShiftSteps - event.steps);
          event.steps += steps;
          currentNumSteps += steps;
        }
      }
      while (currentNumSteps < numSteps) {
        if (currentNumSteps + this.maxShiftSteps > numSteps) {
          this.events.push({ type: "time-shift", steps: numSteps - currentNumSteps });
          currentNumSteps = numSteps;
        } else {
          this.events.push({ type: "time-shift", steps: this.maxShiftSteps });
          currentNumSteps += this.maxShiftSteps;
        }
      }
    } else if (currentNumSteps > numSteps) {
      while (this.events.length && currentNumSteps > numSteps) {
        const event = this.events[this.events.length - 1];
        if (event.type === "time-shift") {
          if (currentNumSteps - event.steps < numSteps) {
            event.steps -= currentNumSteps - numSteps;
            currentNumSteps = numSteps;
          } else {
            this.events.pop();
            currentNumSteps -= event.steps;
          }
        } else {
          this.events.pop();
        }
      }
    }
  }
  toNoteSequence(instrument) {
    const velocityBinSize = this.numVelocityBins ? Math.ceil((MIDI_VELOCITIES - 1) / this.numVelocityBins) : void 0;
    const noteSequence = NoteSequence.create();
    let currentStep = 0;
    let currentVelocity = void 0;
    const pitchStartStepsAndVelocities = /* @__PURE__ */ new Map();
    for (let i = MIN_MIDI_PITCH; i <= MAX_MIDI_PITCH; ++i) {
      pitchStartStepsAndVelocities.set(i, []);
    }
    for (const event of this.events) {
      switch (event.type) {
        case "note-on":
          pitchStartStepsAndVelocities.get(event.pitch).push([
            currentStep,
            currentVelocity
          ]);
          break;
        case "note-off":
          const startStepsAndVelocities = pitchStartStepsAndVelocities.get(event.pitch);
          if (startStepsAndVelocities.length) {
            const [startStep, velocity] = startStepsAndVelocities.shift();
            if (currentStep > startStep) {
              noteSequence.notes.push(NoteSequence.Note.create({
                pitch: event.pitch,
                velocity,
                instrument,
                quantizedStartStep: startStep,
                quantizedEndStep: currentStep,
                program: this.program,
                isDrum: this.isDrum
              }));
            } else {
              log2(`Ignoring zero-length note: (pitch = ${event.pitch}, step = ${currentStep})`, "Performance");
            }
          } else {
            log2(`Ignoring note-off with no previous note-on:(pitch = ${event.pitch}, step = ${currentStep})`, "Performance");
          }
          break;
        case "time-shift":
          currentStep += event.steps;
          break;
        case "velocity-change":
          if (velocityBinSize) {
            currentVelocity = MIN_MIDI_VELOCITY + (event.velocityBin - 1) * velocityBinSize + 1;
          } else {
            throw new Error(`Unexpected velocity change event: ${event}`);
          }
          break;
        default:
          throw new Error(`Unrecognized performance event: ${event}`);
      }
    }
    pitchStartStepsAndVelocities.forEach((startStepsAndVelocities, pitch) => {
      for (const [startStep, velocity] of startStepsAndVelocities) {
        if (currentStep > startStep) {
          noteSequence.notes.push(NoteSequence.Note.create({
            pitch,
            velocity,
            instrument,
            quantizedStartStep: startStep,
            quantizedEndStep: currentStep,
            program: this.program,
            isDrum: this.isDrum
          }));
        } else {
          log2(`Ignoring zero-length note: (pitch = ${pitch}, step = ${currentStep})`, "Performance");
        }
      }
    });
    noteSequence.totalQuantizedSteps = currentStep;
    return noteSequence;
  }
};

// node_modules/@magenta/music/esm/core/data.js
function converterFromSpec(spec) {
  switch (spec.type) {
    case "MelodyConverter":
      return new MelodyConverter(spec.args);
    case "MelodyRhythmConverter":
      return new MelodyRhythmConverter(spec.args);
    case "MelodyShapeConverter":
      return new MelodyShapeConverter(spec.args);
    case "DrumsConverter":
      return new DrumsConverter(spec.args);
    case "DrumRollConverter":
      return new DrumRollConverter(spec.args);
    case "TrioConverter":
      return new TrioConverter(spec.args);
    case "TrioRhythmConverter":
      return new TrioRhythmConverter(spec.args);
    case "DrumsOneHotConverter":
      return new DrumsOneHotConverter(spec.args);
    case "MultitrackConverter":
      return new MultitrackConverter(spec.args);
    case "GrooveConverter":
      return new GrooveConverter(spec.args);
    default:
      throw new Error(`Unknown DataConverter type: ${spec}`);
  }
}
var DataConverter = class {
  constructor(args) {
    this.NUM_SPLITS = 0;
    this.SEGMENTED_BY_TRACK = false;
    this.numSteps = args.numSteps;
    this.numSegments = args.numSegments;
  }
  tensorSteps(tensor2) {
    return scalar(tensor2.shape[0], "int32");
  }
};
var DrumsConverter = class extends DataConverter {
  constructor(args) {
    super(args);
    this.pitchClasses = args.pitchClasses || DEFAULT_DRUM_PITCH_CLASSES;
    this.pitchToClass = /* @__PURE__ */ new Map();
    for (let c = 0; c < this.pitchClasses.length; ++c) {
      this.pitchClasses[c].forEach((p) => {
        this.pitchToClass.set(p, c);
      });
    }
    this.depth = this.pitchClasses.length + 1;
  }
  toTensor(noteSequence) {
    assertIsQuantizedSequence(noteSequence);
    const numSteps = this.numSteps || noteSequence.totalQuantizedSteps;
    const drumRoll = buffer([numSteps, this.pitchClasses.length + 1], "int32");
    for (let i = 0; i < numSteps; ++i) {
      drumRoll.set(1, i, -1);
    }
    noteSequence.notes.forEach((note) => {
      drumRoll.set(1, note.quantizedStartStep, this.pitchToClass.get(note.pitch));
      drumRoll.set(0, note.quantizedStartStep, -1);
    });
    return drumRoll.toTensor();
  }
  async toNoteSequence(oh, stepsPerQuarter, qpm) {
    const noteSequence = createQuantizedNoteSequence(stepsPerQuarter, qpm);
    const labelsTensor = oh.argMax(1);
    const labels = await labelsTensor.data();
    labelsTensor.dispose();
    for (let s = 0; s < labels.length; ++s) {
      for (let p = 0; p < this.pitchClasses.length; p++) {
        if (labels[s] >> p & 1) {
          noteSequence.notes.push(NoteSequence.Note.create({
            pitch: this.pitchClasses[p][0],
            quantizedStartStep: s,
            quantizedEndStep: s + 1,
            isDrum: true
          }));
        }
      }
    }
    noteSequence.totalQuantizedSteps = labels.length;
    return noteSequence;
  }
};
var DrumRollConverter = class extends DrumsConverter {
  async toNoteSequence(roll, stepsPerQuarter, qpm) {
    const noteSequence = createQuantizedNoteSequence(stepsPerQuarter, qpm);
    const flatRoll = await roll.data();
    for (let s = 0; s < roll.shape[0]; ++s) {
      const pitches = flatRoll.slice(s * this.pitchClasses.length, (s + 1) * this.pitchClasses.length);
      for (let p = 0; p < pitches.length; ++p) {
        if (pitches[p]) {
          noteSequence.notes.push(NoteSequence.Note.create({
            pitch: this.pitchClasses[p][0],
            quantizedStartStep: s,
            quantizedEndStep: s + 1,
            isDrum: true
          }));
        }
      }
    }
    noteSequence.totalQuantizedSteps = roll.shape[0];
    return noteSequence;
  }
};
var DrumsOneHotConverter = class extends DrumsConverter {
  constructor(args) {
    super(args);
    this.depth = Math.pow(2, this.pitchClasses.length);
  }
  toTensor(noteSequence) {
    assertIsRelativeQuantizedSequence(noteSequence);
    const numSteps = this.numSteps || noteSequence.totalQuantizedSteps;
    const labels = Array(numSteps).fill(0);
    for (const { pitch, quantizedStartStep } of noteSequence.notes) {
      labels[quantizedStartStep] += Math.pow(2, this.pitchToClass.get(pitch));
    }
    return tidy(() => oneHot(tensor1d(labels, "int32"), this.depth));
  }
};
var MelodyConverter = class extends DataConverter {
  constructor(args) {
    super(args);
    this.NOTE_OFF = 1;
    this.FIRST_PITCH = 2;
    this.minPitch = args.minPitch;
    this.maxPitch = args.maxPitch;
    this.ignorePolyphony = args.ignorePolyphony;
    this.depth = args.maxPitch - args.minPitch + 1 + this.FIRST_PITCH;
  }
  toTensor(noteSequence) {
    const melody = Melody.fromNoteSequence(noteSequence, this.minPitch, this.maxPitch, this.ignorePolyphony, this.numSteps);
    return tidy(() => oneHot(tensor(melody.events, [melody.events.length], "int32"), this.depth));
  }
  async toNoteSequence(oh, stepsPerQuarter, qpm) {
    const labelsTensor = oh.argMax(1);
    const labels = await labelsTensor.data();
    labelsTensor.dispose();
    const melody = new Melody(labels, this.minPitch, this.maxPitch);
    return melody.toNoteSequence(stepsPerQuarter, qpm);
  }
};
var MelodyControlConverter = class extends DataConverter {
  constructor(args, melodyControl) {
    super(args);
    this.minPitch = args.minPitch;
    this.maxPitch = args.maxPitch;
    this.ignorePolyphony = args.ignorePolyphony;
    this.melodyControl = melodyControl;
    this.depth = melodyControl.depth;
  }
  toTensor(noteSequence) {
    const melody = Melody.fromNoteSequence(noteSequence, this.minPitch, this.maxPitch, this.ignorePolyphony, this.numSteps);
    return this.melodyControl.extract(melody);
  }
};
var MelodyRhythmConverter = class extends MelodyControlConverter {
  constructor(args) {
    super(args, new MelodyRhythm());
  }
  async toNoteSequence(tensor2, stepsPerQuarter, qpm) {
    const noteSequence = createQuantizedNoteSequence(stepsPerQuarter, qpm);
    const rhythm = await tensor2.data();
    for (let s = 0; s < rhythm.length; ++s) {
      if (rhythm[s]) {
        noteSequence.notes.push(NoteSequence.Note.create({
          pitch: DEFAULT_DRUM_PITCH_CLASSES[1][0],
          quantizedStartStep: s,
          quantizedEndStep: s + 1,
          isDrum: true
        }));
      }
    }
    noteSequence.totalQuantizedSteps = rhythm.length;
    return noteSequence;
  }
};
var MelodyShapeConverter = class extends MelodyControlConverter {
  constructor(args) {
    super(args, new MelodyShape());
  }
  async toNoteSequence(oh, stepsPerQuarter, qpm) {
    const noteSequence = createQuantizedNoteSequence(stepsPerQuarter, qpm);
    const shapeTensor = oh.argMax(1);
    const shape = await shapeTensor.data();
    shapeTensor.dispose();
    let pitch = Math.round((this.maxPitch + this.minPitch) / 2);
    for (let s = 0; s < shape.length; ++s) {
      switch (shape[s]) {
        case 0:
          pitch -= 1;
          if (pitch < this.minPitch) {
            pitch = this.minPitch;
            log2("Pitch range exceeded when creating NoteSequence from shape.", "MelodyShapeConverter");
          }
          break;
        case 2:
          pitch += 1;
          if (pitch > this.maxPitch) {
            pitch = this.maxPitch;
            log2("Pitch range exceeded when creating NoteSequence from shape.", "MelodyShapeConverter");
          }
          break;
        default:
          break;
      }
      noteSequence.notes.push(NoteSequence.Note.create({ pitch, quantizedStartStep: s, quantizedEndStep: s + 1 }));
    }
    noteSequence.totalQuantizedSteps = shape.length;
    return noteSequence;
  }
};
var TrioConverter = class extends DataConverter {
  constructor(args) {
    super(args);
    this.NUM_SPLITS = 3;
    this.MEL_PROG_RANGE = [0, 31];
    this.BASS_PROG_RANGE = [32, 39];
    args.melArgs.numSteps = args.numSteps;
    args.bassArgs.numSteps = args.numSteps;
    args.drumsArgs.numSteps = args.numSteps;
    this.melConverter = new MelodyConverter(args.melArgs);
    this.bassConverter = new MelodyConverter(args.bassArgs);
    this.drumsConverter = new DrumsOneHotConverter(args.drumsArgs);
    this.depth = this.melConverter.depth + this.bassConverter.depth + this.drumsConverter.depth;
  }
  toTensor(noteSequence) {
    assertIsQuantizedSequence(noteSequence);
    const melSeq = clone(noteSequence);
    const bassSeq = clone(noteSequence);
    const drumsSeq = clone(noteSequence);
    melSeq.notes = noteSequence.notes.filter((n) => !n.isDrum && n.program >= this.MEL_PROG_RANGE[0] && n.program <= this.MEL_PROG_RANGE[1]);
    bassSeq.notes = noteSequence.notes.filter((n) => !n.isDrum && n.program >= this.BASS_PROG_RANGE[0] && n.program <= this.BASS_PROG_RANGE[1]);
    drumsSeq.notes = noteSequence.notes.filter((n) => n.isDrum);
    return tidy(() => concat([
      this.melConverter.toTensor(melSeq),
      this.bassConverter.toTensor(bassSeq),
      this.drumsConverter.toTensor(drumsSeq)
    ], -1));
  }
  async toNoteSequence(th, stepsPerQuarter, qpm) {
    const ohs = split(th, [
      this.melConverter.depth,
      this.bassConverter.depth,
      this.drumsConverter.depth
    ], -1);
    const ns = await this.melConverter.toNoteSequence(ohs[0], stepsPerQuarter, qpm);
    ns.notes.forEach((n) => {
      n.instrument = 0;
      n.program = 0;
    });
    const bassNs = await this.bassConverter.toNoteSequence(ohs[1], stepsPerQuarter, qpm);
    ns.notes.push(...bassNs.notes.map((n) => {
      n.instrument = 1;
      n.program = this.BASS_PROG_RANGE[0];
      return n;
    }));
    const drumsNs = await this.drumsConverter.toNoteSequence(ohs[2], stepsPerQuarter, qpm);
    ns.notes.push(...drumsNs.notes.map((n) => {
      n.instrument = 2;
      return n;
    }));
    ohs.forEach((oh) => oh.dispose());
    return ns;
  }
};
var TrioRhythmConverter = class extends DataConverter {
  constructor(args) {
    super(args);
    this.NUM_SPLITS = 3;
    this.trioConverter = new TrioConverter(args);
    this.depth = 3;
  }
  toTensor(noteSequence) {
    return tidy(() => {
      const trioTensor = this.trioConverter.toTensor(noteSequence);
      const instrumentTensors = split(trioTensor, [
        this.trioConverter.melConverter.depth,
        this.trioConverter.bassConverter.depth,
        this.trioConverter.drumsConverter.depth
      ], 1);
      const melodyEvents = argMax(instrumentTensors[0], 1);
      const bassEvents = argMax(instrumentTensors[1], 1);
      const drumsEvents = argMax(instrumentTensors[2], 1);
      const melodyRhythm = greater(melodyEvents, 1);
      const bassRhythm = greater(bassEvents, 1);
      const drumsRhythm = greater(drumsEvents, 0);
      return stack([melodyRhythm, bassRhythm, drumsRhythm], 1);
    });
  }
  async toNoteSequence(tensor2, stepsPerQuarter, qpm) {
    const rhythmTensors = split(tensor2, 3, 1);
    const rhythms = await Promise.all(rhythmTensors.map((t) => t.data()));
    const noteSequence = createQuantizedNoteSequence(stepsPerQuarter, qpm);
    for (let s = 0; s < this.numSteps; ++s) {
      if (rhythms[0][s]) {
        noteSequence.notes.push(NoteSequence.Note.create({
          pitch: 72,
          quantizedStartStep: s,
          quantizedEndStep: s + 1,
          instrument: 0,
          program: 0
        }));
      }
      if (rhythms[1][s]) {
        noteSequence.notes.push(NoteSequence.Note.create({
          pitch: 36,
          quantizedStartStep: s,
          quantizedEndStep: s + 1,
          instrument: 1,
          program: 32
        }));
      }
      if (rhythms[2][s]) {
        noteSequence.notes.push(NoteSequence.Note.create({
          pitch: DEFAULT_DRUM_PITCH_CLASSES[1][0],
          quantizedStartStep: s,
          quantizedEndStep: s + 1,
          instrument: 2,
          isDrum: true
        }));
      }
    }
    noteSequence.totalQuantizedSteps = this.numSteps;
    return noteSequence;
  }
};
var MultitrackConverter = class extends DataConverter {
  constructor(args) {
    super(args);
    this.SEGMENTED_BY_TRACK = true;
    this.stepsPerQuarter = args.stepsPerQuarter;
    this.totalSteps = args.totalSteps;
    this.numVelocityBins = args.numVelocityBins;
    this.minPitch = args.minPitch ? args.minPitch : MIN_MIDI_PITCH;
    this.maxPitch = args.maxPitch ? args.maxPitch : MAX_MIDI_PITCH;
    this.numPitches = this.maxPitch - this.minPitch + 1;
    this.performanceEventDepth = 2 * this.numPitches + this.totalSteps + this.numVelocityBins;
    this.numPrograms = MAX_MIDI_PROGRAM - MIN_MIDI_PROGRAM + 2;
    this.endToken = this.performanceEventDepth + this.numPrograms;
    this.depth = this.endToken + 1;
    this.endTensor = tidy(() => oneHot(tensor1d([this.endToken], "int32"), this.depth).as1D());
  }
  trackToTensor(track) {
    const maxEventsPerTrack = this.numSteps / this.numSegments;
    let tokens = void 0;
    if (track) {
      while (track.events.length > maxEventsPerTrack - 2) {
        track.events.pop();
      }
      tokens = buffer([track.events.length + 2], "int32");
      tokens.set(this.performanceEventDepth + (track.isDrum ? this.numPrograms - 1 : track.program), 0);
      track.events.forEach((event, index) => {
        switch (event.type) {
          case "note-on":
            tokens.set(event.pitch - this.minPitch, index + 1);
            break;
          case "note-off":
            tokens.set(this.numPitches + event.pitch - this.minPitch, index + 1);
            break;
          case "time-shift":
            tokens.set(2 * this.numPitches + event.steps - 1, index + 1);
            break;
          case "velocity-change":
            tokens.set(2 * this.numPitches + this.totalSteps + event.velocityBin - 1, index + 1);
            break;
          default:
            throw new Error(`Unrecognized performance event: ${event}`);
        }
      });
      tokens.set(this.endToken, track.events.length + 1);
    } else {
      tokens = buffer([1], "int32", new Int32Array([this.endToken]));
    }
    return tidy(() => {
      const oh = oneHot(tokens.toTensor(), this.depth);
      return oh.pad([[0, maxEventsPerTrack - oh.shape[0]], [0, 0]]);
    });
  }
  toTensor(noteSequence) {
    assertIsRelativeQuantizedSequence(noteSequence);
    if (noteSequence.quantizationInfo.stepsPerQuarter !== this.stepsPerQuarter) {
      throw new Error(`Steps per quarter note mismatch: ${noteSequence.quantizationInfo.stepsPerQuarter} != ${this.stepsPerQuarter}`);
    }
    const seq = clone(noteSequence);
    seq.notes = noteSequence.notes.filter((note) => note.pitch >= this.minPitch && note.pitch <= this.maxPitch);
    const instruments = new Set(seq.notes.map((note) => note.instrument));
    const tracks = Array.from(instruments).map((instrument) => Performance.fromNoteSequence(seq, this.totalSteps, this.numVelocityBins, instrument));
    const sortedTracks = tracks.sort((a, b) => b.isDrum ? -1 : a.isDrum ? 1 : a.program - b.program);
    while (sortedTracks.length > this.numSegments) {
      sortedTracks.pop();
    }
    sortedTracks.forEach((track) => track.setNumSteps(this.totalSteps));
    while (sortedTracks.length < this.numSegments) {
      sortedTracks.push(void 0);
    }
    return tidy(() => concat(sortedTracks.map((track) => this.trackToTensor(track)), 0));
  }
  tokensToTrack(tokens) {
    const idx = tokens.indexOf(this.endToken);
    const endIndex = idx >= 0 ? idx : tokens.length;
    const trackTokens = tokens.slice(0, endIndex);
    const eventTokens = trackTokens.filter((token) => token < this.performanceEventDepth);
    const programTokens = trackTokens.filter((token) => token >= this.performanceEventDepth);
    const [program, isDrum] = programTokens.length ? programTokens[0] - this.performanceEventDepth < this.numPrograms - 1 ? [programTokens[0] - this.performanceEventDepth, false] : [0, true] : [0, false];
    const events = Array.from(eventTokens).map((token) => {
      if (token < this.numPitches) {
        return { type: "note-on", pitch: this.minPitch + token };
      } else if (token < 2 * this.numPitches) {
        return {
          type: "note-off",
          pitch: this.minPitch + token - this.numPitches
        };
      } else if (token < 2 * this.numPitches + this.totalSteps) {
        return {
          type: "time-shift",
          steps: token - 2 * this.numPitches + 1
        };
      } else if (token < 2 * this.numPitches + this.totalSteps + this.numVelocityBins) {
        return {
          type: "velocity-change",
          velocityBin: token - 2 * this.numPitches - this.totalSteps + 1
        };
      } else {
        throw new Error(`Invalid performance event token: ${token}`);
      }
    });
    return new Performance(events, this.totalSteps, this.numVelocityBins, program, isDrum);
  }
  async toNoteSequence(oh, stepsPerQuarter = this.stepsPerQuarter, qpm) {
    const noteSequence = createQuantizedNoteSequence(stepsPerQuarter, qpm);
    noteSequence.totalQuantizedSteps = this.totalSteps;
    const tensors = tidy(() => split(oh.argMax(1), this.numSegments));
    const tracks = await Promise.all(tensors.map(async (tensor2) => {
      const tokens = await tensor2.data();
      const track = this.tokensToTrack(tokens);
      tensor2.dispose();
      return track;
    }));
    tracks.forEach((track, instrument) => {
      track.setNumSteps(this.totalSteps);
      noteSequence.notes.push(...track.toNoteSequence(instrument).notes);
    });
    return noteSequence;
  }
};
var GrooveConverter = class extends DataConverter {
  constructor(args) {
    super(args);
    this.TAPIFY_CHANNEL = 3;
    this.stepsPerQuarter = args.stepsPerQuarter || DEFAULT_STEPS_PER_QUARTER;
    this.pitchClasses = args.pitchClasses || DEFAULT_DRUM_PITCH_CLASSES;
    this.pitchToClass = /* @__PURE__ */ new Map();
    for (let c = 0; c < this.pitchClasses.length; ++c) {
      this.pitchClasses[c].forEach((p) => {
        this.pitchToClass.set(p, c);
      });
    }
    this.humanize = args.humanize || false;
    this.tapify = args.tapify || false;
    this.splitInstruments = args.splitInstruments || false;
    this.depth = 3;
  }
  toTensor(ns) {
    const qns = isRelativeQuantizedSequence(ns) ? ns : quantizeNoteSequence(ns, this.stepsPerQuarter);
    const numSteps = this.numSteps;
    const qpm = qns.tempos && qns.tempos.length ? qns.tempos[0].qpm : DEFAULT_QUARTERS_PER_MINUTE;
    const stepLength = 60 / qpm / this.stepsPerQuarter;
    const stepNotes = [];
    for (let i = 0; i < numSteps; ++i) {
      stepNotes.push(/* @__PURE__ */ new Map());
    }
    qns.notes.forEach((n) => {
      if (!(this.tapify || this.pitchToClass.has(n.pitch))) {
        return;
      }
      const s = n.quantizedStartStep;
      if (s >= stepNotes.length) {
        throw Error(`Model does not support sequences with more than ${numSteps} steps (${numSteps * stepLength} seconds at qpm ${qpm}).`);
      }
      const d = this.tapify ? this.TAPIFY_CHANNEL : this.pitchToClass.get(n.pitch);
      if (!stepNotes[s].has(d) || stepNotes[s].get(d).velocity < n.velocity) {
        stepNotes[s].set(d, n);
      }
    });
    const numDrums = this.pitchClasses.length;
    const hitVectors = buffer([numSteps, numDrums]);
    const velocityVectors = buffer([numSteps, numDrums]);
    const offsetVectors = buffer([numSteps, numDrums]);
    function getOffset(n) {
      if (n.startTime === void 0) {
        return 0;
      }
      const tOnset = n.startTime;
      const qOnset = n.quantizedStartStep * stepLength;
      return 2 * (qOnset - tOnset) / stepLength;
    }
    for (let s = 0; s < numSteps; ++s) {
      for (let d = 0; d < numDrums; ++d) {
        const note = stepNotes[s].get(d);
        hitVectors.set(note ? 1 : 0, s, d);
        if (!this.humanize && !this.tapify) {
          velocityVectors.set(note ? note.velocity / MAX_MIDI_VELOCITY : 0, s, d);
        }
        if (!this.humanize) {
          offsetVectors.set(note ? getOffset(note) : 0, s, d);
        }
      }
    }
    return tidy(() => {
      const hits = hitVectors.toTensor();
      const velocities = velocityVectors.toTensor();
      const offsets = offsetVectors.toTensor();
      const outLength = this.splitInstruments ? numSteps * numDrums : numSteps;
      return concat([
        hits.as2D(outLength, -1),
        velocities.as2D(outLength, -1),
        offsets.as2D(outLength, -1)
      ], 1);
    });
  }
  async toNoteSequence(t, stepsPerQuarter, qpm = DEFAULT_QUARTERS_PER_MINUTE) {
    if (stepsPerQuarter && stepsPerQuarter !== this.stepsPerQuarter) {
      throw Error("`stepsPerQuarter` is set by the model.");
    }
    stepsPerQuarter = this.stepsPerQuarter;
    const numSteps = this.splitInstruments ? t.shape[0] / this.pitchClasses.length : t.shape[0];
    const stepLength = 60 / qpm / this.stepsPerQuarter;
    const ns = NoteSequence.create({ totalTime: numSteps * stepLength, tempos: [{ qpm }] });
    const results = await t.data();
    function clip(v, min2, max2) {
      return Math.min(Math.max(v, min2), max2);
    }
    const numDrums = this.pitchClasses.length;
    for (let s = 0; s < numSteps; ++s) {
      const stepResults = results.slice(s * numDrums * this.depth, (s + 1) * numDrums * this.depth);
      for (let d = 0; d < numDrums; ++d) {
        const hitOutput = stepResults[this.splitInstruments ? d * this.depth : d];
        const velI = this.splitInstruments ? d * this.depth + 1 : numDrums + d;
        const velOutput = stepResults[velI];
        const offsetI = this.splitInstruments ? d * this.depth + 2 : 2 * numDrums + d;
        const offsetOutput = stepResults[offsetI];
        if (hitOutput > 0.5) {
          const velocity = clip(Math.round(velOutput * MAX_MIDI_VELOCITY), MIN_MIDI_VELOCITY, MAX_MIDI_VELOCITY);
          const offset = clip(offsetOutput / 2, -0.5, 0.5);
          ns.notes.push(NoteSequence.Note.create({
            pitch: this.pitchClasses[d][0],
            startTime: (s - offset) * stepLength,
            endTime: (s - offset + 1) * stepLength,
            velocity,
            isDrum: true
          }));
        }
      }
    }
    return ns;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  AMOscillator: () => AMOscillator,
  AMSynth: () => AMSynth,
  Abs: () => Abs,
  Add: () => Add,
  AmplitudeEnvelope: () => AmplitudeEnvelope,
  Analyser: () => Analyser,
  AudioToGain: () => AudioToGain,
  AutoFilter: () => AutoFilter,
  AutoPanner: () => AutoPanner,
  AutoWah: () => AutoWah,
  BaseContext: () => BaseContext,
  BiquadFilter: () => BiquadFilter,
  BitCrusher: () => BitCrusher,
  Buffer: () => Buffer,
  BufferSource: () => BufferSource,
  Buffers: () => Buffers,
  Channel: () => Channel,
  Chebyshev: () => Chebyshev,
  Chorus: () => Chorus,
  Clock: () => Clock,
  Compressor: () => Compressor,
  Context: () => Context,
  Convolver: () => Convolver,
  CrossFade: () => CrossFade,
  DCMeter: () => DCMeter,
  Delay: () => Delay,
  Destination: () => Destination,
  Distortion: () => Distortion,
  Draw: () => Draw,
  DuoSynth: () => DuoSynth,
  EQ3: () => EQ3,
  Emitter: () => Emitter,
  Envelope: () => Envelope,
  FFT: () => FFT,
  FMOscillator: () => FMOscillator,
  FMSynth: () => FMSynth,
  FatOscillator: () => FatOscillator,
  FeedbackCombFilter: () => FeedbackCombFilter,
  FeedbackDelay: () => FeedbackDelay,
  Filter: () => Filter,
  Follower: () => Follower,
  Freeverb: () => Freeverb,
  Frequency: () => Frequency,
  FrequencyClass: () => FrequencyClass,
  FrequencyEnvelope: () => FrequencyEnvelope,
  FrequencyShifter: () => FrequencyShifter,
  Gain: () => Gain,
  GainToAudio: () => GainToAudio,
  Gate: () => Gate,
  GrainPlayer: () => GrainPlayer,
  GreaterThan: () => GreaterThan,
  GreaterThanZero: () => GreaterThanZero,
  IntervalTimeline: () => IntervalTimeline,
  JCReverb: () => JCReverb,
  LFO: () => LFO,
  Limiter: () => Limiter,
  Listener: () => Listener,
  Loop: () => Loop,
  LowpassCombFilter: () => LowpassCombFilter,
  Master: () => Master,
  MembraneSynth: () => MembraneSynth,
  Merge: () => Merge,
  MetalSynth: () => MetalSynth,
  Meter: () => Meter,
  MidSideCompressor: () => MidSideCompressor,
  MidSideMerge: () => MidSideMerge,
  MidSideSplit: () => MidSideSplit,
  Midi: () => Midi,
  MidiClass: () => MidiClass,
  Mono: () => Mono,
  MonoSynth: () => MonoSynth,
  MultibandCompressor: () => MultibandCompressor,
  MultibandSplit: () => MultibandSplit,
  Multiply: () => Multiply,
  Negate: () => Negate,
  Noise: () => Noise,
  NoiseSynth: () => NoiseSynth,
  Offline: () => Offline,
  OfflineContext: () => OfflineContext,
  OmniOscillator: () => OmniOscillator,
  OnePoleFilter: () => OnePoleFilter,
  Oscillator: () => Oscillator,
  PWMOscillator: () => PWMOscillator,
  PanVol: () => PanVol,
  Panner: () => Panner,
  Panner3D: () => Panner3D,
  Param: () => Param,
  Part: () => Part,
  Pattern: () => Pattern,
  Phaser: () => Phaser,
  PingPongDelay: () => PingPongDelay,
  PitchShift: () => PitchShift,
  Player: () => Player,
  Players: () => Players,
  PluckSynth: () => PluckSynth,
  PolySynth: () => PolySynth,
  Pow: () => Pow,
  PulseOscillator: () => PulseOscillator,
  Recorder: () => Recorder,
  Reverb: () => Reverb,
  Sampler: () => Sampler,
  Scale: () => Scale,
  ScaleExp: () => ScaleExp,
  Sequence: () => Sequence,
  Signal: () => Signal,
  Solo: () => Solo,
  Split: () => Split,
  StateTimeline: () => StateTimeline,
  StereoWidener: () => StereoWidener,
  Subtract: () => Subtract,
  SyncedSignal: () => SyncedSignal,
  Synth: () => Synth,
  Ticks: () => Ticks,
  TicksClass: () => TicksClass,
  Time: () => Time,
  TimeClass: () => TimeClass,
  Timeline: () => Timeline,
  ToneAudioBuffer: () => ToneAudioBuffer,
  ToneAudioBuffers: () => ToneAudioBuffers,
  ToneAudioNode: () => ToneAudioNode,
  ToneBufferSource: () => ToneBufferSource,
  ToneEvent: () => ToneEvent,
  ToneOscillatorNode: () => ToneOscillatorNode,
  Transport: () => Transport,
  TransportTime: () => TransportTime,
  TransportTimeClass: () => TransportTimeClass,
  Tremolo: () => Tremolo,
  Unit: () => Units_exports,
  UserMedia: () => UserMedia,
  Vibrato: () => Vibrato,
  Volume: () => Volume,
  WaveShaper: () => WaveShaper,
  Waveform: () => Waveform,
  Zero: () => Zero,
  connect: () => connect,
  connectSeries: () => connectSeries,
  connectSignal: () => connectSignal,
  context: () => context,
  dbToGain: () => dbToGain,
  debug: () => Debug_exports,
  defaultArg: () => defaultArg,
  disconnect: () => disconnect,
  fanIn: () => fanIn,
  ftom: () => ftom,
  gainToDb: () => gainToDb,
  getContext: () => getContext,
  getDestination: () => getDestination,
  getDraw: () => getDraw,
  getListener: () => getListener,
  getTransport: () => getTransport,
  immediate: () => immediate,
  intervalToFrequencyRatio: () => intervalToFrequencyRatio,
  isArray: () => isArray,
  isBoolean: () => isBoolean,
  isDefined: () => isDefined,
  isFunction: () => isFunction,
  isNote: () => isNote,
  isNumber: () => isNumber,
  isObject: () => isObject,
  isString: () => isString,
  isUndef: () => isUndef,
  loaded: () => loaded,
  mtof: () => mtof,
  now: () => now2,
  optionsFromArguments: () => optionsFromArguments,
  setContext: () => setContext,
  start: () => start,
  supported: () => isSupported,
  version: () => version
});

// node_modules/@magenta/music/node_modules/tone/build/esm/version.js
var version = "14.9.17";

// node_modules/@magenta/music/node_modules/tone/build/esm/core/util/Debug.js
var Debug_exports = {};
__export(Debug_exports, {
  assert: () => assert,
  assertContextRunning: () => assertContextRunning,
  assertRange: () => assertRange,
  assertUsedScheduleTime: () => assertUsedScheduleTime,
  enterScheduledCallback: () => enterScheduledCallback,
  log: () => log3,
  setLogger: () => setLogger,
  warn: () => warn
});

// node_modules/@magenta/music/node_modules/tone/build/esm/core/util/TypeCheck.js
function isUndef(arg) {
  return arg === void 0;
}
function isDefined(arg) {
  return arg !== void 0;
}
function isFunction(arg) {
  return typeof arg === "function";
}
function isNumber(arg) {
  return typeof arg === "number";
}
function isObject(arg) {
  return Object.prototype.toString.call(arg) === "[object Object]" && arg.constructor === Object;
}
function isBoolean(arg) {
  return typeof arg === "boolean";
}
function isArray(arg) {
  return Array.isArray(arg);
}
function isString(arg) {
  return typeof arg === "string";
}
function isNote(arg) {
  return isString(arg) && /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i.test(arg);
}

// node_modules/@magenta/music/node_modules/tone/build/esm/core/util/Debug.js
function assert(statement, error) {
  if (!statement) {
    throw new Error(error);
  }
}
function assertRange(value, gte, lte = Infinity) {
  if (!(gte <= value && value <= lte)) {
    throw new RangeError(`Value must be within [${gte}, ${lte}], got: ${value}`);
  }
}
function assertContextRunning(context2) {
  if (!context2.isOffline && context2.state !== "running") {
    warn('The AudioContext is "suspended". Invoke Tone.start() from a user action to start the audio.');
  }
}
var isInsideScheduledCallback = false;
var printedScheduledWarning = false;
function enterScheduledCallback(insideCallback) {
  isInsideScheduledCallback = insideCallback;
}
function assertUsedScheduleTime(time2) {
  if (isUndef(time2) && isInsideScheduledCallback && !printedScheduledWarning) {
    printedScheduledWarning = true;
    warn("Events scheduled inside of scheduled callbacks should use the passed in scheduling time. See https://github.com/Tonejs/Tone.js/wiki/Accurate-Timing");
  }
}
var defaultLogger = console;
function setLogger(logger) {
  defaultLogger = logger;
}
function log3(...args) {
  defaultLogger.log(...args);
}
function warn(...args) {
  defaultLogger.warn(...args);
}

// node_modules/@magenta/music/node_modules/tone/build/esm/core/context/AudioContext.js
function createAudioContext(options) {
  return new audioContextConstructor(options);
}
function createOfflineAudioContext(channels, length, sampleRate) {
  return new offlineAudioContextConstructor(channels, length, sampleRate);
}
var theWindow = typeof self === "object" ? self : null;
var hasAudioContext = theWindow && (theWindow.hasOwnProperty("AudioContext") || theWindow.hasOwnProperty("webkitAudioContext"));
function createAudioWorkletNode(context2, name, options) {
  assert(isDefined(audioWorkletNodeConstructor), "This node only works in a secure context (https or localhost)");
  return new audioWorkletNodeConstructor(context2, name, options);
}

// node_modules/@magenta/music/node_modules/tone/build/esm/core/clock/Ticker.js
var Ticker = class {
  constructor(callback, type, updateInterval, contextSampleRate) {
    this._callback = callback;
    this._type = type;
    this._minimumUpdateInterval = Math.max(128 / (contextSampleRate || 44100), 1e-3);
    this.updateInterval = updateInterval;
    this._createClock();
  }
  /**
   * Generate a web worker
   */
  _createWorker() {
    const blob = new Blob([
      /* javascript */
      `
			// the initial timeout time
			let timeoutTime =  ${(this._updateInterval * 1e3).toFixed(1)};
			// onmessage callback
			self.onmessage = function(msg){
				timeoutTime = parseInt(msg.data);
			};
			// the tick function which posts a message
			// and schedules a new tick
			function tick(){
				setTimeout(tick, timeoutTime);
				self.postMessage('tick');
			}
			// call tick initially
			tick();
			`
    ], { type: "text/javascript" });
    const blobUrl = URL.createObjectURL(blob);
    const worker = new Worker(blobUrl);
    worker.onmessage = this._callback.bind(this);
    this._worker = worker;
  }
  /**
   * Create a timeout loop
   */
  _createTimeout() {
    this._timeout = setTimeout(() => {
      this._createTimeout();
      this._callback();
    }, this._updateInterval * 1e3);
  }
  /**
   * Create the clock source.
   */
  _createClock() {
    if (this._type === "worker") {
      try {
        this._createWorker();
      } catch (e) {
        this._type = "timeout";
        this._createClock();
      }
    } else if (this._type === "timeout") {
      this._createTimeout();
    }
  }
  /**
   * Clean up the current clock source
   */
  _disposeClock() {
    if (this._timeout) {
      clearTimeout(this._timeout);
    }
    if (this._worker) {
      this._worker.terminate();
      this._worker.onmessage = null;
    }
  }
  /**
   * The rate in seconds the ticker will update
   */
  get updateInterval() {
    return this._updateInterval;
  }
  set updateInterval(interval) {
    var _a;
    this._updateInterval = Math.max(interval, this._minimumUpdateInterval);
    if (this._type === "worker") {
      (_a = this._worker) === null || _a === void 0 ? void 0 : _a.postMessage(this._updateInterval * 1e3);
    }
  }
  /**
   * The type of the ticker, either a worker or a timeout
   */
  get type() {
    return this._type;
  }
  set type(type) {
    this._disposeClock();
    this._type = type;
    this._createClock();
  }
  /**
   * Clean up
   */
  dispose() {
    this._disposeClock();
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/core/util/AdvancedTypeCheck.js
function isAudioParam(arg) {
  return isAnyAudioParam(arg);
}
function isAudioNode(arg) {
  return isAnyAudioNode(arg);
}
function isOfflineAudioContext(arg) {
  return isAnyOfflineAudioContext(arg);
}
function isAudioContext(arg) {
  return isAnyAudioContext(arg);
}
function isAudioBuffer(arg) {
  return arg instanceof audioBufferConstructor;
}

// node_modules/@magenta/music/node_modules/tone/build/esm/core/util/Defaults.js
function noCopy(key, arg) {
  return key === "value" || isAudioParam(arg) || isAudioNode(arg) || isAudioBuffer(arg);
}
function deepMerge(target, ...sources) {
  if (!sources.length) {
    return target;
  }
  const source = sources.shift();
  if (isObject(target) && isObject(source)) {
    for (const key in source) {
      if (noCopy(key, source[key])) {
        target[key] = source[key];
      } else if (isObject(source[key])) {
        if (!target[key]) {
          Object.assign(target, { [key]: {} });
        }
        deepMerge(target[key], source[key]);
      } else {
        Object.assign(target, { [key]: source[key] });
      }
    }
  }
  return deepMerge(target, ...sources);
}
function deepEquals(arrayA, arrayB) {
  return arrayA.length === arrayB.length && arrayA.every((element, index) => arrayB[index] === element);
}
function optionsFromArguments(defaults, argsArray, keys = [], objKey) {
  const opts = {};
  const args = Array.from(argsArray);
  if (isObject(args[0]) && objKey && !Reflect.has(args[0], objKey)) {
    const partOfDefaults = Object.keys(args[0]).some((key) => Reflect.has(defaults, key));
    if (!partOfDefaults) {
      deepMerge(opts, { [objKey]: args[0] });
      keys.splice(keys.indexOf(objKey), 1);
      args.shift();
    }
  }
  if (args.length === 1 && isObject(args[0])) {
    deepMerge(opts, args[0]);
  } else {
    for (let i = 0; i < keys.length; i++) {
      if (isDefined(args[i])) {
        opts[keys[i]] = args[i];
      }
    }
  }
  return deepMerge(defaults, opts);
}
function getDefaultsFromInstance(instance) {
  return instance.constructor.getDefaults();
}
function defaultArg(given, fallback) {
  if (isUndef(given)) {
    return fallback;
  } else {
    return given;
  }
}
function omitFromObject(obj, omit) {
  omit.forEach((prop) => {
    if (Reflect.has(obj, prop)) {
      delete obj[prop];
    }
  });
  return obj;
}

// node_modules/@magenta/music/node_modules/tone/build/esm/core/Tone.js
var Tone = class {
  constructor() {
    this.debug = false;
    this._wasDisposed = false;
  }
  /**
   * Returns all of the default options belonging to the class.
   */
  static getDefaults() {
    return {};
  }
  /**
   * Prints the outputs to the console log for debugging purposes.
   * Prints the contents only if either the object has a property
   * called `debug` set to true, or a variable called TONE_DEBUG_CLASS
   * is set to the name of the class.
   * @example
   * const osc = new Tone.Oscillator();
   * // prints all logs originating from this oscillator
   * osc.debug = true;
   * // calls to start/stop will print in the console
   * osc.start();
   */
  log(...args) {
    if (this.debug || theWindow && this.toString() === theWindow.TONE_DEBUG_CLASS) {
      log3(this, ...args);
    }
  }
  /**
   * disconnect and dispose.
   */
  dispose() {
    this._wasDisposed = true;
    return this;
  }
  /**
   * Indicates if the instance was disposed. 'Disposing' an
   * instance means that all of the Web Audio nodes that were
   * created for the instance are disconnected and freed for garbage collection.
   */
  get disposed() {
    return this._wasDisposed;
  }
  /**
   * Convert the class to a string
   * @example
   * const osc = new Tone.Oscillator();
   * console.log(osc.toString());
   */
  toString() {
    return this.name;
  }
};
Tone.version = version;

// node_modules/@magenta/music/node_modules/tone/build/esm/core/util/Math.js
var EPSILON = 1e-6;
function GT(a, b) {
  return a > b + EPSILON;
}
function GTE(a, b) {
  return GT(a, b) || EQ(a, b);
}
function LT(a, b) {
  return a + EPSILON < b;
}
function EQ(a, b) {
  return Math.abs(a - b) < EPSILON;
}
function clamp(value, min2, max2) {
  return Math.max(Math.min(value, max2), min2);
}

// node_modules/@magenta/music/node_modules/tone/build/esm/core/util/Timeline.js
var Timeline = class _Timeline extends Tone {
  constructor() {
    super();
    this.name = "Timeline";
    this._timeline = [];
    const options = optionsFromArguments(_Timeline.getDefaults(), arguments, ["memory"]);
    this.memory = options.memory;
    this.increasing = options.increasing;
  }
  static getDefaults() {
    return {
      memory: Infinity,
      increasing: false
    };
  }
  /**
   * The number of items in the timeline.
   */
  get length() {
    return this._timeline.length;
  }
  /**
   * Insert an event object onto the timeline. Events must have a "time" attribute.
   * @param event  The event object to insert into the timeline.
   */
  add(event) {
    assert(Reflect.has(event, "time"), "Timeline: events must have a time attribute");
    event.time = event.time.valueOf();
    if (this.increasing && this.length) {
      const lastValue = this._timeline[this.length - 1];
      assert(GTE(event.time, lastValue.time), "The time must be greater than or equal to the last scheduled time");
      this._timeline.push(event);
    } else {
      const index = this._search(event.time);
      this._timeline.splice(index + 1, 0, event);
    }
    if (this.length > this.memory) {
      const diff = this.length - this.memory;
      this._timeline.splice(0, diff);
    }
    return this;
  }
  /**
   * Remove an event from the timeline.
   * @param  {Object}  event  The event object to remove from the list.
   * @returns {Timeline} this
   */
  remove(event) {
    const index = this._timeline.indexOf(event);
    if (index !== -1) {
      this._timeline.splice(index, 1);
    }
    return this;
  }
  /**
   * Get the nearest event whose time is less than or equal to the given time.
   * @param  time  The time to query.
   */
  get(time2, param = "time") {
    const index = this._search(time2, param);
    if (index !== -1) {
      return this._timeline[index];
    } else {
      return null;
    }
  }
  /**
   * Return the first event in the timeline without removing it
   * @returns {Object} The first event object
   */
  peek() {
    return this._timeline[0];
  }
  /**
   * Return the first event in the timeline and remove it
   */
  shift() {
    return this._timeline.shift();
  }
  /**
   * Get the event which is scheduled after the given time.
   * @param  time  The time to query.
   */
  getAfter(time2, param = "time") {
    const index = this._search(time2, param);
    if (index + 1 < this._timeline.length) {
      return this._timeline[index + 1];
    } else {
      return null;
    }
  }
  /**
   * Get the event before the event at the given time.
   * @param  time  The time to query.
   */
  getBefore(time2) {
    const len = this._timeline.length;
    if (len > 0 && this._timeline[len - 1].time < time2) {
      return this._timeline[len - 1];
    }
    const index = this._search(time2);
    if (index - 1 >= 0) {
      return this._timeline[index - 1];
    } else {
      return null;
    }
  }
  /**
   * Cancel events at and after the given time
   * @param  after  The time to query.
   */
  cancel(after) {
    if (this._timeline.length > 1) {
      let index = this._search(after);
      if (index >= 0) {
        if (EQ(this._timeline[index].time, after)) {
          for (let i = index; i >= 0; i--) {
            if (EQ(this._timeline[i].time, after)) {
              index = i;
            } else {
              break;
            }
          }
          this._timeline = this._timeline.slice(0, index);
        } else {
          this._timeline = this._timeline.slice(0, index + 1);
        }
      } else {
        this._timeline = [];
      }
    } else if (this._timeline.length === 1) {
      if (GTE(this._timeline[0].time, after)) {
        this._timeline = [];
      }
    }
    return this;
  }
  /**
   * Cancel events before or equal to the given time.
   * @param  time  The time to cancel before.
   */
  cancelBefore(time2) {
    const index = this._search(time2);
    if (index >= 0) {
      this._timeline = this._timeline.slice(index + 1);
    }
    return this;
  }
  /**
   * Returns the previous event if there is one. null otherwise
   * @param  event The event to find the previous one of
   * @return The event right before the given event
   */
  previousEvent(event) {
    const index = this._timeline.indexOf(event);
    if (index > 0) {
      return this._timeline[index - 1];
    } else {
      return null;
    }
  }
  /**
   * Does a binary search on the timeline array and returns the
   * nearest event index whose time is after or equal to the given time.
   * If a time is searched before the first index in the timeline, -1 is returned.
   * If the time is after the end, the index of the last item is returned.
   */
  _search(time2, param = "time") {
    if (this._timeline.length === 0) {
      return -1;
    }
    let beginning = 0;
    const len = this._timeline.length;
    let end = len;
    if (len > 0 && this._timeline[len - 1][param] <= time2) {
      return len - 1;
    }
    while (beginning < end) {
      let midPoint = Math.floor(beginning + (end - beginning) / 2);
      const event = this._timeline[midPoint];
      const nextEvent = this._timeline[midPoint + 1];
      if (EQ(event[param], time2)) {
        for (let i = midPoint; i < this._timeline.length; i++) {
          const testEvent = this._timeline[i];
          if (EQ(testEvent[param], time2)) {
            midPoint = i;
          } else {
            break;
          }
        }
        return midPoint;
      } else if (LT(event[param], time2) && GT(nextEvent[param], time2)) {
        return midPoint;
      } else if (GT(event[param], time2)) {
        end = midPoint;
      } else {
        beginning = midPoint + 1;
      }
    }
    return -1;
  }
  /**
   * Internal iterator. Applies extra safety checks for
   * removing items from the array.
   */
  _iterate(callback, lowerBound = 0, upperBound = this._timeline.length - 1) {
    this._timeline.slice(lowerBound, upperBound + 1).forEach(callback);
  }
  /**
   * Iterate over everything in the array
   * @param  callback The callback to invoke with every item
   */
  forEach(callback) {
    this._iterate(callback);
    return this;
  }
  /**
   * Iterate over everything in the array at or before the given time.
   * @param  time The time to check if items are before
   * @param  callback The callback to invoke with every item
   */
  forEachBefore(time2, callback) {
    const upperBound = this._search(time2);
    if (upperBound !== -1) {
      this._iterate(callback, 0, upperBound);
    }
    return this;
  }
  /**
   * Iterate over everything in the array after the given time.
   * @param  time The time to check if items are before
   * @param  callback The callback to invoke with every item
   */
  forEachAfter(time2, callback) {
    const lowerBound = this._search(time2);
    this._iterate(callback, lowerBound + 1);
    return this;
  }
  /**
   * Iterate over everything in the array between the startTime and endTime.
   * The timerange is inclusive of the startTime, but exclusive of the endTime.
   * range = [startTime, endTime).
   * @param  startTime The time to check if items are before
   * @param  endTime The end of the test interval.
   * @param  callback The callback to invoke with every item
   */
  forEachBetween(startTime, endTime, callback) {
    let lowerBound = this._search(startTime);
    let upperBound = this._search(endTime);
    if (lowerBound !== -1 && upperBound !== -1) {
      if (this._timeline[lowerBound].time !== startTime) {
        lowerBound += 1;
      }
      if (this._timeline[upperBound].time === endTime) {
        upperBound -= 1;
      }
      this._iterate(callback, lowerBound, upperBound);
    } else if (lowerBound === -1) {
      this._iterate(callback, 0, upperBound);
    }
    return this;
  }
  /**
   * Iterate over everything in the array at or after the given time. Similar to
   * forEachAfter, but includes the item(s) at the given time.
   * @param  time The time to check if items are before
   * @param  callback The callback to invoke with every item
   */
  forEachFrom(time2, callback) {
    let lowerBound = this._search(time2);
    while (lowerBound >= 0 && this._timeline[lowerBound].time >= time2) {
      lowerBound--;
    }
    this._iterate(callback, lowerBound + 1);
    return this;
  }
  /**
   * Iterate over everything in the array at the given time
   * @param  time The time to check if items are before
   * @param  callback The callback to invoke with every item
   */
  forEachAtTime(time2, callback) {
    const upperBound = this._search(time2);
    if (upperBound !== -1 && EQ(this._timeline[upperBound].time, time2)) {
      let lowerBound = upperBound;
      for (let i = upperBound; i >= 0; i--) {
        if (EQ(this._timeline[i].time, time2)) {
          lowerBound = i;
        } else {
          break;
        }
      }
      this._iterate((event) => {
        callback(event);
      }, lowerBound, upperBound);
    }
    return this;
  }
  /**
   * Clean up.
   */
  dispose() {
    super.dispose();
    this._timeline = [];
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/core/context/ContextInitialization.js
var notifyNewContext = [];
function onContextInit(cb) {
  notifyNewContext.push(cb);
}
function initializeContext(ctx) {
  notifyNewContext.forEach((cb) => cb(ctx));
}
var notifyCloseContext = [];
function onContextClose(cb) {
  notifyCloseContext.push(cb);
}
function closeContext(ctx) {
  notifyCloseContext.forEach((cb) => cb(ctx));
}

// node_modules/@magenta/music/node_modules/tone/build/esm/core/util/Emitter.js
var Emitter = class _Emitter extends Tone {
  constructor() {
    super(...arguments);
    this.name = "Emitter";
  }
  /**
   * Bind a callback to a specific event.
   * @param  event     The name of the event to listen for.
   * @param  callback  The callback to invoke when the event is emitted
   */
  on(event, callback) {
    const events = event.split(/\W+/);
    events.forEach((eventName) => {
      if (isUndef(this._events)) {
        this._events = {};
      }
      if (!this._events.hasOwnProperty(eventName)) {
        this._events[eventName] = [];
      }
      this._events[eventName].push(callback);
    });
    return this;
  }
  /**
   * Bind a callback which is only invoked once
   * @param  event     The name of the event to listen for.
   * @param  callback  The callback to invoke when the event is emitted
   */
  once(event, callback) {
    const boundCallback = (...args) => {
      callback(...args);
      this.off(event, boundCallback);
    };
    this.on(event, boundCallback);
    return this;
  }
  /**
   * Remove the event listener.
   * @param  event     The event to stop listening to.
   * @param  callback  The callback which was bound to the event with Emitter.on.
   *                   If no callback is given, all callbacks events are removed.
   */
  off(event, callback) {
    const events = event.split(/\W+/);
    events.forEach((eventName) => {
      if (isUndef(this._events)) {
        this._events = {};
      }
      if (this._events.hasOwnProperty(eventName)) {
        if (isUndef(callback)) {
          this._events[eventName] = [];
        } else {
          const eventList = this._events[eventName];
          for (let i = eventList.length - 1; i >= 0; i--) {
            if (eventList[i] === callback) {
              eventList.splice(i, 1);
            }
          }
        }
      }
    });
    return this;
  }
  /**
   * Invoke all of the callbacks bound to the event
   * with any arguments passed in.
   * @param  event  The name of the event.
   * @param args The arguments to pass to the functions listening.
   */
  emit(event, ...args) {
    if (this._events) {
      if (this._events.hasOwnProperty(event)) {
        const eventList = this._events[event].slice(0);
        for (let i = 0, len = eventList.length; i < len; i++) {
          eventList[i].apply(this, args);
        }
      }
    }
    return this;
  }
  /**
   * Add Emitter functions (on/off/emit) to the object
   */
  static mixin(constr) {
    ["on", "once", "off", "emit"].forEach((name) => {
      const property = Object.getOwnPropertyDescriptor(_Emitter.prototype, name);
      Object.defineProperty(constr.prototype, name, property);
    });
  }
  /**
   * Clean up
   */
  dispose() {
    super.dispose();
    this._events = void 0;
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/core/context/BaseContext.js
var BaseContext = class extends Emitter {
  constructor() {
    super(...arguments);
    this.isOffline = false;
  }
  /*
   * This is a placeholder so that JSON.stringify does not throw an error
   * This matches what JSON.stringify(audioContext) returns on a native
   * audioContext instance.
   */
  toJSON() {
    return {};
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/core/context/Context.js
var Context = class _Context extends BaseContext {
  constructor() {
    var _a, _b;
    super();
    this.name = "Context";
    this._constants = /* @__PURE__ */ new Map();
    this._timeouts = new Timeline();
    this._timeoutIds = 0;
    this._initialized = false;
    this._closeStarted = false;
    this.isOffline = false;
    this._workletPromise = null;
    const options = optionsFromArguments(_Context.getDefaults(), arguments, [
      "context"
    ]);
    if (options.context) {
      this._context = options.context;
      this._latencyHint = ((_a = arguments[0]) === null || _a === void 0 ? void 0 : _a.latencyHint) || "";
    } else {
      this._context = createAudioContext({
        latencyHint: options.latencyHint
      });
      this._latencyHint = options.latencyHint;
    }
    this._ticker = new Ticker(this.emit.bind(this, "tick"), options.clockSource, options.updateInterval, this._context.sampleRate);
    this.on("tick", this._timeoutLoop.bind(this));
    this._context.onstatechange = () => {
      this.emit("statechange", this.state);
    };
    this[((_b = arguments[0]) === null || _b === void 0 ? void 0 : _b.hasOwnProperty("updateInterval")) ? "_lookAhead" : "lookAhead"] = options.lookAhead;
  }
  static getDefaults() {
    return {
      clockSource: "worker",
      latencyHint: "interactive",
      lookAhead: 0.1,
      updateInterval: 0.05
    };
  }
  /**
   * Finish setting up the context. **You usually do not need to do this manually.**
   */
  initialize() {
    if (!this._initialized) {
      initializeContext(this);
      this._initialized = true;
    }
    return this;
  }
  //---------------------------
  // BASE AUDIO CONTEXT METHODS
  //---------------------------
  createAnalyser() {
    return this._context.createAnalyser();
  }
  createOscillator() {
    return this._context.createOscillator();
  }
  createBufferSource() {
    return this._context.createBufferSource();
  }
  createBiquadFilter() {
    return this._context.createBiquadFilter();
  }
  createBuffer(numberOfChannels, length, sampleRate) {
    return this._context.createBuffer(numberOfChannels, length, sampleRate);
  }
  createChannelMerger(numberOfInputs) {
    return this._context.createChannelMerger(numberOfInputs);
  }
  createChannelSplitter(numberOfOutputs) {
    return this._context.createChannelSplitter(numberOfOutputs);
  }
  createConstantSource() {
    return this._context.createConstantSource();
  }
  createConvolver() {
    return this._context.createConvolver();
  }
  createDelay(maxDelayTime) {
    return this._context.createDelay(maxDelayTime);
  }
  createDynamicsCompressor() {
    return this._context.createDynamicsCompressor();
  }
  createGain() {
    return this._context.createGain();
  }
  createIIRFilter(feedForward, feedback) {
    return this._context.createIIRFilter(feedForward, feedback);
  }
  createPanner() {
    return this._context.createPanner();
  }
  createPeriodicWave(real, imag, constraints) {
    return this._context.createPeriodicWave(real, imag, constraints);
  }
  createStereoPanner() {
    return this._context.createStereoPanner();
  }
  createWaveShaper() {
    return this._context.createWaveShaper();
  }
  createMediaStreamSource(stream) {
    assert(isAudioContext(this._context), "Not available if OfflineAudioContext");
    const context2 = this._context;
    return context2.createMediaStreamSource(stream);
  }
  createMediaElementSource(element) {
    assert(isAudioContext(this._context), "Not available if OfflineAudioContext");
    const context2 = this._context;
    return context2.createMediaElementSource(element);
  }
  createMediaStreamDestination() {
    assert(isAudioContext(this._context), "Not available if OfflineAudioContext");
    const context2 = this._context;
    return context2.createMediaStreamDestination();
  }
  decodeAudioData(audioData) {
    return this._context.decodeAudioData(audioData);
  }
  /**
   * The current time in seconds of the AudioContext.
   */
  get currentTime() {
    return this._context.currentTime;
  }
  /**
   * The current time in seconds of the AudioContext.
   */
  get state() {
    return this._context.state;
  }
  /**
   * The current time in seconds of the AudioContext.
   */
  get sampleRate() {
    return this._context.sampleRate;
  }
  /**
   * The listener
   */
  get listener() {
    this.initialize();
    return this._listener;
  }
  set listener(l) {
    assert(!this._initialized, "The listener cannot be set after initialization.");
    this._listener = l;
  }
  /**
   * There is only one Transport per Context. It is created on initialization.
   */
  get transport() {
    this.initialize();
    return this._transport;
  }
  set transport(t) {
    assert(!this._initialized, "The transport cannot be set after initialization.");
    this._transport = t;
  }
  /**
   * This is the Draw object for the context which is useful for synchronizing the draw frame with the Tone.js clock.
   */
  get draw() {
    this.initialize();
    return this._draw;
  }
  set draw(d) {
    assert(!this._initialized, "Draw cannot be set after initialization.");
    this._draw = d;
  }
  /**
   * A reference to the Context's destination node.
   */
  get destination() {
    this.initialize();
    return this._destination;
  }
  set destination(d) {
    assert(!this._initialized, "The destination cannot be set after initialization.");
    this._destination = d;
  }
  /**
   * Create an audio worklet node from a name and options. The module
   * must first be loaded using {@link addAudioWorkletModule}.
   */
  createAudioWorkletNode(name, options) {
    return createAudioWorkletNode(this.rawContext, name, options);
  }
  /**
   * Add an AudioWorkletProcessor module
   * @param url The url of the module
   */
  addAudioWorkletModule(url) {
    return __awaiter(this, void 0, void 0, function* () {
      assert(isDefined(this.rawContext.audioWorklet), "AudioWorkletNode is only available in a secure context (https or localhost)");
      if (!this._workletPromise) {
        this._workletPromise = this.rawContext.audioWorklet.addModule(url);
      }
      yield this._workletPromise;
    });
  }
  /**
   * Returns a promise which resolves when all of the worklets have been loaded on this context
   */
  workletsAreReady() {
    return __awaiter(this, void 0, void 0, function* () {
      (yield this._workletPromise) ? this._workletPromise : Promise.resolve();
    });
  }
  //---------------------------
  // TICKER
  //---------------------------
  /**
   * How often the interval callback is invoked.
   * This number corresponds to how responsive the scheduling
   * can be. Setting to 0 will result in the lowest practial interval
   * based on context properties. context.updateInterval + context.lookAhead
   * gives you the total latency between scheduling an event and hearing it.
   */
  get updateInterval() {
    return this._ticker.updateInterval;
  }
  set updateInterval(interval) {
    this._ticker.updateInterval = interval;
  }
  /**
   * What the source of the clock is, either "worker" (default),
   * "timeout", or "offline" (none).
   */
  get clockSource() {
    return this._ticker.type;
  }
  set clockSource(type) {
    this._ticker.type = type;
  }
  /**
   * The amount of time into the future events are scheduled. Giving Web Audio
   * a short amount of time into the future to schedule events can reduce clicks and
   * improve performance. This value can be set to 0 to get the lowest latency.
   * Adjusting this value also affects the {@link updateInterval}.
   */
  get lookAhead() {
    return this._lookAhead;
  }
  set lookAhead(time2) {
    this._lookAhead = time2;
    this.updateInterval = time2 ? time2 / 2 : 0.01;
  }
  /**
   * The type of playback, which affects tradeoffs between audio
   * output latency and responsiveness.
   * In addition to setting the value in seconds, the latencyHint also
   * accepts the strings "interactive" (prioritizes low latency),
   * "playback" (prioritizes sustained playback), "balanced" (balances
   * latency and performance).
   * @example
   * // prioritize sustained playback
   * const context = new Tone.Context({ latencyHint: "playback" });
   * // set this context as the global Context
   * Tone.setContext(context);
   * // the global context is gettable with Tone.getContext()
   * console.log(Tone.getContext().latencyHint);
   */
  get latencyHint() {
    return this._latencyHint;
  }
  /**
   * The unwrapped AudioContext or OfflineAudioContext
   */
  get rawContext() {
    return this._context;
  }
  /**
   * The current audio context time plus a short {@link lookAhead}.
   * @example
   * setInterval(() => {
   * 	console.log("now", Tone.now());
   * }, 100);
   */
  now() {
    return this._context.currentTime + this._lookAhead;
  }
  /**
   * The current audio context time without the {@link lookAhead}.
   * In most cases it is better to use {@link now} instead of {@link immediate} since
   * with {@link now} the {@link lookAhead} is applied equally to _all_ components including internal components,
   * to making sure that everything is scheduled in sync. Mixing {@link now} and {@link immediate}
   * can cause some timing issues. If no lookAhead is desired, you can set the {@link lookAhead} to `0`.
   */
  immediate() {
    return this._context.currentTime;
  }
  /**
   * Starts the audio context from a suspended state. This is required
   * to initially start the AudioContext.
   * @see {@link start}
   */
  resume() {
    if (isAudioContext(this._context)) {
      return this._context.resume();
    } else {
      return Promise.resolve();
    }
  }
  /**
   * Close the context. Once closed, the context can no longer be used and
   * any AudioNodes created from the context will be silent.
   */
  close() {
    return __awaiter(this, void 0, void 0, function* () {
      if (isAudioContext(this._context) && this.state !== "closed" && !this._closeStarted) {
        this._closeStarted = true;
        yield this._context.close();
      }
      if (this._initialized) {
        closeContext(this);
      }
    });
  }
  /**
   * **Internal** Generate a looped buffer at some constant value.
   */
  getConstant(val) {
    if (this._constants.has(val)) {
      return this._constants.get(val);
    } else {
      const buffer2 = this._context.createBuffer(1, 128, this._context.sampleRate);
      const arr = buffer2.getChannelData(0);
      for (let i = 0; i < arr.length; i++) {
        arr[i] = val;
      }
      const constant = this._context.createBufferSource();
      constant.channelCount = 1;
      constant.channelCountMode = "explicit";
      constant.buffer = buffer2;
      constant.loop = true;
      constant.start(0);
      this._constants.set(val, constant);
      return constant;
    }
  }
  /**
   * Clean up. Also closes the audio context.
   */
  dispose() {
    super.dispose();
    this._ticker.dispose();
    this._timeouts.dispose();
    Object.keys(this._constants).map((val) => this._constants[val].disconnect());
    this.close();
    return this;
  }
  //---------------------------
  // TIMEOUTS
  //---------------------------
  /**
   * The private loop which keeps track of the context scheduled timeouts
   * Is invoked from the clock source
   */
  _timeoutLoop() {
    const now3 = this.now();
    let firstEvent = this._timeouts.peek();
    while (this._timeouts.length && firstEvent && firstEvent.time <= now3) {
      firstEvent.callback();
      this._timeouts.shift();
      firstEvent = this._timeouts.peek();
    }
  }
  /**
   * A setTimeout which is guaranteed by the clock source.
   * Also runs in the offline context.
   * @param  fn       The callback to invoke
   * @param  timeout  The timeout in seconds
   * @returns ID to use when invoking Context.clearTimeout
   */
  setTimeout(fn, timeout) {
    this._timeoutIds++;
    const now3 = this.now();
    this._timeouts.add({
      callback: fn,
      id: this._timeoutIds,
      time: now3 + timeout
    });
    return this._timeoutIds;
  }
  /**
   * Clears a previously scheduled timeout with Tone.context.setTimeout
   * @param  id  The ID returned from setTimeout
   */
  clearTimeout(id) {
    this._timeouts.forEach((event) => {
      if (event.id === id) {
        this._timeouts.remove(event);
      }
    });
    return this;
  }
  /**
   * Clear the function scheduled by {@link setInterval}
   */
  clearInterval(id) {
    return this.clearTimeout(id);
  }
  /**
   * Adds a repeating event to the context's callback clock
   */
  setInterval(fn, interval) {
    const id = ++this._timeoutIds;
    const intervalFn = () => {
      const now3 = this.now();
      this._timeouts.add({
        callback: () => {
          fn();
          intervalFn();
        },
        id,
        time: now3 + interval
      });
    };
    intervalFn();
    return id;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/core/context/DummyContext.js
var DummyContext = class extends BaseContext {
  constructor() {
    super(...arguments);
    this.lookAhead = 0;
    this.latencyHint = 0;
    this.isOffline = false;
  }
  //---------------------------
  // BASE AUDIO CONTEXT METHODS
  //---------------------------
  createAnalyser() {
    return {};
  }
  createOscillator() {
    return {};
  }
  createBufferSource() {
    return {};
  }
  createBiquadFilter() {
    return {};
  }
  createBuffer(_numberOfChannels, _length, _sampleRate) {
    return {};
  }
  createChannelMerger(_numberOfInputs) {
    return {};
  }
  createChannelSplitter(_numberOfOutputs) {
    return {};
  }
  createConstantSource() {
    return {};
  }
  createConvolver() {
    return {};
  }
  createDelay(_maxDelayTime) {
    return {};
  }
  createDynamicsCompressor() {
    return {};
  }
  createGain() {
    return {};
  }
  createIIRFilter(_feedForward, _feedback) {
    return {};
  }
  createPanner() {
    return {};
  }
  createPeriodicWave(_real, _imag, _constraints) {
    return {};
  }
  createStereoPanner() {
    return {};
  }
  createWaveShaper() {
    return {};
  }
  createMediaStreamSource(_stream) {
    return {};
  }
  createMediaElementSource(_element) {
    return {};
  }
  createMediaStreamDestination() {
    return {};
  }
  decodeAudioData(_audioData) {
    return Promise.resolve({});
  }
  //---------------------------
  // TONE AUDIO CONTEXT METHODS
  //---------------------------
  createAudioWorkletNode(_name, _options) {
    return {};
  }
  get rawContext() {
    return {};
  }
  addAudioWorkletModule(_url) {
    return __awaiter(this, void 0, void 0, function* () {
      return Promise.resolve();
    });
  }
  resume() {
    return Promise.resolve();
  }
  setTimeout(_fn, _timeout) {
    return 0;
  }
  clearTimeout(_id) {
    return this;
  }
  setInterval(_fn, _interval) {
    return 0;
  }
  clearInterval(_id) {
    return this;
  }
  getConstant(_val) {
    return {};
  }
  get currentTime() {
    return 0;
  }
  get state() {
    return {};
  }
  get sampleRate() {
    return 0;
  }
  get listener() {
    return {};
  }
  get transport() {
    return {};
  }
  get draw() {
    return {};
  }
  set draw(_d) {
  }
  get destination() {
    return {};
  }
  set destination(_d) {
  }
  now() {
    return 0;
  }
  immediate() {
    return 0;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/core/util/Interface.js
function readOnly(target, property) {
  if (isArray(property)) {
    property.forEach((str) => readOnly(target, str));
  } else {
    Object.defineProperty(target, property, {
      enumerable: true,
      writable: false
    });
  }
}
function writable(target, property) {
  if (isArray(property)) {
    property.forEach((str) => writable(target, str));
  } else {
    Object.defineProperty(target, property, {
      writable: true
    });
  }
}
var noOp = () => {
};

// node_modules/@magenta/music/node_modules/tone/build/esm/core/context/ToneAudioBuffer.js
var ToneAudioBuffer = class _ToneAudioBuffer extends Tone {
  constructor() {
    super();
    this.name = "ToneAudioBuffer";
    this.onload = noOp;
    const options = optionsFromArguments(_ToneAudioBuffer.getDefaults(), arguments, ["url", "onload", "onerror"]);
    this.reverse = options.reverse;
    this.onload = options.onload;
    if (isString(options.url)) {
      this.load(options.url).catch(options.onerror);
    } else if (options.url) {
      this.set(options.url);
    }
  }
  static getDefaults() {
    return {
      onerror: noOp,
      onload: noOp,
      reverse: false
    };
  }
  /**
   * The sample rate of the AudioBuffer
   */
  get sampleRate() {
    if (this._buffer) {
      return this._buffer.sampleRate;
    } else {
      return getContext().sampleRate;
    }
  }
  /**
   * Pass in an AudioBuffer or ToneAudioBuffer to set the value of this buffer.
   */
  set(buffer2) {
    if (buffer2 instanceof _ToneAudioBuffer) {
      if (buffer2.loaded) {
        this._buffer = buffer2.get();
      } else {
        buffer2.onload = () => {
          this.set(buffer2);
          this.onload(this);
        };
      }
    } else {
      this._buffer = buffer2;
    }
    if (this._reversed) {
      this._reverse();
    }
    return this;
  }
  /**
   * The audio buffer stored in the object.
   */
  get() {
    return this._buffer;
  }
  /**
   * Makes an fetch request for the selected url then decodes the file as an audio buffer.
   * Invokes the callback once the audio buffer loads.
   * @param url The url of the buffer to load. filetype support depends on the browser.
   * @returns A Promise which resolves with this ToneAudioBuffer
   */
  load(url) {
    return __awaiter(this, void 0, void 0, function* () {
      const doneLoading = _ToneAudioBuffer.load(url).then((audioBuffer) => {
        this.set(audioBuffer);
        this.onload(this);
      });
      _ToneAudioBuffer.downloads.push(doneLoading);
      try {
        yield doneLoading;
      } finally {
        const index = _ToneAudioBuffer.downloads.indexOf(doneLoading);
        _ToneAudioBuffer.downloads.splice(index, 1);
      }
      return this;
    });
  }
  /**
   * clean up
   */
  dispose() {
    super.dispose();
    this._buffer = void 0;
    return this;
  }
  /**
   * Set the audio buffer from the array.
   * To create a multichannel AudioBuffer, pass in a multidimensional array.
   * @param array The array to fill the audio buffer
   */
  fromArray(array) {
    const isMultidimensional = isArray(array) && array[0].length > 0;
    const channels = isMultidimensional ? array.length : 1;
    const len = isMultidimensional ? array[0].length : array.length;
    const context2 = getContext();
    const buffer2 = context2.createBuffer(channels, len, context2.sampleRate);
    const multiChannelArray = !isMultidimensional && channels === 1 ? [array] : array;
    for (let c = 0; c < channels; c++) {
      buffer2.copyToChannel(multiChannelArray[c], c);
    }
    this._buffer = buffer2;
    return this;
  }
  /**
   * Sums multiple channels into 1 channel
   * @param chanNum Optionally only copy a single channel from the array.
   */
  toMono(chanNum) {
    if (isNumber(chanNum)) {
      this.fromArray(this.toArray(chanNum));
    } else {
      let outputArray = new Float32Array(this.length);
      const numChannels = this.numberOfChannels;
      for (let channel = 0; channel < numChannels; channel++) {
        const channelArray = this.toArray(channel);
        for (let i = 0; i < channelArray.length; i++) {
          outputArray[i] += channelArray[i];
        }
      }
      outputArray = outputArray.map((sample) => sample / numChannels);
      this.fromArray(outputArray);
    }
    return this;
  }
  /**
   * Get the buffer as an array. Single channel buffers will return a 1-dimensional
   * Float32Array, and multichannel buffers will return multidimensional arrays.
   * @param channel Optionally only copy a single channel from the array.
   */
  toArray(channel) {
    if (isNumber(channel)) {
      return this.getChannelData(channel);
    } else if (this.numberOfChannels === 1) {
      return this.toArray(0);
    } else {
      const ret = [];
      for (let c = 0; c < this.numberOfChannels; c++) {
        ret[c] = this.getChannelData(c);
      }
      return ret;
    }
  }
  /**
   * Returns the Float32Array representing the PCM audio data for the specific channel.
   * @param  channel  The channel number to return
   * @return The audio as a TypedArray
   */
  getChannelData(channel) {
    if (this._buffer) {
      return this._buffer.getChannelData(channel);
    } else {
      return new Float32Array(0);
    }
  }
  /**
   * Cut a subsection of the array and return a buffer of the
   * subsection. Does not modify the original buffer
   * @param start The time to start the slice
   * @param end The end time to slice. If none is given will default to the end of the buffer
   */
  slice(start2, end = this.duration) {
    assert(this.loaded, "Buffer is not loaded");
    const startSamples = Math.floor(start2 * this.sampleRate);
    const endSamples = Math.floor(end * this.sampleRate);
    assert(startSamples < endSamples, "The start time must be less than the end time");
    const length = endSamples - startSamples;
    const retBuffer = getContext().createBuffer(this.numberOfChannels, length, this.sampleRate);
    for (let channel = 0; channel < this.numberOfChannels; channel++) {
      retBuffer.copyToChannel(this.getChannelData(channel).subarray(startSamples, endSamples), channel);
    }
    return new _ToneAudioBuffer(retBuffer);
  }
  /**
   * Reverse the buffer.
   */
  _reverse() {
    if (this.loaded) {
      for (let i = 0; i < this.numberOfChannels; i++) {
        this.getChannelData(i).reverse();
      }
    }
    return this;
  }
  /**
   * If the buffer is loaded or not
   */
  get loaded() {
    return this.length > 0;
  }
  /**
   * The duration of the buffer in seconds.
   */
  get duration() {
    if (this._buffer) {
      return this._buffer.duration;
    } else {
      return 0;
    }
  }
  /**
   * The length of the buffer in samples
   */
  get length() {
    if (this._buffer) {
      return this._buffer.length;
    } else {
      return 0;
    }
  }
  /**
   * The number of discrete audio channels. Returns 0 if no buffer is loaded.
   */
  get numberOfChannels() {
    if (this._buffer) {
      return this._buffer.numberOfChannels;
    } else {
      return 0;
    }
  }
  /**
   * Reverse the buffer.
   */
  get reverse() {
    return this._reversed;
  }
  set reverse(rev) {
    if (this._reversed !== rev) {
      this._reversed = rev;
      this._reverse();
    }
  }
  /**
   * Create a ToneAudioBuffer from the array. To create a multichannel AudioBuffer,
   * pass in a multidimensional array.
   * @param array The array to fill the audio buffer
   * @return A ToneAudioBuffer created from the array
   */
  static fromArray(array) {
    return new _ToneAudioBuffer().fromArray(array);
  }
  /**
   * Creates a ToneAudioBuffer from a URL, returns a promise which resolves to a ToneAudioBuffer
   * @param  url The url to load.
   * @return A promise which resolves to a ToneAudioBuffer
   */
  static fromUrl(url) {
    return __awaiter(this, void 0, void 0, function* () {
      const buffer2 = new _ToneAudioBuffer();
      return yield buffer2.load(url);
    });
  }
  /**
   * Loads a url using fetch and returns the AudioBuffer.
   */
  static load(url) {
    return __awaiter(this, void 0, void 0, function* () {
      const matches = url.match(/\[([^\]\[]+\|.+)\]$/);
      if (matches) {
        const extensions = matches[1].split("|");
        let extension = extensions[0];
        for (const ext of extensions) {
          if (_ToneAudioBuffer.supportsType(ext)) {
            extension = ext;
            break;
          }
        }
        url = url.replace(matches[0], extension);
      }
      const baseUrl = _ToneAudioBuffer.baseUrl === "" || _ToneAudioBuffer.baseUrl.endsWith("/") ? _ToneAudioBuffer.baseUrl : _ToneAudioBuffer.baseUrl + "/";
      const location = document.createElement("a");
      location.href = baseUrl + url;
      location.pathname = (location.pathname + location.hash).split("/").map(encodeURIComponent).join("/");
      const response = yield fetch(location.href);
      if (!response.ok) {
        throw new Error(`could not load url: ${url}`);
      }
      const arrayBuffer = yield response.arrayBuffer();
      const audioBuffer = yield getContext().decodeAudioData(arrayBuffer);
      return audioBuffer;
    });
  }
  /**
   * Checks a url's extension to see if the current browser can play that file type.
   * @param url The url/extension to test
   * @return If the file extension can be played
   * @static
   * @example
   * Tone.ToneAudioBuffer.supportsType("wav"); // returns true
   * Tone.ToneAudioBuffer.supportsType("path/to/file.wav"); // returns true
   */
  static supportsType(url) {
    const extensions = url.split(".");
    const extension = extensions[extensions.length - 1];
    const response = document.createElement("audio").canPlayType("audio/" + extension);
    return response !== "";
  }
  /**
   * Returns a Promise which resolves when all of the buffers have loaded
   */
  static loaded() {
    return __awaiter(this, void 0, void 0, function* () {
      yield Promise.resolve();
      while (_ToneAudioBuffer.downloads.length) {
        yield _ToneAudioBuffer.downloads[0];
      }
    });
  }
};
ToneAudioBuffer.baseUrl = "";
ToneAudioBuffer.downloads = [];

// node_modules/@magenta/music/node_modules/tone/build/esm/core/context/OfflineContext.js
var OfflineContext = class extends Context {
  constructor() {
    super({
      clockSource: "offline",
      context: isOfflineAudioContext(arguments[0]) ? arguments[0] : createOfflineAudioContext(arguments[0], arguments[1] * arguments[2], arguments[2]),
      lookAhead: 0,
      updateInterval: isOfflineAudioContext(arguments[0]) ? 128 / arguments[0].sampleRate : 128 / arguments[2]
    });
    this.name = "OfflineContext";
    this._currentTime = 0;
    this.isOffline = true;
    this._duration = isOfflineAudioContext(arguments[0]) ? arguments[0].length / arguments[0].sampleRate : arguments[1];
  }
  /**
   * Override the now method to point to the internal clock time
   */
  now() {
    return this._currentTime;
  }
  /**
   * Same as this.now()
   */
  get currentTime() {
    return this._currentTime;
  }
  /**
   * Render just the clock portion of the audio context.
   */
  _renderClock(asynchronous) {
    return __awaiter(this, void 0, void 0, function* () {
      let index = 0;
      while (this._duration - this._currentTime >= 0) {
        this.emit("tick");
        this._currentTime += 128 / this.sampleRate;
        index++;
        const yieldEvery = Math.floor(this.sampleRate / 128);
        if (asynchronous && index % yieldEvery === 0) {
          yield new Promise((done) => setTimeout(done, 1));
        }
      }
    });
  }
  /**
   * Render the output of the OfflineContext
   * @param asynchronous If the clock should be rendered asynchronously, which will not block the main thread, but be slightly slower.
   */
  render(asynchronous = true) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.workletsAreReady();
      yield this._renderClock(asynchronous);
      const buffer2 = yield this._context.startRendering();
      return new ToneAudioBuffer(buffer2);
    });
  }
  /**
   * Close the context
   */
  close() {
    return Promise.resolve();
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/core/Global.js
var dummyContext = new DummyContext();
var globalContext = dummyContext;
function getContext() {
  if (globalContext === dummyContext && hasAudioContext) {
    setContext(new Context());
  }
  return globalContext;
}
function setContext(context2, disposeOld = false) {
  if (disposeOld) {
    globalContext.dispose();
  }
  if (isAudioContext(context2)) {
    globalContext = new Context(context2);
  } else if (isOfflineAudioContext(context2)) {
    globalContext = new OfflineContext(context2);
  } else {
    globalContext = context2;
  }
}
function start() {
  return globalContext.resume();
}
if (theWindow && !theWindow.TONE_SILENCE_LOGGING) {
  let prefix = "v";
  if (version === "dev") {
    prefix = "";
  }
  const printString = ` * Tone.js ${prefix}${version} * `;
  console.log(`%c${printString}`, "background: #000; color: #fff");
}

// node_modules/@magenta/music/node_modules/tone/build/esm/core/type/Conversions.js
function dbToGain(db) {
  return Math.pow(10, db / 20);
}
function gainToDb(gain) {
  return 20 * (Math.log(gain) / Math.LN10);
}
function intervalToFrequencyRatio(interval) {
  return Math.pow(2, interval / 12);
}
var A4 = 440;
function getA4() {
  return A4;
}
function setA4(freq) {
  A4 = freq;
}
function ftom(frequency) {
  return Math.round(ftomf(frequency));
}
function ftomf(frequency) {
  return 69 + 12 * Math.log2(frequency / A4);
}
function mtof(midi) {
  return A4 * Math.pow(2, (midi - 69) / 12);
}

// node_modules/@magenta/music/node_modules/tone/build/esm/core/type/TimeBase.js
var TimeBaseClass = class _TimeBaseClass extends Tone {
  /**
   * @param context The context associated with the time value. Used to compute
   * Transport and context-relative timing.
   * @param  value  The time value as a number, string or object
   * @param  units  Unit values
   */
  constructor(context2, value, units) {
    super();
    this.defaultUnits = "s";
    this._val = value;
    this._units = units;
    this.context = context2;
    this._expressions = this._getExpressions();
  }
  /**
   * All of the time encoding expressions
   */
  _getExpressions() {
    return {
      hz: {
        method: (value) => {
          return this._frequencyToUnits(parseFloat(value));
        },
        regexp: /^(\d+(?:\.\d+)?)hz$/i
      },
      i: {
        method: (value) => {
          return this._ticksToUnits(parseInt(value, 10));
        },
        regexp: /^(\d+)i$/i
      },
      m: {
        method: (value) => {
          return this._beatsToUnits(parseInt(value, 10) * this._getTimeSignature());
        },
        regexp: /^(\d+)m$/i
      },
      n: {
        method: (value, dot) => {
          const numericValue = parseInt(value, 10);
          const scalar2 = dot === "." ? 1.5 : 1;
          if (numericValue === 1) {
            return this._beatsToUnits(this._getTimeSignature()) * scalar2;
          } else {
            return this._beatsToUnits(4 / numericValue) * scalar2;
          }
        },
        regexp: /^(\d+)n(\.?)$/i
      },
      number: {
        method: (value) => {
          return this._expressions[this.defaultUnits].method.call(this, value);
        },
        regexp: /^(\d+(?:\.\d+)?)$/
      },
      s: {
        method: (value) => {
          return this._secondsToUnits(parseFloat(value));
        },
        regexp: /^(\d+(?:\.\d+)?)s$/
      },
      samples: {
        method: (value) => {
          return parseInt(value, 10) / this.context.sampleRate;
        },
        regexp: /^(\d+)samples$/
      },
      t: {
        method: (value) => {
          const numericValue = parseInt(value, 10);
          return this._beatsToUnits(8 / (Math.floor(numericValue) * 3));
        },
        regexp: /^(\d+)t$/i
      },
      tr: {
        method: (m, q, s) => {
          let total = 0;
          if (m && m !== "0") {
            total += this._beatsToUnits(this._getTimeSignature() * parseFloat(m));
          }
          if (q && q !== "0") {
            total += this._beatsToUnits(parseFloat(q));
          }
          if (s && s !== "0") {
            total += this._beatsToUnits(parseFloat(s) / 4);
          }
          return total;
        },
        regexp: /^(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):?(\d+(?:\.\d+)?)?$/
      }
    };
  }
  //-------------------------------------
  // 	VALUE OF
  //-------------------------------------
  /**
   * Evaluate the time value. Returns the time in seconds.
   */
  valueOf() {
    if (this._val instanceof _TimeBaseClass) {
      this.fromType(this._val);
    }
    if (isUndef(this._val)) {
      return this._noArg();
    } else if (isString(this._val) && isUndef(this._units)) {
      for (const units in this._expressions) {
        if (this._expressions[units].regexp.test(this._val.trim())) {
          this._units = units;
          break;
        }
      }
    } else if (isObject(this._val)) {
      let total = 0;
      for (const typeName in this._val) {
        if (isDefined(this._val[typeName])) {
          const quantity = this._val[typeName];
          const time2 = new this.constructor(this.context, typeName).valueOf() * quantity;
          total += time2;
        }
      }
      return total;
    }
    if (isDefined(this._units)) {
      const expr = this._expressions[this._units];
      const matching = this._val.toString().trim().match(expr.regexp);
      if (matching) {
        return expr.method.apply(this, matching.slice(1));
      } else {
        return expr.method.call(this, this._val);
      }
    } else if (isString(this._val)) {
      return parseFloat(this._val);
    } else {
      return this._val;
    }
  }
  //-------------------------------------
  // 	UNIT CONVERSIONS
  //-------------------------------------
  /**
   * Returns the value of a frequency in the current units
   */
  _frequencyToUnits(freq) {
    return 1 / freq;
  }
  /**
   * Return the value of the beats in the current units
   */
  _beatsToUnits(beats) {
    return 60 / this._getBpm() * beats;
  }
  /**
   * Returns the value of a second in the current units
   */
  _secondsToUnits(seconds) {
    return seconds;
  }
  /**
   * Returns the value of a tick in the current time units
   */
  _ticksToUnits(ticks) {
    return ticks * this._beatsToUnits(1) / this._getPPQ();
  }
  /**
   * With no arguments, return 'now'
   */
  _noArg() {
    return this._now();
  }
  //-------------------------------------
  // 	TEMPO CONVERSIONS
  //-------------------------------------
  /**
   * Return the bpm
   */
  _getBpm() {
    return this.context.transport.bpm.value;
  }
  /**
   * Return the timeSignature
   */
  _getTimeSignature() {
    return this.context.transport.timeSignature;
  }
  /**
   * Return the PPQ or 192 if Transport is not available
   */
  _getPPQ() {
    return this.context.transport.PPQ;
  }
  //-------------------------------------
  // 	CONVERSION INTERFACE
  //-------------------------------------
  /**
   * Coerce a time type into this units type.
   * @param type Any time type units
   */
  fromType(type) {
    this._units = void 0;
    switch (this.defaultUnits) {
      case "s":
        this._val = type.toSeconds();
        break;
      case "i":
        this._val = type.toTicks();
        break;
      case "hz":
        this._val = type.toFrequency();
        break;
      case "midi":
        this._val = type.toMidi();
        break;
    }
    return this;
  }
  /**
   * Return the value in hertz
   */
  toFrequency() {
    return 1 / this.toSeconds();
  }
  /**
   * Return the time in samples
   */
  toSamples() {
    return this.toSeconds() * this.context.sampleRate;
  }
  /**
   * Return the time in milliseconds.
   */
  toMilliseconds() {
    return this.toSeconds() * 1e3;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/core/type/Time.js
var TimeClass = class _TimeClass extends TimeBaseClass {
  constructor() {
    super(...arguments);
    this.name = "TimeClass";
  }
  _getExpressions() {
    return Object.assign(super._getExpressions(), {
      now: {
        method: (capture) => {
          return this._now() + new this.constructor(this.context, capture).valueOf();
        },
        regexp: /^\+(.+)/
      },
      quantize: {
        method: (capture) => {
          const quantTo = new _TimeClass(this.context, capture).valueOf();
          return this._secondsToUnits(this.context.transport.nextSubdivision(quantTo));
        },
        regexp: /^@(.+)/
      }
    });
  }
  /**
   * Quantize the time by the given subdivision. Optionally add a
   * percentage which will move the time value towards the ideal
   * quantized value by that percentage.
   * @param  subdiv    The subdivision to quantize to
   * @param  percent  Move the time value towards the quantized value by a percentage.
   * @example
   * Tone.Time(21).quantize(2); // returns 22
   * Tone.Time(0.6).quantize("4n", 0.5); // returns 0.55
   */
  quantize(subdiv, percent = 1) {
    const subdivision = new this.constructor(this.context, subdiv).valueOf();
    const value = this.valueOf();
    const multiple = Math.round(value / subdivision);
    const ideal = multiple * subdivision;
    const diff = ideal - value;
    return value + diff * percent;
  }
  //-------------------------------------
  // CONVERSIONS
  //-------------------------------------
  /**
   * Convert a Time to Notation. The notation values are will be the
   * closest representation between 1m to 128th note.
   * @return {Notation}
   * @example
   * // if the Transport is at 120bpm:
   * Tone.Time(2).toNotation(); // returns "1m"
   */
  toNotation() {
    const time2 = this.toSeconds();
    const testNotations = ["1m"];
    for (let power = 1; power < 9; power++) {
      const subdiv = Math.pow(2, power);
      testNotations.push(subdiv + "n.");
      testNotations.push(subdiv + "n");
      testNotations.push(subdiv + "t");
    }
    testNotations.push("0");
    let closest = testNotations[0];
    let closestSeconds = new _TimeClass(this.context, testNotations[0]).toSeconds();
    testNotations.forEach((notation) => {
      const notationSeconds = new _TimeClass(this.context, notation).toSeconds();
      if (Math.abs(notationSeconds - time2) < Math.abs(closestSeconds - time2)) {
        closest = notation;
        closestSeconds = notationSeconds;
      }
    });
    return closest;
  }
  /**
   * Return the time encoded as Bars:Beats:Sixteenths.
   */
  toBarsBeatsSixteenths() {
    const quarterTime = this._beatsToUnits(1);
    let quarters = this.valueOf() / quarterTime;
    quarters = parseFloat(quarters.toFixed(4));
    const measures = Math.floor(quarters / this._getTimeSignature());
    let sixteenths = quarters % 1 * 4;
    quarters = Math.floor(quarters) % this._getTimeSignature();
    const sixteenthString = sixteenths.toString();
    if (sixteenthString.length > 3) {
      sixteenths = parseFloat(parseFloat(sixteenthString).toFixed(3));
    }
    const progress = [measures, quarters, sixteenths];
    return progress.join(":");
  }
  /**
   * Return the time in ticks.
   */
  toTicks() {
    const quarterTime = this._beatsToUnits(1);
    const quarters = this.valueOf() / quarterTime;
    return quarters * this._getPPQ();
  }
  /**
   * Return the time in seconds.
   */
  toSeconds() {
    return this.valueOf();
  }
  /**
   * Return the value as a midi note.
   */
  toMidi() {
    return ftom(this.toFrequency());
  }
  _now() {
    return this.context.now();
  }
};
function Time(value, units) {
  return new TimeClass(getContext(), value, units);
}

// node_modules/@magenta/music/node_modules/tone/build/esm/core/type/Frequency.js
var FrequencyClass = class _FrequencyClass extends TimeClass {
  constructor() {
    super(...arguments);
    this.name = "Frequency";
    this.defaultUnits = "hz";
  }
  /**
   * The [concert tuning pitch](https://en.wikipedia.org/wiki/Concert_pitch) which is used
   * to generate all the other pitch values from notes. A4's values in Hertz.
   */
  static get A4() {
    return getA4();
  }
  static set A4(freq) {
    setA4(freq);
  }
  //-------------------------------------
  // 	AUGMENT BASE EXPRESSIONS
  //-------------------------------------
  _getExpressions() {
    return Object.assign({}, super._getExpressions(), {
      midi: {
        regexp: /^(\d+(?:\.\d+)?midi)/,
        method(value) {
          if (this.defaultUnits === "midi") {
            return value;
          } else {
            return _FrequencyClass.mtof(value);
          }
        }
      },
      note: {
        regexp: /^([a-g]{1}(?:b|#|##|x|bb|###|#x|x#|bbb)?)(-?[0-9]+)/i,
        method(pitch, octave) {
          const index = noteToScaleIndex[pitch.toLowerCase()];
          const noteNumber = index + (parseInt(octave, 10) + 1) * 12;
          if (this.defaultUnits === "midi") {
            return noteNumber;
          } else {
            return _FrequencyClass.mtof(noteNumber);
          }
        }
      },
      tr: {
        regexp: /^(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):?(\d+(?:\.\d+)?)?/,
        method(m, q, s) {
          let total = 1;
          if (m && m !== "0") {
            total *= this._beatsToUnits(this._getTimeSignature() * parseFloat(m));
          }
          if (q && q !== "0") {
            total *= this._beatsToUnits(parseFloat(q));
          }
          if (s && s !== "0") {
            total *= this._beatsToUnits(parseFloat(s) / 4);
          }
          return total;
        }
      }
    });
  }
  //-------------------------------------
  // 	EXPRESSIONS
  //-------------------------------------
  /**
   * Transposes the frequency by the given number of semitones.
   * @return  A new transposed frequency
   * @example
   * Tone.Frequency("A4").transpose(3); // "C5"
   */
  transpose(interval) {
    return new _FrequencyClass(this.context, this.valueOf() * intervalToFrequencyRatio(interval));
  }
  /**
   * Takes an array of semitone intervals and returns
   * an array of frequencies transposed by those intervals.
   * @return  Returns an array of Frequencies
   * @example
   * Tone.Frequency("A4").harmonize([0, 3, 7]); // ["A4", "C5", "E5"]
   */
  harmonize(intervals) {
    return intervals.map((interval) => {
      return this.transpose(interval);
    });
  }
  //-------------------------------------
  // 	UNIT CONVERSIONS
  //-------------------------------------
  /**
   * Return the value of the frequency as a MIDI note
   * @example
   * Tone.Frequency("C4").toMidi(); // 60
   */
  toMidi() {
    return ftom(this.valueOf());
  }
  /**
   * Return the value of the frequency in Scientific Pitch Notation
   * @example
   * Tone.Frequency(69, "midi").toNote(); // "A4"
   */
  toNote() {
    const freq = this.toFrequency();
    const log4 = Math.log2(freq / _FrequencyClass.A4);
    let noteNumber = Math.round(12 * log4) + 57;
    const octave = Math.floor(noteNumber / 12);
    if (octave < 0) {
      noteNumber += -12 * octave;
    }
    const noteName = scaleIndexToNote[noteNumber % 12];
    return noteName + octave.toString();
  }
  /**
   * Return the duration of one cycle in seconds.
   */
  toSeconds() {
    return 1 / super.toSeconds();
  }
  /**
   * Return the duration of one cycle in ticks
   */
  toTicks() {
    const quarterTime = this._beatsToUnits(1);
    const quarters = this.valueOf() / quarterTime;
    return Math.floor(quarters * this._getPPQ());
  }
  //-------------------------------------
  // 	UNIT CONVERSIONS HELPERS
  //-------------------------------------
  /**
   * With no arguments, return 0
   */
  _noArg() {
    return 0;
  }
  /**
   * Returns the value of a frequency in the current units
   */
  _frequencyToUnits(freq) {
    return freq;
  }
  /**
   * Returns the value of a tick in the current time units
   */
  _ticksToUnits(ticks) {
    return 1 / (ticks * 60 / (this._getBpm() * this._getPPQ()));
  }
  /**
   * Return the value of the beats in the current units
   */
  _beatsToUnits(beats) {
    return 1 / super._beatsToUnits(beats);
  }
  /**
   * Returns the value of a second in the current units
   */
  _secondsToUnits(seconds) {
    return 1 / seconds;
  }
  /**
   * Convert a MIDI note to frequency value.
   * @param  midi The midi number to convert.
   * @return The corresponding frequency value
   */
  static mtof(midi) {
    return mtof(midi);
  }
  /**
   * Convert a frequency value to a MIDI note.
   * @param frequency The value to frequency value to convert.
   */
  static ftom(frequency) {
    return ftom(frequency);
  }
};
var noteToScaleIndex = {
  cbbb: -3,
  cbb: -2,
  cb: -1,
  c: 0,
  "c#": 1,
  cx: 2,
  "c##": 2,
  "c###": 3,
  "cx#": 3,
  "c#x": 3,
  dbbb: -1,
  dbb: 0,
  db: 1,
  d: 2,
  "d#": 3,
  dx: 4,
  "d##": 4,
  "d###": 5,
  "dx#": 5,
  "d#x": 5,
  ebbb: 1,
  ebb: 2,
  eb: 3,
  e: 4,
  "e#": 5,
  ex: 6,
  "e##": 6,
  "e###": 7,
  "ex#": 7,
  "e#x": 7,
  fbbb: 2,
  fbb: 3,
  fb: 4,
  f: 5,
  "f#": 6,
  fx: 7,
  "f##": 7,
  "f###": 8,
  "fx#": 8,
  "f#x": 8,
  gbbb: 4,
  gbb: 5,
  gb: 6,
  g: 7,
  "g#": 8,
  gx: 9,
  "g##": 9,
  "g###": 10,
  "gx#": 10,
  "g#x": 10,
  abbb: 6,
  abb: 7,
  ab: 8,
  a: 9,
  "a#": 10,
  ax: 11,
  "a##": 11,
  "a###": 12,
  "ax#": 12,
  "a#x": 12,
  bbbb: 8,
  bbb: 9,
  bb: 10,
  b: 11,
  "b#": 12,
  bx: 13,
  "b##": 13,
  "b###": 14,
  "bx#": 14,
  "b#x": 14
};
var scaleIndexToNote = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
function Frequency(value, units) {
  return new FrequencyClass(getContext(), value, units);
}

// node_modules/@magenta/music/node_modules/tone/build/esm/core/type/TransportTime.js
var TransportTimeClass = class extends TimeClass {
  constructor() {
    super(...arguments);
    this.name = "TransportTime";
  }
  /**
   * Return the current time in whichever context is relevant
   */
  _now() {
    return this.context.transport.seconds;
  }
};
function TransportTime(value, units) {
  return new TransportTimeClass(getContext(), value, units);
}

// node_modules/@magenta/music/node_modules/tone/build/esm/core/context/ToneWithContext.js
var ToneWithContext = class _ToneWithContext extends Tone {
  constructor() {
    super();
    const options = optionsFromArguments(_ToneWithContext.getDefaults(), arguments, ["context"]);
    if (this.defaultContext) {
      this.context = this.defaultContext;
    } else {
      this.context = options.context;
    }
  }
  static getDefaults() {
    return {
      context: getContext()
    };
  }
  /**
   * Return the current time of the Context clock plus the lookAhead.
   * @example
   * setInterval(() => {
   * 	console.log(Tone.now());
   * }, 100);
   */
  now() {
    return this.context.currentTime + this.context.lookAhead;
  }
  /**
   * Return the current time of the Context clock without any lookAhead.
   * @example
   * setInterval(() => {
   * 	console.log(Tone.immediate());
   * }, 100);
   */
  immediate() {
    return this.context.currentTime;
  }
  /**
   * The duration in seconds of one sample.
   */
  get sampleTime() {
    return 1 / this.context.sampleRate;
  }
  /**
   * The number of seconds of 1 processing block (128 samples)
   * @example
   * console.log(Tone.Destination.blockTime);
   */
  get blockTime() {
    return 128 / this.context.sampleRate;
  }
  /**
   * Convert the incoming time to seconds.
   * This is calculated against the current {@link TransportClass} bpm
   * @example
   * const gain = new Tone.Gain();
   * setInterval(() => console.log(gain.toSeconds("4n")), 100);
   * // ramp the tempo to 60 bpm over 30 seconds
   * Tone.getTransport().bpm.rampTo(60, 30);
   */
  toSeconds(time2) {
    assertUsedScheduleTime(time2);
    return new TimeClass(this.context, time2).toSeconds();
  }
  /**
   * Convert the input to a frequency number
   * @example
   * const gain = new Tone.Gain();
   * console.log(gain.toFrequency("4n"));
   */
  toFrequency(freq) {
    return new FrequencyClass(this.context, freq).toFrequency();
  }
  /**
   * Convert the input time into ticks
   * @example
   * const gain = new Tone.Gain();
   * console.log(gain.toTicks("4n"));
   */
  toTicks(time2) {
    return new TransportTimeClass(this.context, time2).toTicks();
  }
  //-------------------------------------
  // 	GET/SET
  //-------------------------------------
  /**
   * Get a subset of the properties which are in the partial props
   */
  _getPartialProperties(props) {
    const options = this.get();
    Object.keys(options).forEach((name) => {
      if (isUndef(props[name])) {
        delete options[name];
      }
    });
    return options;
  }
  /**
   * Get the object's attributes.
   * @example
   * const osc = new Tone.Oscillator();
   * console.log(osc.get());
   */
  get() {
    const defaults = getDefaultsFromInstance(this);
    Object.keys(defaults).forEach((attribute) => {
      if (Reflect.has(this, attribute)) {
        const member = this[attribute];
        if (isDefined(member) && isDefined(member.value) && isDefined(member.setValueAtTime)) {
          defaults[attribute] = member.value;
        } else if (member instanceof _ToneWithContext) {
          defaults[attribute] = member._getPartialProperties(defaults[attribute]);
        } else if (isArray(member) || isNumber(member) || isString(member) || isBoolean(member)) {
          defaults[attribute] = member;
        } else {
          delete defaults[attribute];
        }
      }
    });
    return defaults;
  }
  /**
   * Set multiple properties at once with an object.
   * @example
   * const filter = new Tone.Filter().toDestination();
   * // set values using an object
   * filter.set({
   * 	frequency: "C6",
   * 	type: "highpass"
   * });
   * const player = new Tone.Player("https://tonejs.github.io/audio/berklee/Analogsynth_octaves_highmid.mp3").connect(filter);
   * player.autostart = true;
   */
  set(props) {
    Object.keys(props).forEach((attribute) => {
      if (Reflect.has(this, attribute) && isDefined(this[attribute])) {
        if (this[attribute] && isDefined(this[attribute].value) && isDefined(this[attribute].setValueAtTime)) {
          if (this[attribute].value !== props[attribute]) {
            this[attribute].value = props[attribute];
          }
        } else if (this[attribute] instanceof _ToneWithContext) {
          this[attribute].set(props[attribute]);
        } else {
          this[attribute] = props[attribute];
        }
      }
    });
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/core/util/StateTimeline.js
var StateTimeline = class extends Timeline {
  constructor(initial = "stopped") {
    super();
    this.name = "StateTimeline";
    this._initial = initial;
    this.setStateAtTime(this._initial, 0);
  }
  /**
   * Returns the scheduled state scheduled before or at
   * the given time.
   * @param  time  The time to query.
   * @return  The name of the state input in setStateAtTime.
   */
  getValueAtTime(time2) {
    const event = this.get(time2);
    if (event !== null) {
      return event.state;
    } else {
      return this._initial;
    }
  }
  /**
   * Add a state to the timeline.
   * @param  state The name of the state to set.
   * @param  time  The time to query.
   * @param options Any additional options that are needed in the timeline.
   */
  setStateAtTime(state, time2, options) {
    assertRange(time2, 0);
    this.add(Object.assign({}, options, {
      state,
      time: time2
    }));
    return this;
  }
  /**
   * Return the event before the time with the given state
   * @param  state The state to look for
   * @param  time  When to check before
   * @return  The event with the given state before the time
   */
  getLastState(state, time2) {
    const index = this._search(time2);
    for (let i = index; i >= 0; i--) {
      const event = this._timeline[i];
      if (event.state === state) {
        return event;
      }
    }
  }
  /**
   * Return the event after the time with the given state
   * @param  state The state to look for
   * @param  time  When to check from
   * @return  The event with the given state after the time
   */
  getNextState(state, time2) {
    const index = this._search(time2);
    if (index !== -1) {
      for (let i = index; i < this._timeline.length; i++) {
        const event = this._timeline[i];
        if (event.state === state) {
          return event;
        }
      }
    }
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/core/context/Param.js
var Param = class _Param extends ToneWithContext {
  constructor() {
    super(optionsFromArguments(_Param.getDefaults(), arguments, ["param", "units", "convert"]));
    this.name = "Param";
    this.overridden = false;
    this._minOutput = 1e-7;
    const options = optionsFromArguments(_Param.getDefaults(), arguments, ["param", "units", "convert"]);
    assert(isDefined(options.param) && (isAudioParam(options.param) || options.param instanceof _Param), "param must be an AudioParam");
    while (!isAudioParam(options.param)) {
      options.param = options.param._param;
    }
    this._swappable = isDefined(options.swappable) ? options.swappable : false;
    if (this._swappable) {
      this.input = this.context.createGain();
      this._param = options.param;
      this.input.connect(this._param);
    } else {
      this._param = this.input = options.param;
    }
    this._events = new Timeline(1e3);
    this._initialValue = this._param.defaultValue;
    this.units = options.units;
    this.convert = options.convert;
    this._minValue = options.minValue;
    this._maxValue = options.maxValue;
    if (isDefined(options.value) && options.value !== this._toType(this._initialValue)) {
      this.setValueAtTime(options.value, 0);
    }
  }
  static getDefaults() {
    return Object.assign(ToneWithContext.getDefaults(), {
      convert: true,
      units: "number"
    });
  }
  get value() {
    const now3 = this.now();
    return this.getValueAtTime(now3);
  }
  set value(value) {
    this.cancelScheduledValues(this.now());
    this.setValueAtTime(value, this.now());
  }
  get minValue() {
    if (isDefined(this._minValue)) {
      return this._minValue;
    } else if (this.units === "time" || this.units === "frequency" || this.units === "normalRange" || this.units === "positive" || this.units === "transportTime" || this.units === "ticks" || this.units === "bpm" || this.units === "hertz" || this.units === "samples") {
      return 0;
    } else if (this.units === "audioRange") {
      return -1;
    } else if (this.units === "decibels") {
      return -Infinity;
    } else {
      return this._param.minValue;
    }
  }
  get maxValue() {
    if (isDefined(this._maxValue)) {
      return this._maxValue;
    } else if (this.units === "normalRange" || this.units === "audioRange") {
      return 1;
    } else {
      return this._param.maxValue;
    }
  }
  /**
   * Type guard based on the unit name
   */
  _is(arg, type) {
    return this.units === type;
  }
  /**
   * Make sure the value is always in the defined range
   */
  _assertRange(value) {
    if (isDefined(this.maxValue) && isDefined(this.minValue)) {
      assertRange(value, this._fromType(this.minValue), this._fromType(this.maxValue));
    }
    return value;
  }
  /**
   * Convert the given value from the type specified by Param.units
   * into the destination value (such as Gain or Frequency).
   */
  _fromType(val) {
    if (this.convert && !this.overridden) {
      if (this._is(val, "time")) {
        return this.toSeconds(val);
      } else if (this._is(val, "decibels")) {
        return dbToGain(val);
      } else if (this._is(val, "frequency")) {
        return this.toFrequency(val);
      } else {
        return val;
      }
    } else if (this.overridden) {
      return 0;
    } else {
      return val;
    }
  }
  /**
   * Convert the parameters value into the units specified by Param.units.
   */
  _toType(val) {
    if (this.convert && this.units === "decibels") {
      return gainToDb(val);
    } else {
      return val;
    }
  }
  //-------------------------------------
  // ABSTRACT PARAM INTERFACE
  // all docs are generated from ParamInterface.ts
  //-------------------------------------
  setValueAtTime(value, time2) {
    const computedTime = this.toSeconds(time2);
    const numericValue = this._fromType(value);
    assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to setValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(time2)}`);
    this._assertRange(numericValue);
    this.log(this.units, "setValueAtTime", value, computedTime);
    this._events.add({
      time: computedTime,
      type: "setValueAtTime",
      value: numericValue
    });
    this._param.setValueAtTime(numericValue, computedTime);
    return this;
  }
  getValueAtTime(time2) {
    const computedTime = Math.max(this.toSeconds(time2), 0);
    const after = this._events.getAfter(computedTime);
    const before = this._events.get(computedTime);
    let value = this._initialValue;
    if (before === null) {
      value = this._initialValue;
    } else if (before.type === "setTargetAtTime" && (after === null || after.type === "setValueAtTime")) {
      const previous = this._events.getBefore(before.time);
      let previousVal;
      if (previous === null) {
        previousVal = this._initialValue;
      } else {
        previousVal = previous.value;
      }
      if (before.type === "setTargetAtTime") {
        value = this._exponentialApproach(before.time, previousVal, before.value, before.constant, computedTime);
      }
    } else if (after === null) {
      value = before.value;
    } else if (after.type === "linearRampToValueAtTime" || after.type === "exponentialRampToValueAtTime") {
      let beforeValue = before.value;
      if (before.type === "setTargetAtTime") {
        const previous = this._events.getBefore(before.time);
        if (previous === null) {
          beforeValue = this._initialValue;
        } else {
          beforeValue = previous.value;
        }
      }
      if (after.type === "linearRampToValueAtTime") {
        value = this._linearInterpolate(before.time, beforeValue, after.time, after.value, computedTime);
      } else {
        value = this._exponentialInterpolate(before.time, beforeValue, after.time, after.value, computedTime);
      }
    } else {
      value = before.value;
    }
    return this._toType(value);
  }
  setRampPoint(time2) {
    time2 = this.toSeconds(time2);
    let currentVal = this.getValueAtTime(time2);
    this.cancelAndHoldAtTime(time2);
    if (this._fromType(currentVal) === 0) {
      currentVal = this._toType(this._minOutput);
    }
    this.setValueAtTime(currentVal, time2);
    return this;
  }
  linearRampToValueAtTime(value, endTime) {
    const numericValue = this._fromType(value);
    const computedTime = this.toSeconds(endTime);
    assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to linearRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`);
    this._assertRange(numericValue);
    this._events.add({
      time: computedTime,
      type: "linearRampToValueAtTime",
      value: numericValue
    });
    this.log(this.units, "linearRampToValueAtTime", value, computedTime);
    this._param.linearRampToValueAtTime(numericValue, computedTime);
    return this;
  }
  exponentialRampToValueAtTime(value, endTime) {
    let numericValue = this._fromType(value);
    numericValue = EQ(numericValue, 0) ? this._minOutput : numericValue;
    this._assertRange(numericValue);
    const computedTime = this.toSeconds(endTime);
    assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to exponentialRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`);
    this._events.add({
      time: computedTime,
      type: "exponentialRampToValueAtTime",
      value: numericValue
    });
    this.log(this.units, "exponentialRampToValueAtTime", value, computedTime);
    this._param.exponentialRampToValueAtTime(numericValue, computedTime);
    return this;
  }
  exponentialRampTo(value, rampTime, startTime) {
    startTime = this.toSeconds(startTime);
    this.setRampPoint(startTime);
    this.exponentialRampToValueAtTime(value, startTime + this.toSeconds(rampTime));
    return this;
  }
  linearRampTo(value, rampTime, startTime) {
    startTime = this.toSeconds(startTime);
    this.setRampPoint(startTime);
    this.linearRampToValueAtTime(value, startTime + this.toSeconds(rampTime));
    return this;
  }
  targetRampTo(value, rampTime, startTime) {
    startTime = this.toSeconds(startTime);
    this.setRampPoint(startTime);
    this.exponentialApproachValueAtTime(value, startTime, rampTime);
    return this;
  }
  exponentialApproachValueAtTime(value, time2, rampTime) {
    time2 = this.toSeconds(time2);
    rampTime = this.toSeconds(rampTime);
    const timeConstant = Math.log(rampTime + 1) / Math.log(200);
    this.setTargetAtTime(value, time2, timeConstant);
    this.cancelAndHoldAtTime(time2 + rampTime * 0.9);
    this.linearRampToValueAtTime(value, time2 + rampTime);
    return this;
  }
  setTargetAtTime(value, startTime, timeConstant) {
    const numericValue = this._fromType(value);
    assert(isFinite(timeConstant) && timeConstant > 0, "timeConstant must be a number greater than 0");
    const computedTime = this.toSeconds(startTime);
    this._assertRange(numericValue);
    assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to setTargetAtTime: ${JSON.stringify(value)}, ${JSON.stringify(startTime)}`);
    this._events.add({
      constant: timeConstant,
      time: computedTime,
      type: "setTargetAtTime",
      value: numericValue
    });
    this.log(this.units, "setTargetAtTime", value, computedTime, timeConstant);
    this._param.setTargetAtTime(numericValue, computedTime, timeConstant);
    return this;
  }
  setValueCurveAtTime(values, startTime, duration, scaling = 1) {
    duration = this.toSeconds(duration);
    startTime = this.toSeconds(startTime);
    const startingValue = this._fromType(values[0]) * scaling;
    this.setValueAtTime(this._toType(startingValue), startTime);
    const segTime = duration / (values.length - 1);
    for (let i = 1; i < values.length; i++) {
      const numericValue = this._fromType(values[i]) * scaling;
      this.linearRampToValueAtTime(this._toType(numericValue), startTime + i * segTime);
    }
    return this;
  }
  cancelScheduledValues(time2) {
    const computedTime = this.toSeconds(time2);
    assert(isFinite(computedTime), `Invalid argument to cancelScheduledValues: ${JSON.stringify(time2)}`);
    this._events.cancel(computedTime);
    this._param.cancelScheduledValues(computedTime);
    this.log(this.units, "cancelScheduledValues", computedTime);
    return this;
  }
  cancelAndHoldAtTime(time2) {
    const computedTime = this.toSeconds(time2);
    const valueAtTime = this._fromType(this.getValueAtTime(computedTime));
    assert(isFinite(computedTime), `Invalid argument to cancelAndHoldAtTime: ${JSON.stringify(time2)}`);
    this.log(this.units, "cancelAndHoldAtTime", computedTime, "value=" + valueAtTime);
    const before = this._events.get(computedTime);
    const after = this._events.getAfter(computedTime);
    if (before && EQ(before.time, computedTime)) {
      if (after) {
        this._param.cancelScheduledValues(after.time);
        this._events.cancel(after.time);
      } else {
        this._param.cancelAndHoldAtTime(computedTime);
        this._events.cancel(computedTime + this.sampleTime);
      }
    } else if (after) {
      this._param.cancelScheduledValues(after.time);
      this._events.cancel(after.time);
      if (after.type === "linearRampToValueAtTime") {
        this.linearRampToValueAtTime(this._toType(valueAtTime), computedTime);
      } else if (after.type === "exponentialRampToValueAtTime") {
        this.exponentialRampToValueAtTime(this._toType(valueAtTime), computedTime);
      }
    }
    this._events.add({
      time: computedTime,
      type: "setValueAtTime",
      value: valueAtTime
    });
    this._param.setValueAtTime(valueAtTime, computedTime);
    return this;
  }
  rampTo(value, rampTime = 0.1, startTime) {
    if (this.units === "frequency" || this.units === "bpm" || this.units === "decibels") {
      this.exponentialRampTo(value, rampTime, startTime);
    } else {
      this.linearRampTo(value, rampTime, startTime);
    }
    return this;
  }
  /**
   * Apply all of the previously scheduled events to the passed in Param or AudioParam.
   * The applied values will start at the context's current time and schedule
   * all of the events which are scheduled on this Param onto the passed in param.
   */
  apply(param) {
    const now3 = this.context.currentTime;
    param.setValueAtTime(this.getValueAtTime(now3), now3);
    const previousEvent = this._events.get(now3);
    if (previousEvent && previousEvent.type === "setTargetAtTime") {
      const nextEvent = this._events.getAfter(previousEvent.time);
      const endTime = nextEvent ? nextEvent.time : now3 + 2;
      const subdivisions = (endTime - now3) / 10;
      for (let i = now3; i < endTime; i += subdivisions) {
        param.linearRampToValueAtTime(this.getValueAtTime(i), i);
      }
    }
    this._events.forEachAfter(this.context.currentTime, (event) => {
      if (event.type === "cancelScheduledValues") {
        param.cancelScheduledValues(event.time);
      } else if (event.type === "setTargetAtTime") {
        param.setTargetAtTime(event.value, event.time, event.constant);
      } else {
        param[event.type](event.value, event.time);
      }
    });
    return this;
  }
  /**
   * Replace the Param's internal AudioParam. Will apply scheduled curves
   * onto the parameter and replace the connections.
   */
  setParam(param) {
    assert(this._swappable, "The Param must be assigned as 'swappable' in the constructor");
    const input2 = this.input;
    input2.disconnect(this._param);
    this.apply(param);
    this._param = param;
    input2.connect(this._param);
    return this;
  }
  dispose() {
    super.dispose();
    this._events.dispose();
    return this;
  }
  get defaultValue() {
    return this._toType(this._param.defaultValue);
  }
  //-------------------------------------
  // 	AUTOMATION CURVE CALCULATIONS
  // 	MIT License, copyright (c) 2014 Jordan Santell
  //-------------------------------------
  // Calculates the the value along the curve produced by setTargetAtTime
  _exponentialApproach(t0, v0, v1, timeConstant, t) {
    return v1 + (v0 - v1) * Math.exp(-(t - t0) / timeConstant);
  }
  // Calculates the the value along the curve produced by linearRampToValueAtTime
  _linearInterpolate(t0, v0, t1, v1, t) {
    return v0 + (v1 - v0) * ((t - t0) / (t1 - t0));
  }
  // Calculates the the value along the curve produced by exponentialRampToValueAtTime
  _exponentialInterpolate(t0, v0, t1, v1, t) {
    return v0 * Math.pow(v1 / v0, (t - t0) / (t1 - t0));
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/core/context/ToneAudioNode.js
var ToneAudioNode = class _ToneAudioNode extends ToneWithContext {
  constructor() {
    super(...arguments);
    this._internalChannels = [];
  }
  /**
   * The number of inputs feeding into the AudioNode.
   * For source nodes, this will be 0.
   * @example
   * const node = new Tone.Gain();
   * console.log(node.numberOfInputs);
   */
  get numberOfInputs() {
    if (isDefined(this.input)) {
      if (isAudioParam(this.input) || this.input instanceof Param) {
        return 1;
      } else {
        return this.input.numberOfInputs;
      }
    } else {
      return 0;
    }
  }
  /**
   * The number of outputs of the AudioNode.
   * @example
   * const node = new Tone.Gain();
   * console.log(node.numberOfOutputs);
   */
  get numberOfOutputs() {
    if (isDefined(this.output)) {
      return this.output.numberOfOutputs;
    } else {
      return 0;
    }
  }
  //-------------------------------------
  // AUDIO PROPERTIES
  //-------------------------------------
  /**
   * Used to decide which nodes to get/set properties on
   */
  _isAudioNode(node) {
    return isDefined(node) && (node instanceof _ToneAudioNode || isAudioNode(node));
  }
  /**
   * Get all of the audio nodes (either internal or input/output) which together
   * make up how the class node responds to channel input/output
   */
  _getInternalNodes() {
    const nodeList = this._internalChannels.slice(0);
    if (this._isAudioNode(this.input)) {
      nodeList.push(this.input);
    }
    if (this._isAudioNode(this.output)) {
      if (this.input !== this.output) {
        nodeList.push(this.output);
      }
    }
    return nodeList;
  }
  /**
   * Set the audio options for this node such as channelInterpretation
   * channelCount, etc.
   * @param options
   */
  _setChannelProperties(options) {
    const nodeList = this._getInternalNodes();
    nodeList.forEach((node) => {
      node.channelCount = options.channelCount;
      node.channelCountMode = options.channelCountMode;
      node.channelInterpretation = options.channelInterpretation;
    });
  }
  /**
   * Get the current audio options for this node such as channelInterpretation
   * channelCount, etc.
   */
  _getChannelProperties() {
    const nodeList = this._getInternalNodes();
    assert(nodeList.length > 0, "ToneAudioNode does not have any internal nodes");
    const node = nodeList[0];
    return {
      channelCount: node.channelCount,
      channelCountMode: node.channelCountMode,
      channelInterpretation: node.channelInterpretation
    };
  }
  /**
   * channelCount is the number of channels used when up-mixing and down-mixing
   * connections to any inputs to the node. The default value is 2 except for
   * specific nodes where its value is specially determined.
   */
  get channelCount() {
    return this._getChannelProperties().channelCount;
  }
  set channelCount(channelCount) {
    const props = this._getChannelProperties();
    this._setChannelProperties(Object.assign(props, { channelCount }));
  }
  /**
   * channelCountMode determines how channels will be counted when up-mixing and
   * down-mixing connections to any inputs to the node.
   * The default value is "max". This attribute has no effect for nodes with no inputs.
   * * "max" - computedNumberOfChannels is the maximum of the number of channels of all connections to an input. In this mode channelCount is ignored.
   * * "clamped-max" - computedNumberOfChannels is determined as for "max" and then clamped to a maximum value of the given channelCount.
   * * "explicit" - computedNumberOfChannels is the exact value as specified by the channelCount.
   */
  get channelCountMode() {
    return this._getChannelProperties().channelCountMode;
  }
  set channelCountMode(channelCountMode) {
    const props = this._getChannelProperties();
    this._setChannelProperties(Object.assign(props, { channelCountMode }));
  }
  /**
   * channelInterpretation determines how individual channels will be treated
   * when up-mixing and down-mixing connections to any inputs to the node.
   * The default value is "speakers".
   */
  get channelInterpretation() {
    return this._getChannelProperties().channelInterpretation;
  }
  set channelInterpretation(channelInterpretation) {
    const props = this._getChannelProperties();
    this._setChannelProperties(Object.assign(props, { channelInterpretation }));
  }
  //-------------------------------------
  // CONNECTIONS
  //-------------------------------------
  /**
   * connect the output of a ToneAudioNode to an AudioParam, AudioNode, or ToneAudioNode
   * @param destination The output to connect to
   * @param outputNum The output to connect from
   * @param inputNum The input to connect to
   */
  connect(destination, outputNum = 0, inputNum = 0) {
    connect(this, destination, outputNum, inputNum);
    return this;
  }
  /**
   * Connect the output to the context's destination node.
   * @example
   * const osc = new Tone.Oscillator("C2").start();
   * osc.toDestination();
   */
  toDestination() {
    this.connect(this.context.destination);
    return this;
  }
  /**
   * Connect the output to the context's destination node.
   * @see {@link toDestination}
   * @deprecated
   */
  toMaster() {
    warn("toMaster() has been renamed toDestination()");
    return this.toDestination();
  }
  /**
   * disconnect the output
   */
  disconnect(destination, outputNum = 0, inputNum = 0) {
    disconnect(this, destination, outputNum, inputNum);
    return this;
  }
  /**
   * Connect the output of this node to the rest of the nodes in series.
   * @example
   * const player = new Tone.Player("https://tonejs.github.io/audio/drum-samples/handdrum-loop.mp3");
   * player.autostart = true;
   * const filter = new Tone.AutoFilter(4).start();
   * const distortion = new Tone.Distortion(0.5);
   * // connect the player to the filter, distortion and then to the master output
   * player.chain(filter, distortion, Tone.Destination);
   */
  chain(...nodes) {
    connectSeries(this, ...nodes);
    return this;
  }
  /**
   * connect the output of this node to the rest of the nodes in parallel.
   * @example
   * const player = new Tone.Player("https://tonejs.github.io/audio/drum-samples/conga-rhythm.mp3");
   * player.autostart = true;
   * const pitchShift = new Tone.PitchShift(4).toDestination();
   * const filter = new Tone.Filter("G5").toDestination();
   * // connect a node to the pitch shift and filter in parallel
   * player.fan(pitchShift, filter);
   */
  fan(...nodes) {
    nodes.forEach((node) => this.connect(node));
    return this;
  }
  /**
   * Dispose and disconnect
   */
  dispose() {
    super.dispose();
    if (isDefined(this.input)) {
      if (this.input instanceof _ToneAudioNode) {
        this.input.dispose();
      } else if (isAudioNode(this.input)) {
        this.input.disconnect();
      }
    }
    if (isDefined(this.output)) {
      if (this.output instanceof _ToneAudioNode) {
        this.output.dispose();
      } else if (isAudioNode(this.output)) {
        this.output.disconnect();
      }
    }
    this._internalChannels = [];
    return this;
  }
};
function connectSeries(...nodes) {
  const first = nodes.shift();
  nodes.reduce((prev, current) => {
    if (prev instanceof ToneAudioNode) {
      prev.connect(current);
    } else if (isAudioNode(prev)) {
      connect(prev, current);
    }
    return current;
  }, first);
}
function connect(srcNode, dstNode, outputNumber = 0, inputNumber = 0) {
  assert(isDefined(srcNode), "Cannot connect from undefined node");
  assert(isDefined(dstNode), "Cannot connect to undefined node");
  if (dstNode instanceof ToneAudioNode || isAudioNode(dstNode)) {
    assert(dstNode.numberOfInputs > 0, "Cannot connect to node with no inputs");
  }
  assert(srcNode.numberOfOutputs > 0, "Cannot connect from node with no outputs");
  while (dstNode instanceof ToneAudioNode || dstNode instanceof Param) {
    if (isDefined(dstNode.input)) {
      dstNode = dstNode.input;
    }
  }
  while (srcNode instanceof ToneAudioNode) {
    if (isDefined(srcNode.output)) {
      srcNode = srcNode.output;
    }
  }
  if (isAudioParam(dstNode)) {
    srcNode.connect(dstNode, outputNumber);
  } else {
    srcNode.connect(dstNode, outputNumber, inputNumber);
  }
}
function disconnect(srcNode, dstNode, outputNumber = 0, inputNumber = 0) {
  if (isDefined(dstNode)) {
    while (dstNode instanceof ToneAudioNode) {
      dstNode = dstNode.input;
    }
  }
  while (!isAudioNode(srcNode)) {
    if (isDefined(srcNode.output)) {
      srcNode = srcNode.output;
    }
  }
  if (isAudioParam(dstNode)) {
    srcNode.disconnect(dstNode, outputNumber);
  } else if (isAudioNode(dstNode)) {
    srcNode.disconnect(dstNode, outputNumber, inputNumber);
  } else {
    srcNode.disconnect();
  }
}
function fanIn(...nodes) {
  const dstNode = nodes.pop();
  if (isDefined(dstNode)) {
    nodes.forEach((node) => connect(node, dstNode));
  }
}

// node_modules/@magenta/music/node_modules/tone/build/esm/core/context/Gain.js
var Gain = class _Gain extends ToneAudioNode {
  constructor() {
    super(optionsFromArguments(_Gain.getDefaults(), arguments, ["gain", "units"]));
    this.name = "Gain";
    this._gainNode = this.context.createGain();
    this.input = this._gainNode;
    this.output = this._gainNode;
    const options = optionsFromArguments(_Gain.getDefaults(), arguments, ["gain", "units"]);
    this.gain = new Param({
      context: this.context,
      convert: options.convert,
      param: this._gainNode.gain,
      units: options.units,
      value: options.gain,
      minValue: options.minValue,
      maxValue: options.maxValue
    });
    readOnly(this, "gain");
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      convert: true,
      gain: 1,
      units: "gain"
    });
  }
  /**
   * Clean up.
   */
  dispose() {
    super.dispose();
    this._gainNode.disconnect();
    this.gain.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/source/OneShotSource.js
var OneShotSource = class extends ToneAudioNode {
  constructor(options) {
    super(options);
    this.onended = noOp;
    this._startTime = -1;
    this._stopTime = -1;
    this._timeout = -1;
    this.output = new Gain({
      context: this.context,
      gain: 0
    });
    this._gainNode = this.output;
    this.getStateAtTime = function(time2) {
      const computedTime = this.toSeconds(time2);
      if (this._startTime !== -1 && computedTime >= this._startTime && (this._stopTime === -1 || computedTime <= this._stopTime)) {
        return "started";
      } else {
        return "stopped";
      }
    };
    this._fadeIn = options.fadeIn;
    this._fadeOut = options.fadeOut;
    this._curve = options.curve;
    this.onended = options.onended;
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      curve: "linear",
      fadeIn: 0,
      fadeOut: 0,
      onended: noOp
    });
  }
  /**
   * Start the source at the given time
   * @param  time When to start the source
   */
  _startGain(time2, gain = 1) {
    assert(this._startTime === -1, "Source cannot be started more than once");
    const fadeInTime = this.toSeconds(this._fadeIn);
    this._startTime = time2 + fadeInTime;
    this._startTime = Math.max(this._startTime, this.context.currentTime);
    if (fadeInTime > 0) {
      this._gainNode.gain.setValueAtTime(0, time2);
      if (this._curve === "linear") {
        this._gainNode.gain.linearRampToValueAtTime(gain, time2 + fadeInTime);
      } else {
        this._gainNode.gain.exponentialApproachValueAtTime(gain, time2, fadeInTime);
      }
    } else {
      this._gainNode.gain.setValueAtTime(gain, time2);
    }
    return this;
  }
  /**
   * Stop the source node at the given time.
   * @param time When to stop the source
   */
  stop(time2) {
    this.log("stop", time2);
    this._stopGain(this.toSeconds(time2));
    return this;
  }
  /**
   * Stop the source at the given time
   * @param  time When to stop the source
   */
  _stopGain(time2) {
    assert(this._startTime !== -1, "'start' must be called before 'stop'");
    this.cancelStop();
    const fadeOutTime = this.toSeconds(this._fadeOut);
    this._stopTime = this.toSeconds(time2) + fadeOutTime;
    this._stopTime = Math.max(this._stopTime, this.now());
    if (fadeOutTime > 0) {
      if (this._curve === "linear") {
        this._gainNode.gain.linearRampTo(0, fadeOutTime, time2);
      } else {
        this._gainNode.gain.targetRampTo(0, fadeOutTime, time2);
      }
    } else {
      this._gainNode.gain.cancelAndHoldAtTime(time2);
      this._gainNode.gain.setValueAtTime(0, time2);
    }
    this.context.clearTimeout(this._timeout);
    this._timeout = this.context.setTimeout(() => {
      const additionalTail = this._curve === "exponential" ? fadeOutTime * 2 : 0;
      this._stopSource(this.now() + additionalTail);
      this._onended();
    }, this._stopTime - this.context.currentTime);
    return this;
  }
  /**
   * Invoke the onended callback
   */
  _onended() {
    if (this.onended !== noOp) {
      this.onended(this);
      this.onended = noOp;
      if (!this.context.isOffline) {
        const disposeCallback = () => this.dispose();
        if (typeof window.requestIdleCallback !== "undefined") {
          window.requestIdleCallback(disposeCallback);
        } else {
          setTimeout(disposeCallback, 1e3);
        }
      }
    }
  }
  /**
   * Get the playback state at the current time
   */
  get state() {
    return this.getStateAtTime(this.now());
  }
  /**
   * Cancel a scheduled stop event
   */
  cancelStop() {
    this.log("cancelStop");
    assert(this._startTime !== -1, "Source is not started");
    this._gainNode.gain.cancelScheduledValues(this._startTime + this.sampleTime);
    this.context.clearTimeout(this._timeout);
    this._stopTime = -1;
    return this;
  }
  dispose() {
    super.dispose();
    this._gainNode.dispose();
    this.onended = noOp;
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/signal/ToneConstantSource.js
var ToneConstantSource = class _ToneConstantSource extends OneShotSource {
  constructor() {
    super(optionsFromArguments(_ToneConstantSource.getDefaults(), arguments, ["offset"]));
    this.name = "ToneConstantSource";
    this._source = this.context.createConstantSource();
    const options = optionsFromArguments(_ToneConstantSource.getDefaults(), arguments, ["offset"]);
    connect(this._source, this._gainNode);
    this.offset = new Param({
      context: this.context,
      convert: options.convert,
      param: this._source.offset,
      units: options.units,
      value: options.offset,
      minValue: options.minValue,
      maxValue: options.maxValue
    });
  }
  static getDefaults() {
    return Object.assign(OneShotSource.getDefaults(), {
      convert: true,
      offset: 1,
      units: "number"
    });
  }
  /**
   * Start the source node at the given time
   * @param  time When to start the source
   */
  start(time2) {
    const computedTime = this.toSeconds(time2);
    this.log("start", computedTime);
    this._startGain(computedTime);
    this._source.start(computedTime);
    return this;
  }
  _stopSource(time2) {
    this._source.stop(time2);
  }
  dispose() {
    super.dispose();
    if (this.state === "started") {
      this.stop();
    }
    this._source.disconnect();
    this.offset.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/signal/Signal.js
var Signal = class _Signal extends ToneAudioNode {
  constructor() {
    super(optionsFromArguments(_Signal.getDefaults(), arguments, ["value", "units"]));
    this.name = "Signal";
    this.override = true;
    const options = optionsFromArguments(_Signal.getDefaults(), arguments, ["value", "units"]);
    this.output = this._constantSource = new ToneConstantSource({
      context: this.context,
      convert: options.convert,
      offset: options.value,
      units: options.units,
      minValue: options.minValue,
      maxValue: options.maxValue
    });
    this._constantSource.start(0);
    this.input = this._param = this._constantSource.offset;
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      convert: true,
      units: "number",
      value: 0
    });
  }
  connect(destination, outputNum = 0, inputNum = 0) {
    connectSignal(this, destination, outputNum, inputNum);
    return this;
  }
  dispose() {
    super.dispose();
    this._param.dispose();
    this._constantSource.dispose();
    return this;
  }
  //-------------------------------------
  // ABSTRACT PARAM INTERFACE
  // just a proxy for the ConstantSourceNode's offset AudioParam
  // all docs are generated from AbstractParam.ts
  //-------------------------------------
  setValueAtTime(value, time2) {
    this._param.setValueAtTime(value, time2);
    return this;
  }
  getValueAtTime(time2) {
    return this._param.getValueAtTime(time2);
  }
  setRampPoint(time2) {
    this._param.setRampPoint(time2);
    return this;
  }
  linearRampToValueAtTime(value, time2) {
    this._param.linearRampToValueAtTime(value, time2);
    return this;
  }
  exponentialRampToValueAtTime(value, time2) {
    this._param.exponentialRampToValueAtTime(value, time2);
    return this;
  }
  exponentialRampTo(value, rampTime, startTime) {
    this._param.exponentialRampTo(value, rampTime, startTime);
    return this;
  }
  linearRampTo(value, rampTime, startTime) {
    this._param.linearRampTo(value, rampTime, startTime);
    return this;
  }
  targetRampTo(value, rampTime, startTime) {
    this._param.targetRampTo(value, rampTime, startTime);
    return this;
  }
  exponentialApproachValueAtTime(value, time2, rampTime) {
    this._param.exponentialApproachValueAtTime(value, time2, rampTime);
    return this;
  }
  setTargetAtTime(value, startTime, timeConstant) {
    this._param.setTargetAtTime(value, startTime, timeConstant);
    return this;
  }
  setValueCurveAtTime(values, startTime, duration, scaling) {
    this._param.setValueCurveAtTime(values, startTime, duration, scaling);
    return this;
  }
  cancelScheduledValues(time2) {
    this._param.cancelScheduledValues(time2);
    return this;
  }
  cancelAndHoldAtTime(time2) {
    this._param.cancelAndHoldAtTime(time2);
    return this;
  }
  rampTo(value, rampTime, startTime) {
    this._param.rampTo(value, rampTime, startTime);
    return this;
  }
  get value() {
    return this._param.value;
  }
  set value(value) {
    this._param.value = value;
  }
  get convert() {
    return this._param.convert;
  }
  set convert(convert) {
    this._param.convert = convert;
  }
  get units() {
    return this._param.units;
  }
  get overridden() {
    return this._param.overridden;
  }
  set overridden(overridden) {
    this._param.overridden = overridden;
  }
  get maxValue() {
    return this._param.maxValue;
  }
  get minValue() {
    return this._param.minValue;
  }
  /**
   * @see {@link Param.apply}.
   */
  apply(param) {
    this._param.apply(param);
    return this;
  }
};
function connectSignal(signal, destination, outputNum, inputNum) {
  if (destination instanceof Param || isAudioParam(destination) || destination instanceof Signal && destination.override) {
    destination.cancelScheduledValues(0);
    destination.setValueAtTime(0, 0);
    if (destination instanceof Signal) {
      destination.overridden = true;
    }
  }
  connect(signal, destination, outputNum, inputNum);
}

// node_modules/@magenta/music/node_modules/tone/build/esm/core/clock/TickParam.js
var TickParam = class _TickParam extends Param {
  constructor() {
    super(optionsFromArguments(_TickParam.getDefaults(), arguments, ["value"]));
    this.name = "TickParam";
    this._events = new Timeline(Infinity);
    this._multiplier = 1;
    const options = optionsFromArguments(_TickParam.getDefaults(), arguments, ["value"]);
    this._multiplier = options.multiplier;
    this._events.cancel(0);
    this._events.add({
      ticks: 0,
      time: 0,
      type: "setValueAtTime",
      value: this._fromType(options.value)
    });
    this.setValueAtTime(options.value, 0);
  }
  static getDefaults() {
    return Object.assign(Param.getDefaults(), {
      multiplier: 1,
      units: "hertz",
      value: 1
    });
  }
  setTargetAtTime(value, time2, constant) {
    time2 = this.toSeconds(time2);
    this.setRampPoint(time2);
    const computedValue = this._fromType(value);
    const prevEvent = this._events.get(time2);
    const segments = Math.round(Math.max(1 / constant, 1));
    for (let i = 0; i <= segments; i++) {
      const segTime = constant * i + time2;
      const rampVal = this._exponentialApproach(prevEvent.time, prevEvent.value, computedValue, constant, segTime);
      this.linearRampToValueAtTime(this._toType(rampVal), segTime);
    }
    return this;
  }
  setValueAtTime(value, time2) {
    const computedTime = this.toSeconds(time2);
    super.setValueAtTime(value, time2);
    const event = this._events.get(computedTime);
    const previousEvent = this._events.previousEvent(event);
    const ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);
    event.ticks = Math.max(ticksUntilTime, 0);
    return this;
  }
  linearRampToValueAtTime(value, time2) {
    const computedTime = this.toSeconds(time2);
    super.linearRampToValueAtTime(value, time2);
    const event = this._events.get(computedTime);
    const previousEvent = this._events.previousEvent(event);
    const ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);
    event.ticks = Math.max(ticksUntilTime, 0);
    return this;
  }
  exponentialRampToValueAtTime(value, time2) {
    time2 = this.toSeconds(time2);
    const computedVal = this._fromType(value);
    const prevEvent = this._events.get(time2);
    const segments = Math.round(Math.max((time2 - prevEvent.time) * 10, 1));
    const segmentDur = (time2 - prevEvent.time) / segments;
    for (let i = 0; i <= segments; i++) {
      const segTime = segmentDur * i + prevEvent.time;
      const rampVal = this._exponentialInterpolate(prevEvent.time, prevEvent.value, time2, computedVal, segTime);
      this.linearRampToValueAtTime(this._toType(rampVal), segTime);
    }
    return this;
  }
  /**
   * Returns the tick value at the time. Takes into account
   * any automation curves scheduled on the signal.
   * @param  event The time to get the tick count at
   * @return The number of ticks which have elapsed at the time given any automations.
   */
  _getTicksUntilEvent(event, time2) {
    if (event === null) {
      event = {
        ticks: 0,
        time: 0,
        type: "setValueAtTime",
        value: 0
      };
    } else if (isUndef(event.ticks)) {
      const previousEvent = this._events.previousEvent(event);
      event.ticks = this._getTicksUntilEvent(previousEvent, event.time);
    }
    const val0 = this._fromType(this.getValueAtTime(event.time));
    let val1 = this._fromType(this.getValueAtTime(time2));
    const onTheLineEvent = this._events.get(time2);
    if (onTheLineEvent && onTheLineEvent.time === time2 && onTheLineEvent.type === "setValueAtTime") {
      val1 = this._fromType(this.getValueAtTime(time2 - this.sampleTime));
    }
    return 0.5 * (time2 - event.time) * (val0 + val1) + event.ticks;
  }
  /**
   * Returns the tick value at the time. Takes into account
   * any automation curves scheduled on the signal.
   * @param  time The time to get the tick count at
   * @return The number of ticks which have elapsed at the time given any automations.
   */
  getTicksAtTime(time2) {
    const computedTime = this.toSeconds(time2);
    const event = this._events.get(computedTime);
    return Math.max(this._getTicksUntilEvent(event, computedTime), 0);
  }
  /**
   * Return the elapsed time of the number of ticks from the given time
   * @param ticks The number of ticks to calculate
   * @param  time The time to get the next tick from
   * @return The duration of the number of ticks from the given time in seconds
   */
  getDurationOfTicks(ticks, time2) {
    const computedTime = this.toSeconds(time2);
    const currentTick = this.getTicksAtTime(time2);
    return this.getTimeOfTick(currentTick + ticks) - computedTime;
  }
  /**
   * Given a tick, returns the time that tick occurs at.
   * @return The time that the tick occurs.
   */
  getTimeOfTick(tick) {
    const before = this._events.get(tick, "ticks");
    const after = this._events.getAfter(tick, "ticks");
    if (before && before.ticks === tick) {
      return before.time;
    } else if (before && after && after.type === "linearRampToValueAtTime" && before.value !== after.value) {
      const val0 = this._fromType(this.getValueAtTime(before.time));
      const val1 = this._fromType(this.getValueAtTime(after.time));
      const delta = (val1 - val0) / (after.time - before.time);
      const k = Math.sqrt(Math.pow(val0, 2) - 2 * delta * (before.ticks - tick));
      const sol1 = (-val0 + k) / delta;
      const sol2 = (-val0 - k) / delta;
      return (sol1 > 0 ? sol1 : sol2) + before.time;
    } else if (before) {
      if (before.value === 0) {
        return Infinity;
      } else {
        return before.time + (tick - before.ticks) / before.value;
      }
    } else {
      return tick / this._initialValue;
    }
  }
  /**
   * Convert some number of ticks their the duration in seconds accounting
   * for any automation curves starting at the given time.
   * @param  ticks The number of ticks to convert to seconds.
   * @param  when  When along the automation timeline to convert the ticks.
   * @return The duration in seconds of the ticks.
   */
  ticksToTime(ticks, when) {
    return this.getDurationOfTicks(ticks, when);
  }
  /**
   * The inverse of {@link ticksToTime}. Convert a duration in
   * seconds to the corresponding number of ticks accounting for any
   * automation curves starting at the given time.
   * @param  duration The time interval to convert to ticks.
   * @param  when When along the automation timeline to convert the ticks.
   * @return The duration in ticks.
   */
  timeToTicks(duration, when) {
    const computedTime = this.toSeconds(when);
    const computedDuration = this.toSeconds(duration);
    const startTicks = this.getTicksAtTime(computedTime);
    const endTicks = this.getTicksAtTime(computedTime + computedDuration);
    return endTicks - startTicks;
  }
  /**
   * Convert from the type when the unit value is BPM
   */
  _fromType(val) {
    if (this.units === "bpm" && this.multiplier) {
      return 1 / (60 / val / this.multiplier);
    } else {
      return super._fromType(val);
    }
  }
  /**
   * Special case of type conversion where the units === "bpm"
   */
  _toType(val) {
    if (this.units === "bpm" && this.multiplier) {
      return val / this.multiplier * 60;
    } else {
      return super._toType(val);
    }
  }
  /**
   * A multiplier on the bpm value. Useful for setting a PPQ relative to the base frequency value.
   */
  get multiplier() {
    return this._multiplier;
  }
  set multiplier(m) {
    const currentVal = this.value;
    this._multiplier = m;
    this.cancelScheduledValues(0);
    this.setValueAtTime(currentVal, 0);
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/core/clock/TickSignal.js
var TickSignal = class _TickSignal extends Signal {
  constructor() {
    super(optionsFromArguments(_TickSignal.getDefaults(), arguments, ["value"]));
    this.name = "TickSignal";
    const options = optionsFromArguments(_TickSignal.getDefaults(), arguments, ["value"]);
    this.input = this._param = new TickParam({
      context: this.context,
      convert: options.convert,
      multiplier: options.multiplier,
      param: this._constantSource.offset,
      units: options.units,
      value: options.value
    });
  }
  static getDefaults() {
    return Object.assign(Signal.getDefaults(), {
      multiplier: 1,
      units: "hertz",
      value: 1
    });
  }
  ticksToTime(ticks, when) {
    return this._param.ticksToTime(ticks, when);
  }
  timeToTicks(duration, when) {
    return this._param.timeToTicks(duration, when);
  }
  getTimeOfTick(tick) {
    return this._param.getTimeOfTick(tick);
  }
  getDurationOfTicks(ticks, time2) {
    return this._param.getDurationOfTicks(ticks, time2);
  }
  getTicksAtTime(time2) {
    return this._param.getTicksAtTime(time2);
  }
  /**
   * A multiplier on the bpm value. Useful for setting a PPQ relative to the base frequency value.
   */
  get multiplier() {
    return this._param.multiplier;
  }
  set multiplier(m) {
    this._param.multiplier = m;
  }
  dispose() {
    super.dispose();
    this._param.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/core/clock/TickSource.js
var TickSource = class _TickSource extends ToneWithContext {
  constructor() {
    super(optionsFromArguments(_TickSource.getDefaults(), arguments, ["frequency"]));
    this.name = "TickSource";
    this._state = new StateTimeline();
    this._tickOffset = new Timeline();
    this._ticksAtTime = new Timeline();
    this._secondsAtTime = new Timeline();
    const options = optionsFromArguments(_TickSource.getDefaults(), arguments, ["frequency"]);
    this.frequency = new TickSignal({
      context: this.context,
      units: options.units,
      value: options.frequency
    });
    readOnly(this, "frequency");
    this._state.setStateAtTime("stopped", 0);
    this.setTicksAtTime(0, 0);
  }
  static getDefaults() {
    return Object.assign({
      frequency: 1,
      units: "hertz"
    }, ToneWithContext.getDefaults());
  }
  /**
   * Returns the playback state of the source, either "started", "stopped" or "paused".
   */
  get state() {
    return this.getStateAtTime(this.now());
  }
  /**
   * Start the clock at the given time. Optionally pass in an offset
   * of where to start the tick counter from.
   * @param  time    The time the clock should start
   * @param offset The number of ticks to start the source at
   */
  start(time2, offset) {
    const computedTime = this.toSeconds(time2);
    if (this._state.getValueAtTime(computedTime) !== "started") {
      this._state.setStateAtTime("started", computedTime);
      if (isDefined(offset)) {
        this.setTicksAtTime(offset, computedTime);
      }
      this._ticksAtTime.cancel(computedTime);
      this._secondsAtTime.cancel(computedTime);
    }
    return this;
  }
  /**
   * Stop the clock. Stopping the clock resets the tick counter to 0.
   * @param time The time when the clock should stop.
   */
  stop(time2) {
    const computedTime = this.toSeconds(time2);
    if (this._state.getValueAtTime(computedTime) === "stopped") {
      const event = this._state.get(computedTime);
      if (event && event.time > 0) {
        this._tickOffset.cancel(event.time);
        this._state.cancel(event.time);
      }
    }
    this._state.cancel(computedTime);
    this._state.setStateAtTime("stopped", computedTime);
    this.setTicksAtTime(0, computedTime);
    this._ticksAtTime.cancel(computedTime);
    this._secondsAtTime.cancel(computedTime);
    return this;
  }
  /**
   * Pause the clock. Pausing does not reset the tick counter.
   * @param time The time when the clock should stop.
   */
  pause(time2) {
    const computedTime = this.toSeconds(time2);
    if (this._state.getValueAtTime(computedTime) === "started") {
      this._state.setStateAtTime("paused", computedTime);
      this._ticksAtTime.cancel(computedTime);
      this._secondsAtTime.cancel(computedTime);
    }
    return this;
  }
  /**
   * Cancel start/stop/pause and setTickAtTime events scheduled after the given time.
   * @param time When to clear the events after
   */
  cancel(time2) {
    time2 = this.toSeconds(time2);
    this._state.cancel(time2);
    this._tickOffset.cancel(time2);
    this._ticksAtTime.cancel(time2);
    this._secondsAtTime.cancel(time2);
    return this;
  }
  /**
   * Get the elapsed ticks at the given time
   * @param  time  When to get the tick value
   * @return The number of ticks
   */
  getTicksAtTime(time2) {
    const computedTime = this.toSeconds(time2);
    const stopEvent = this._state.getLastState("stopped", computedTime);
    const memoizedEvent = this._ticksAtTime.get(computedTime);
    const tmpEvent = { state: "paused", time: computedTime };
    this._state.add(tmpEvent);
    let lastState = memoizedEvent ? memoizedEvent : stopEvent;
    let elapsedTicks = memoizedEvent ? memoizedEvent.ticks : 0;
    let eventToMemoize = null;
    this._state.forEachBetween(lastState.time, computedTime + this.sampleTime, (e) => {
      let periodStartTime = lastState.time;
      const offsetEvent = this._tickOffset.get(e.time);
      if (offsetEvent && offsetEvent.time >= lastState.time) {
        elapsedTicks = offsetEvent.ticks;
        periodStartTime = offsetEvent.time;
      }
      if (lastState.state === "started" && e.state !== "started") {
        elapsedTicks += this.frequency.getTicksAtTime(e.time) - this.frequency.getTicksAtTime(periodStartTime);
        if (e.time !== tmpEvent.time) {
          eventToMemoize = { state: e.state, time: e.time, ticks: elapsedTicks };
        }
      }
      lastState = e;
    });
    this._state.remove(tmpEvent);
    if (eventToMemoize) {
      this._ticksAtTime.add(eventToMemoize);
    }
    return elapsedTicks;
  }
  /**
   * The number of times the callback was invoked. Starts counting at 0
   * and increments after the callback was invoked. Returns -1 when stopped.
   */
  get ticks() {
    return this.getTicksAtTime(this.now());
  }
  set ticks(t) {
    this.setTicksAtTime(t, this.now());
  }
  /**
   * The time since ticks=0 that the TickSource has been running. Accounts
   * for tempo curves
   */
  get seconds() {
    return this.getSecondsAtTime(this.now());
  }
  set seconds(s) {
    const now3 = this.now();
    const ticks = this.frequency.timeToTicks(s, now3);
    this.setTicksAtTime(ticks, now3);
  }
  /**
   * Return the elapsed seconds at the given time.
   * @param  time  When to get the elapsed seconds
   * @return  The number of elapsed seconds
   */
  getSecondsAtTime(time2) {
    time2 = this.toSeconds(time2);
    const stopEvent = this._state.getLastState("stopped", time2);
    const tmpEvent = { state: "paused", time: time2 };
    this._state.add(tmpEvent);
    const memoizedEvent = this._secondsAtTime.get(time2);
    let lastState = memoizedEvent ? memoizedEvent : stopEvent;
    let elapsedSeconds = memoizedEvent ? memoizedEvent.seconds : 0;
    let eventToMemoize = null;
    this._state.forEachBetween(lastState.time, time2 + this.sampleTime, (e) => {
      let periodStartTime = lastState.time;
      const offsetEvent = this._tickOffset.get(e.time);
      if (offsetEvent && offsetEvent.time >= lastState.time) {
        elapsedSeconds = offsetEvent.seconds;
        periodStartTime = offsetEvent.time;
      }
      if (lastState.state === "started" && e.state !== "started") {
        elapsedSeconds += e.time - periodStartTime;
        if (e.time !== tmpEvent.time) {
          eventToMemoize = { state: e.state, time: e.time, seconds: elapsedSeconds };
        }
      }
      lastState = e;
    });
    this._state.remove(tmpEvent);
    if (eventToMemoize) {
      this._secondsAtTime.add(eventToMemoize);
    }
    return elapsedSeconds;
  }
  /**
   * Set the clock's ticks at the given time.
   * @param  ticks The tick value to set
   * @param  time  When to set the tick value
   */
  setTicksAtTime(ticks, time2) {
    time2 = this.toSeconds(time2);
    this._tickOffset.cancel(time2);
    this._tickOffset.add({
      seconds: this.frequency.getDurationOfTicks(ticks, time2),
      ticks,
      time: time2
    });
    this._ticksAtTime.cancel(time2);
    this._secondsAtTime.cancel(time2);
    return this;
  }
  /**
   * Returns the scheduled state at the given time.
   * @param  time  The time to query.
   */
  getStateAtTime(time2) {
    time2 = this.toSeconds(time2);
    return this._state.getValueAtTime(time2);
  }
  /**
   * Get the time of the given tick. The second argument
   * is when to test before. Since ticks can be set (with setTicksAtTime)
   * there may be multiple times for a given tick value.
   * @param  tick The tick number.
   * @param  before When to measure the tick value from.
   * @return The time of the tick
   */
  getTimeOfTick(tick, before = this.now()) {
    const offset = this._tickOffset.get(before);
    const event = this._state.get(before);
    const startTime = Math.max(offset.time, event.time);
    const absoluteTicks = this.frequency.getTicksAtTime(startTime) + tick - offset.ticks;
    return this.frequency.getTimeOfTick(absoluteTicks);
  }
  /**
   * Invoke the callback event at all scheduled ticks between the
   * start time and the end time
   * @param  startTime  The beginning of the search range
   * @param  endTime    The end of the search range
   * @param  callback   The callback to invoke with each tick
   */
  forEachTickBetween(startTime, endTime, callback) {
    let lastStateEvent = this._state.get(startTime);
    this._state.forEachBetween(startTime, endTime, (event) => {
      if (lastStateEvent && lastStateEvent.state === "started" && event.state !== "started") {
        this.forEachTickBetween(Math.max(lastStateEvent.time, startTime), event.time - this.sampleTime, callback);
      }
      lastStateEvent = event;
    });
    let error = null;
    if (lastStateEvent && lastStateEvent.state === "started") {
      const maxStartTime = Math.max(lastStateEvent.time, startTime);
      const startTicks = this.frequency.getTicksAtTime(maxStartTime);
      const ticksAtStart = this.frequency.getTicksAtTime(lastStateEvent.time);
      const diff = startTicks - ticksAtStart;
      let offset = Math.ceil(diff) - diff;
      offset = EQ(offset, 1) ? 0 : offset;
      let nextTickTime = this.frequency.getTimeOfTick(startTicks + offset);
      while (nextTickTime < endTime) {
        try {
          callback(nextTickTime, Math.round(this.getTicksAtTime(nextTickTime)));
        } catch (e) {
          error = e;
          break;
        }
        nextTickTime += this.frequency.getDurationOfTicks(1, nextTickTime);
      }
    }
    if (error) {
      throw error;
    }
    return this;
  }
  /**
   * Clean up
   */
  dispose() {
    super.dispose();
    this._state.dispose();
    this._tickOffset.dispose();
    this._ticksAtTime.dispose();
    this._secondsAtTime.dispose();
    this.frequency.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/core/clock/Clock.js
var Clock = class _Clock extends ToneWithContext {
  constructor() {
    super(optionsFromArguments(_Clock.getDefaults(), arguments, ["callback", "frequency"]));
    this.name = "Clock";
    this.callback = noOp;
    this._lastUpdate = 0;
    this._state = new StateTimeline("stopped");
    this._boundLoop = this._loop.bind(this);
    const options = optionsFromArguments(_Clock.getDefaults(), arguments, ["callback", "frequency"]);
    this.callback = options.callback;
    this._tickSource = new TickSource({
      context: this.context,
      frequency: options.frequency,
      units: options.units
    });
    this._lastUpdate = 0;
    this.frequency = this._tickSource.frequency;
    readOnly(this, "frequency");
    this._state.setStateAtTime("stopped", 0);
    this.context.on("tick", this._boundLoop);
  }
  static getDefaults() {
    return Object.assign(ToneWithContext.getDefaults(), {
      callback: noOp,
      frequency: 1,
      units: "hertz"
    });
  }
  /**
   * Returns the playback state of the source, either "started", "stopped" or "paused".
   */
  get state() {
    return this._state.getValueAtTime(this.now());
  }
  /**
   * Start the clock at the given time. Optionally pass in an offset
   * of where to start the tick counter from.
   * @param  time    The time the clock should start
   * @param offset  Where the tick counter starts counting from.
   */
  start(time2, offset) {
    assertContextRunning(this.context);
    const computedTime = this.toSeconds(time2);
    this.log("start", computedTime);
    if (this._state.getValueAtTime(computedTime) !== "started") {
      this._state.setStateAtTime("started", computedTime);
      this._tickSource.start(computedTime, offset);
      if (computedTime < this._lastUpdate) {
        this.emit("start", computedTime, offset);
      }
    }
    return this;
  }
  /**
   * Stop the clock. Stopping the clock resets the tick counter to 0.
   * @param time The time when the clock should stop.
   * @example
   * const clock = new Tone.Clock(time => {
   * 	console.log(time);
   * }, 1);
   * clock.start();
   * // stop the clock after 10 seconds
   * clock.stop("+10");
   */
  stop(time2) {
    const computedTime = this.toSeconds(time2);
    this.log("stop", computedTime);
    this._state.cancel(computedTime);
    this._state.setStateAtTime("stopped", computedTime);
    this._tickSource.stop(computedTime);
    if (computedTime < this._lastUpdate) {
      this.emit("stop", computedTime);
    }
    return this;
  }
  /**
   * Pause the clock. Pausing does not reset the tick counter.
   * @param time The time when the clock should stop.
   */
  pause(time2) {
    const computedTime = this.toSeconds(time2);
    if (this._state.getValueAtTime(computedTime) === "started") {
      this._state.setStateAtTime("paused", computedTime);
      this._tickSource.pause(computedTime);
      if (computedTime < this._lastUpdate) {
        this.emit("pause", computedTime);
      }
    }
    return this;
  }
  /**
   * The number of times the callback was invoked. Starts counting at 0
   * and increments after the callback was invoked.
   */
  get ticks() {
    return Math.ceil(this.getTicksAtTime(this.now()));
  }
  set ticks(t) {
    this._tickSource.ticks = t;
  }
  /**
   * The time since ticks=0 that the Clock has been running. Accounts for tempo curves
   */
  get seconds() {
    return this._tickSource.seconds;
  }
  set seconds(s) {
    this._tickSource.seconds = s;
  }
  /**
   * Return the elapsed seconds at the given time.
   * @param  time  When to get the elapsed seconds
   * @return  The number of elapsed seconds
   */
  getSecondsAtTime(time2) {
    return this._tickSource.getSecondsAtTime(time2);
  }
  /**
   * Set the clock's ticks at the given time.
   * @param  ticks The tick value to set
   * @param  time  When to set the tick value
   */
  setTicksAtTime(ticks, time2) {
    this._tickSource.setTicksAtTime(ticks, time2);
    return this;
  }
  /**
   * Get the time of the given tick. The second argument
   * is when to test before. Since ticks can be set (with setTicksAtTime)
   * there may be multiple times for a given tick value.
   * @param  tick The tick number.
   * @param  before When to measure the tick value from.
   * @return The time of the tick
   */
  getTimeOfTick(tick, before = this.now()) {
    return this._tickSource.getTimeOfTick(tick, before);
  }
  /**
   * Get the clock's ticks at the given time.
   * @param  time  When to get the tick value
   * @return The tick value at the given time.
   */
  getTicksAtTime(time2) {
    return this._tickSource.getTicksAtTime(time2);
  }
  /**
   * Get the time of the next tick
   * @param  offset The tick number.
   */
  nextTickTime(offset, when) {
    const computedTime = this.toSeconds(when);
    const currentTick = this.getTicksAtTime(computedTime);
    return this._tickSource.getTimeOfTick(currentTick + offset, computedTime);
  }
  /**
   * The scheduling loop.
   */
  _loop() {
    const startTime = this._lastUpdate;
    const endTime = this.now();
    this._lastUpdate = endTime;
    this.log("loop", startTime, endTime);
    if (startTime !== endTime) {
      this._state.forEachBetween(startTime, endTime, (e) => {
        switch (e.state) {
          case "started":
            const offset = this._tickSource.getTicksAtTime(e.time);
            this.emit("start", e.time, offset);
            break;
          case "stopped":
            if (e.time !== 0) {
              this.emit("stop", e.time);
            }
            break;
          case "paused":
            this.emit("pause", e.time);
            break;
        }
      });
      this._tickSource.forEachTickBetween(startTime, endTime, (time2, ticks) => {
        this.callback(time2, ticks);
      });
    }
  }
  /**
   * Returns the scheduled state at the given time.
   * @param  time  The time to query.
   * @return  The name of the state input in setStateAtTime.
   * @example
   * const clock = new Tone.Clock();
   * clock.start("+0.1");
   * clock.getStateAtTime("+0.1"); // returns "started"
   */
  getStateAtTime(time2) {
    const computedTime = this.toSeconds(time2);
    return this._state.getValueAtTime(computedTime);
  }
  /**
   * Clean up
   */
  dispose() {
    super.dispose();
    this.context.off("tick", this._boundLoop);
    this._tickSource.dispose();
    this._state.dispose();
    return this;
  }
};
Emitter.mixin(Clock);

// node_modules/@magenta/music/node_modules/tone/build/esm/core/context/Delay.js
var Delay = class _Delay extends ToneAudioNode {
  constructor() {
    super(optionsFromArguments(_Delay.getDefaults(), arguments, ["delayTime", "maxDelay"]));
    this.name = "Delay";
    const options = optionsFromArguments(_Delay.getDefaults(), arguments, ["delayTime", "maxDelay"]);
    const maxDelayInSeconds = this.toSeconds(options.maxDelay);
    this._maxDelay = Math.max(maxDelayInSeconds, this.toSeconds(options.delayTime));
    this._delayNode = this.input = this.output = this.context.createDelay(maxDelayInSeconds);
    this.delayTime = new Param({
      context: this.context,
      param: this._delayNode.delayTime,
      units: "time",
      value: options.delayTime,
      minValue: 0,
      maxValue: this.maxDelay
    });
    readOnly(this, "delayTime");
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      delayTime: 0,
      maxDelay: 1
    });
  }
  /**
   * The maximum delay time. This cannot be changed after
   * the value is passed into the constructor.
   */
  get maxDelay() {
    return this._maxDelay;
  }
  /**
   * Clean up.
   */
  dispose() {
    super.dispose();
    this._delayNode.disconnect();
    this.delayTime.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/core/context/Offline.js
function Offline(callback, duration, channels = 2, sampleRate = getContext().sampleRate) {
  return __awaiter(this, void 0, void 0, function* () {
    const originalContext = getContext();
    const context2 = new OfflineContext(channels, duration, sampleRate);
    setContext(context2);
    yield callback(context2);
    const bufferPromise = context2.render();
    setContext(originalContext);
    const buffer2 = yield bufferPromise;
    return new ToneAudioBuffer(buffer2);
  });
}

// node_modules/@magenta/music/node_modules/tone/build/esm/core/context/ToneAudioBuffers.js
var ToneAudioBuffers = class _ToneAudioBuffers extends Tone {
  constructor() {
    super();
    this.name = "ToneAudioBuffers";
    this._buffers = /* @__PURE__ */ new Map();
    this._loadingCount = 0;
    const options = optionsFromArguments(_ToneAudioBuffers.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls");
    this.baseUrl = options.baseUrl;
    Object.keys(options.urls).forEach((name) => {
      this._loadingCount++;
      const url = options.urls[name];
      this.add(name, url, this._bufferLoaded.bind(this, options.onload), options.onerror);
    });
  }
  static getDefaults() {
    return {
      baseUrl: "",
      onerror: noOp,
      onload: noOp,
      urls: {}
    };
  }
  /**
   * True if the buffers object has a buffer by that name.
   * @param  name  The key or index of the buffer.
   */
  has(name) {
    return this._buffers.has(name.toString());
  }
  /**
   * Get a buffer by name. If an array was loaded,
   * then use the array index.
   * @param  name  The key or index of the buffer.
   */
  get(name) {
    assert(this.has(name), `ToneAudioBuffers has no buffer named: ${name}`);
    return this._buffers.get(name.toString());
  }
  /**
   * A buffer was loaded. decrement the counter.
   */
  _bufferLoaded(callback) {
    this._loadingCount--;
    if (this._loadingCount === 0 && callback) {
      callback();
    }
  }
  /**
   * If the buffers are loaded or not
   */
  get loaded() {
    return Array.from(this._buffers).every(([_, buffer2]) => buffer2.loaded);
  }
  /**
   * Add a buffer by name and url to the Buffers
   * @param  name      A unique name to give the buffer
   * @param  url  Either the url of the bufer, or a buffer which will be added with the given name.
   * @param  callback  The callback to invoke when the url is loaded.
   * @param  onerror  Invoked if the buffer can't be loaded
   */
  add(name, url, callback = noOp, onerror = noOp) {
    if (isString(url)) {
      if (this.baseUrl && url.trim().substring(0, 11).toLowerCase() === "data:audio/") {
        this.baseUrl = "";
      }
      this._buffers.set(name.toString(), new ToneAudioBuffer(this.baseUrl + url, callback, onerror));
    } else {
      this._buffers.set(name.toString(), new ToneAudioBuffer(url, callback, onerror));
    }
    return this;
  }
  dispose() {
    super.dispose();
    this._buffers.forEach((buffer2) => buffer2.dispose());
    this._buffers.clear();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/core/type/Midi.js
var MidiClass = class _MidiClass extends FrequencyClass {
  constructor() {
    super(...arguments);
    this.name = "MidiClass";
    this.defaultUnits = "midi";
  }
  /**
   * Returns the value of a frequency in the current units
   */
  _frequencyToUnits(freq) {
    return ftom(super._frequencyToUnits(freq));
  }
  /**
   * Returns the value of a tick in the current time units
   */
  _ticksToUnits(ticks) {
    return ftom(super._ticksToUnits(ticks));
  }
  /**
   * Return the value of the beats in the current units
   */
  _beatsToUnits(beats) {
    return ftom(super._beatsToUnits(beats));
  }
  /**
   * Returns the value of a second in the current units
   */
  _secondsToUnits(seconds) {
    return ftom(super._secondsToUnits(seconds));
  }
  /**
   * Return the value of the frequency as a MIDI note
   * @example
   * Tone.Midi(60).toMidi(); // 60
   */
  toMidi() {
    return this.valueOf();
  }
  /**
   * Return the value of the frequency as a MIDI note
   * @example
   * Tone.Midi(60).toFrequency(); // 261.6255653005986
   */
  toFrequency() {
    return mtof(this.toMidi());
  }
  /**
   * Transposes the frequency by the given number of semitones.
   * @return A new transposed MidiClass
   * @example
   * Tone.Midi("A4").transpose(3); // "C5"
   */
  transpose(interval) {
    return new _MidiClass(this.context, this.toMidi() + interval);
  }
};
function Midi(value, units) {
  return new MidiClass(getContext(), value, units);
}

// node_modules/@magenta/music/node_modules/tone/build/esm/core/type/Ticks.js
var TicksClass = class extends TransportTimeClass {
  constructor() {
    super(...arguments);
    this.name = "Ticks";
    this.defaultUnits = "i";
  }
  /**
   * Get the current time in the given units
   */
  _now() {
    return this.context.transport.ticks;
  }
  /**
   * Return the value of the beats in the current units
   */
  _beatsToUnits(beats) {
    return this._getPPQ() * beats;
  }
  /**
   * Returns the value of a second in the current units
   */
  _secondsToUnits(seconds) {
    return Math.floor(seconds / (60 / this._getBpm()) * this._getPPQ());
  }
  /**
   * Returns the value of a tick in the current time units
   */
  _ticksToUnits(ticks) {
    return ticks;
  }
  /**
   * Return the time in ticks
   */
  toTicks() {
    return this.valueOf();
  }
  /**
   * Return the time in seconds
   */
  toSeconds() {
    return this.valueOf() / this._getPPQ() * (60 / this._getBpm());
  }
};
function Ticks(value, units) {
  return new TicksClass(getContext(), value, units);
}

// node_modules/@magenta/music/node_modules/tone/build/esm/core/util/Draw.js
var DrawClass = class extends ToneWithContext {
  constructor() {
    super(...arguments);
    this.name = "Draw";
    this.expiration = 0.25;
    this.anticipation = 8e-3;
    this._events = new Timeline();
    this._boundDrawLoop = this._drawLoop.bind(this);
    this._animationFrame = -1;
  }
  /**
   * Schedule a function at the given time to be invoked
   * on the nearest animation frame.
   * @param  callback  Callback is invoked at the given time.
   * @param  time      The time relative to the AudioContext time to invoke the callback.
   * @example
   * Tone.Transport.scheduleRepeat(time => {
   * 	Tone.Draw.schedule(() => console.log(time), time);
   * }, 1);
   * Tone.Transport.start();
   */
  schedule(callback, time2) {
    this._events.add({
      callback,
      time: this.toSeconds(time2)
    });
    if (this._events.length === 1) {
      this._animationFrame = requestAnimationFrame(this._boundDrawLoop);
    }
    return this;
  }
  /**
   * Cancel events scheduled after the given time
   * @param  after  Time after which scheduled events will be removed from the scheduling timeline.
   */
  cancel(after) {
    this._events.cancel(this.toSeconds(after));
    return this;
  }
  /**
   * The draw loop
   */
  _drawLoop() {
    const now3 = this.context.currentTime;
    while (this._events.length && this._events.peek().time - this.anticipation <= now3) {
      const event = this._events.shift();
      if (event && now3 - event.time <= this.expiration) {
        event.callback();
      }
    }
    if (this._events.length > 0) {
      this._animationFrame = requestAnimationFrame(this._boundDrawLoop);
    }
  }
  dispose() {
    super.dispose();
    this._events.dispose();
    cancelAnimationFrame(this._animationFrame);
    return this;
  }
};
onContextInit((context2) => {
  context2.draw = new DrawClass({ context: context2 });
});
onContextClose((context2) => {
  context2.draw.dispose();
});

// node_modules/@magenta/music/node_modules/tone/build/esm/core/util/IntervalTimeline.js
var IntervalTimeline = class extends Tone {
  constructor() {
    super(...arguments);
    this.name = "IntervalTimeline";
    this._root = null;
    this._length = 0;
  }
  /**
   * The event to add to the timeline. All events must
   * have a time and duration value
   * @param  event  The event to add to the timeline
   */
  add(event) {
    assert(isDefined(event.time), "Events must have a time property");
    assert(isDefined(event.duration), "Events must have a duration parameter");
    event.time = event.time.valueOf();
    let node = new IntervalNode(event.time, event.time + event.duration, event);
    if (this._root === null) {
      this._root = node;
    } else {
      this._root.insert(node);
    }
    this._length++;
    while (node !== null) {
      node.updateHeight();
      node.updateMax();
      this._rebalance(node);
      node = node.parent;
    }
    return this;
  }
  /**
   * Remove an event from the timeline.
   * @param  event  The event to remove from the timeline
   */
  remove(event) {
    if (this._root !== null) {
      const results = [];
      this._root.search(event.time, results);
      for (const node of results) {
        if (node.event === event) {
          this._removeNode(node);
          this._length--;
          break;
        }
      }
    }
    return this;
  }
  /**
   * The number of items in the timeline.
   * @readOnly
   */
  get length() {
    return this._length;
  }
  /**
   * Remove events whose time time is after the given time
   * @param  after  The time to query.
   */
  cancel(after) {
    this.forEachFrom(after, (event) => this.remove(event));
    return this;
  }
  /**
   * Set the root node as the given node
   */
  _setRoot(node) {
    this._root = node;
    if (this._root !== null) {
      this._root.parent = null;
    }
  }
  /**
   * Replace the references to the node in the node's parent
   * with the replacement node.
   */
  _replaceNodeInParent(node, replacement) {
    if (node.parent !== null) {
      if (node.isLeftChild()) {
        node.parent.left = replacement;
      } else {
        node.parent.right = replacement;
      }
      this._rebalance(node.parent);
    } else {
      this._setRoot(replacement);
    }
  }
  /**
   * Remove the node from the tree and replace it with
   * a successor which follows the schema.
   */
  _removeNode(node) {
    if (node.left === null && node.right === null) {
      this._replaceNodeInParent(node, null);
    } else if (node.right === null) {
      this._replaceNodeInParent(node, node.left);
    } else if (node.left === null) {
      this._replaceNodeInParent(node, node.right);
    } else {
      const balance = node.getBalance();
      let replacement;
      let temp = null;
      if (balance > 0) {
        if (node.left.right === null) {
          replacement = node.left;
          replacement.right = node.right;
          temp = replacement;
        } else {
          replacement = node.left.right;
          while (replacement.right !== null) {
            replacement = replacement.right;
          }
          if (replacement.parent) {
            replacement.parent.right = replacement.left;
            temp = replacement.parent;
            replacement.left = node.left;
            replacement.right = node.right;
          }
        }
      } else if (node.right.left === null) {
        replacement = node.right;
        replacement.left = node.left;
        temp = replacement;
      } else {
        replacement = node.right.left;
        while (replacement.left !== null) {
          replacement = replacement.left;
        }
        if (replacement.parent) {
          replacement.parent.left = replacement.right;
          temp = replacement.parent;
          replacement.left = node.left;
          replacement.right = node.right;
        }
      }
      if (node.parent !== null) {
        if (node.isLeftChild()) {
          node.parent.left = replacement;
        } else {
          node.parent.right = replacement;
        }
      } else {
        this._setRoot(replacement);
      }
      if (temp) {
        this._rebalance(temp);
      }
    }
    node.dispose();
  }
  /**
   * Rotate the tree to the left
   */
  _rotateLeft(node) {
    const parent = node.parent;
    const isLeftChild = node.isLeftChild();
    const pivotNode = node.right;
    if (pivotNode) {
      node.right = pivotNode.left;
      pivotNode.left = node;
    }
    if (parent !== null) {
      if (isLeftChild) {
        parent.left = pivotNode;
      } else {
        parent.right = pivotNode;
      }
    } else {
      this._setRoot(pivotNode);
    }
  }
  /**
   * Rotate the tree to the right
   */
  _rotateRight(node) {
    const parent = node.parent;
    const isLeftChild = node.isLeftChild();
    const pivotNode = node.left;
    if (pivotNode) {
      node.left = pivotNode.right;
      pivotNode.right = node;
    }
    if (parent !== null) {
      if (isLeftChild) {
        parent.left = pivotNode;
      } else {
        parent.right = pivotNode;
      }
    } else {
      this._setRoot(pivotNode);
    }
  }
  /**
   * Balance the BST
   */
  _rebalance(node) {
    const balance = node.getBalance();
    if (balance > 1 && node.left) {
      if (node.left.getBalance() < 0) {
        this._rotateLeft(node.left);
      } else {
        this._rotateRight(node);
      }
    } else if (balance < -1 && node.right) {
      if (node.right.getBalance() > 0) {
        this._rotateRight(node.right);
      } else {
        this._rotateLeft(node);
      }
    }
  }
  /**
   * Get an event whose time and duration span the give time. Will
   * return the match whose "time" value is closest to the given time.
   * @return  The event which spans the desired time
   */
  get(time2) {
    if (this._root !== null) {
      const results = [];
      this._root.search(time2, results);
      if (results.length > 0) {
        let max2 = results[0];
        for (let i = 1; i < results.length; i++) {
          if (results[i].low > max2.low) {
            max2 = results[i];
          }
        }
        return max2.event;
      }
    }
    return null;
  }
  /**
   * Iterate over everything in the timeline.
   * @param  callback The callback to invoke with every item
   */
  forEach(callback) {
    if (this._root !== null) {
      const allNodes = [];
      this._root.traverse((node) => allNodes.push(node));
      allNodes.forEach((node) => {
        if (node.event) {
          callback(node.event);
        }
      });
    }
    return this;
  }
  /**
   * Iterate over everything in the array in which the given time
   * overlaps with the time and duration time of the event.
   * @param  time The time to check if items are overlapping
   * @param  callback The callback to invoke with every item
   */
  forEachAtTime(time2, callback) {
    if (this._root !== null) {
      const results = [];
      this._root.search(time2, results);
      results.forEach((node) => {
        if (node.event) {
          callback(node.event);
        }
      });
    }
    return this;
  }
  /**
   * Iterate over everything in the array in which the time is greater
   * than or equal to the given time.
   * @param  time The time to check if items are before
   * @param  callback The callback to invoke with every item
   */
  forEachFrom(time2, callback) {
    if (this._root !== null) {
      const results = [];
      this._root.searchAfter(time2, results);
      results.forEach((node) => {
        if (node.event) {
          callback(node.event);
        }
      });
    }
    return this;
  }
  /**
   * Clean up
   */
  dispose() {
    super.dispose();
    if (this._root !== null) {
      this._root.traverse((node) => node.dispose());
    }
    this._root = null;
    return this;
  }
};
var IntervalNode = class {
  constructor(low, high, event) {
    this._left = null;
    this._right = null;
    this.parent = null;
    this.height = 0;
    this.event = event;
    this.low = low;
    this.high = high;
    this.max = this.high;
  }
  /**
   * Insert a node into the correct spot in the tree
   */
  insert(node) {
    if (node.low <= this.low) {
      if (this.left === null) {
        this.left = node;
      } else {
        this.left.insert(node);
      }
    } else if (this.right === null) {
      this.right = node;
    } else {
      this.right.insert(node);
    }
  }
  /**
   * Search the tree for nodes which overlap
   * with the given point
   * @param  point  The point to query
   * @param  results  The array to put the results
   */
  search(point, results) {
    if (point > this.max) {
      return;
    }
    if (this.left !== null) {
      this.left.search(point, results);
    }
    if (this.low <= point && this.high > point) {
      results.push(this);
    }
    if (this.low > point) {
      return;
    }
    if (this.right !== null) {
      this.right.search(point, results);
    }
  }
  /**
   * Search the tree for nodes which are less
   * than the given point
   * @param  point  The point to query
   * @param  results  The array to put the results
   */
  searchAfter(point, results) {
    if (this.low >= point) {
      results.push(this);
      if (this.left !== null) {
        this.left.searchAfter(point, results);
      }
    }
    if (this.right !== null) {
      this.right.searchAfter(point, results);
    }
  }
  /**
   * Invoke the callback on this element and both it's branches
   * @param  {Function}  callback
   */
  traverse(callback) {
    callback(this);
    if (this.left !== null) {
      this.left.traverse(callback);
    }
    if (this.right !== null) {
      this.right.traverse(callback);
    }
  }
  /**
   * Update the height of the node
   */
  updateHeight() {
    if (this.left !== null && this.right !== null) {
      this.height = Math.max(this.left.height, this.right.height) + 1;
    } else if (this.right !== null) {
      this.height = this.right.height + 1;
    } else if (this.left !== null) {
      this.height = this.left.height + 1;
    } else {
      this.height = 0;
    }
  }
  /**
   * Update the height of the node
   */
  updateMax() {
    this.max = this.high;
    if (this.left !== null) {
      this.max = Math.max(this.max, this.left.max);
    }
    if (this.right !== null) {
      this.max = Math.max(this.max, this.right.max);
    }
  }
  /**
   * The balance is how the leafs are distributed on the node
   * @return  Negative numbers are balanced to the right
   */
  getBalance() {
    let balance = 0;
    if (this.left !== null && this.right !== null) {
      balance = this.left.height - this.right.height;
    } else if (this.left !== null) {
      balance = this.left.height + 1;
    } else if (this.right !== null) {
      balance = -(this.right.height + 1);
    }
    return balance;
  }
  /**
   * @returns true if this node is the left child of its parent
   */
  isLeftChild() {
    return this.parent !== null && this.parent.left === this;
  }
  /**
   * get/set the left node
   */
  get left() {
    return this._left;
  }
  set left(node) {
    this._left = node;
    if (node !== null) {
      node.parent = this;
    }
    this.updateHeight();
    this.updateMax();
  }
  /**
   * get/set the right node
   */
  get right() {
    return this._right;
  }
  set right(node) {
    this._right = node;
    if (node !== null) {
      node.parent = this;
    }
    this.updateHeight();
    this.updateMax();
  }
  /**
   * null out references.
   */
  dispose() {
    this.parent = null;
    this._left = null;
    this._right = null;
    this.event = null;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/core/type/Units.js
var Units_exports = {};

// node_modules/@magenta/music/node_modules/tone/build/esm/component/channel/Volume.js
var Volume = class _Volume extends ToneAudioNode {
  constructor() {
    super(optionsFromArguments(_Volume.getDefaults(), arguments, ["volume"]));
    this.name = "Volume";
    const options = optionsFromArguments(_Volume.getDefaults(), arguments, ["volume"]);
    this.input = this.output = new Gain({
      context: this.context,
      gain: options.volume,
      units: "decibels"
    });
    this.volume = this.output.gain;
    readOnly(this, "volume");
    this._unmutedVolume = options.volume;
    this.mute = options.mute;
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      mute: false,
      volume: 0
    });
  }
  /**
   * Mute the output.
   * @example
   * const vol = new Tone.Volume(-12).toDestination();
   * const osc = new Tone.Oscillator().connect(vol).start();
   * // mute the output
   * vol.mute = true;
   */
  get mute() {
    return this.volume.value === -Infinity;
  }
  set mute(mute) {
    if (!this.mute && mute) {
      this._unmutedVolume = this.volume.value;
      this.volume.value = -Infinity;
    } else if (this.mute && !mute) {
      this.volume.value = this._unmutedVolume;
    }
  }
  /**
   * clean up
   */
  dispose() {
    super.dispose();
    this.input.dispose();
    this.volume.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/core/context/Destination.js
var DestinationClass = class _DestinationClass extends ToneAudioNode {
  constructor() {
    super(optionsFromArguments(_DestinationClass.getDefaults(), arguments));
    this.name = "Destination";
    this.input = new Volume({ context: this.context });
    this.output = new Gain({ context: this.context });
    this.volume = this.input.volume;
    const options = optionsFromArguments(_DestinationClass.getDefaults(), arguments);
    connectSeries(this.input, this.output, this.context.rawContext.destination);
    this.mute = options.mute;
    this._internalChannels = [this.input, this.context.rawContext.destination, this.output];
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      mute: false,
      volume: 0
    });
  }
  /**
   * Mute the output.
   * @example
   * const oscillator = new Tone.Oscillator().start().toDestination();
   * setTimeout(() => {
   * 	// mute the output
   * 	Tone.Destination.mute = true;
   * }, 1000);
   */
  get mute() {
    return this.input.mute;
  }
  set mute(mute) {
    this.input.mute = mute;
  }
  /**
   * Add a master effects chain. NOTE: this will disconnect any nodes which were previously
   * chained in the master effects chain.
   * @param args All arguments will be connected in a row and the Master will be routed through it.
   * @example
   * // route all audio through a filter and compressor
   * const lowpass = new Tone.Filter(800, "lowpass");
   * const compressor = new Tone.Compressor(-18);
   * Tone.Destination.chain(lowpass, compressor);
   */
  chain(...args) {
    this.input.disconnect();
    args.unshift(this.input);
    args.push(this.output);
    connectSeries(...args);
    return this;
  }
  /**
   * The maximum number of channels the system can output
   * @example
   * console.log(Tone.Destination.maxChannelCount);
   */
  get maxChannelCount() {
    return this.context.rawContext.destination.maxChannelCount;
  }
  /**
   * Clean up
   */
  dispose() {
    super.dispose();
    this.volume.dispose();
    return this;
  }
};
onContextInit((context2) => {
  context2.destination = new DestinationClass({ context: context2 });
});
onContextClose((context2) => {
  context2.destination.dispose();
});

// node_modules/@magenta/music/node_modules/tone/build/esm/core/util/TimelineValue.js
var TimelineValue = class extends Tone {
  /**
   * @param initialValue The value to return if there is no scheduled values
   */
  constructor(initialValue) {
    super();
    this.name = "TimelineValue";
    this._timeline = new Timeline({ memory: 10 });
    this._initialValue = initialValue;
  }
  /**
   * Set the value at the given time
   */
  set(value, time2) {
    this._timeline.add({
      value,
      time: time2
    });
    return this;
  }
  /**
   * Get the value at the given time
   */
  get(time2) {
    const event = this._timeline.get(time2);
    if (event) {
      return event.value;
    } else {
      return this._initialValue;
    }
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/signal/SignalOperator.js
var SignalOperator = class _SignalOperator extends ToneAudioNode {
  constructor() {
    super(Object.assign(optionsFromArguments(_SignalOperator.getDefaults(), arguments, ["context"])));
  }
  connect(destination, outputNum = 0, inputNum = 0) {
    connectSignal(this, destination, outputNum, inputNum);
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/signal/WaveShaper.js
var WaveShaper = class _WaveShaper extends SignalOperator {
  constructor() {
    super(Object.assign(optionsFromArguments(_WaveShaper.getDefaults(), arguments, ["mapping", "length"])));
    this.name = "WaveShaper";
    this._shaper = this.context.createWaveShaper();
    this.input = this._shaper;
    this.output = this._shaper;
    const options = optionsFromArguments(_WaveShaper.getDefaults(), arguments, ["mapping", "length"]);
    if (isArray(options.mapping) || options.mapping instanceof Float32Array) {
      this.curve = Float32Array.from(options.mapping);
    } else if (isFunction(options.mapping)) {
      this.setMap(options.mapping, options.length);
    }
  }
  static getDefaults() {
    return Object.assign(Signal.getDefaults(), {
      length: 1024
    });
  }
  /**
   * Uses a mapping function to set the value of the curve.
   * @param mapping The function used to define the values.
   *                The mapping function take two arguments:
   *                the first is the value at the current position
   *                which goes from -1 to 1 over the number of elements
   *                in the curve array. The second argument is the array position.
   * @example
   * const shaper = new Tone.WaveShaper();
   * // map the input signal from [-1, 1] to [0, 10]
   * shaper.setMap((val, index) => (val + 1) * 5);
   */
  setMap(mapping, length = 1024) {
    const array = new Float32Array(length);
    for (let i = 0, len = length; i < len; i++) {
      const normalized = i / (len - 1) * 2 - 1;
      array[i] = mapping(normalized, i);
    }
    this.curve = array;
    return this;
  }
  /**
   * The array to set as the waveshaper curve. For linear curves
   * array length does not make much difference, but for complex curves
   * longer arrays will provide smoother interpolation.
   */
  get curve() {
    return this._shaper.curve;
  }
  set curve(mapping) {
    this._shaper.curve = mapping;
  }
  /**
   * Specifies what type of oversampling (if any) should be used when
   * applying the shaping curve. Can either be "none", "2x" or "4x".
   */
  get oversample() {
    return this._shaper.oversample;
  }
  set oversample(oversampling) {
    const isOverSampleType = ["none", "2x", "4x"].some((str) => str.includes(oversampling));
    assert(isOverSampleType, "oversampling must be either 'none', '2x', or '4x'");
    this._shaper.oversample = oversampling;
  }
  /**
   * Clean up.
   */
  dispose() {
    super.dispose();
    this._shaper.disconnect();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/signal/Pow.js
var Pow = class _Pow extends SignalOperator {
  constructor() {
    super(Object.assign(optionsFromArguments(_Pow.getDefaults(), arguments, ["value"])));
    this.name = "Pow";
    const options = optionsFromArguments(_Pow.getDefaults(), arguments, ["value"]);
    this._exponentScaler = this.input = this.output = new WaveShaper({
      context: this.context,
      mapping: this._expFunc(options.value),
      length: 8192
    });
    this._exponent = options.value;
  }
  static getDefaults() {
    return Object.assign(SignalOperator.getDefaults(), {
      value: 1
    });
  }
  /**
   * the function which maps the waveshaper
   * @param exponent exponent value
   */
  _expFunc(exponent) {
    return (val) => {
      return Math.pow(Math.abs(val), exponent);
    };
  }
  /**
   * The value of the exponent.
   */
  get value() {
    return this._exponent;
  }
  set value(exponent) {
    this._exponent = exponent;
    this._exponentScaler.setMap(this._expFunc(this._exponent));
  }
  /**
   * Clean up.
   */
  dispose() {
    super.dispose();
    this._exponentScaler.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/core/clock/TransportEvent.js
var TransportEvent = class _TransportEvent {
  /**
   * @param transport The transport object which the event belongs to
   */
  constructor(transport, opts) {
    this.id = _TransportEvent._eventId++;
    this._remainderTime = 0;
    const options = Object.assign(_TransportEvent.getDefaults(), opts);
    this.transport = transport;
    this.callback = options.callback;
    this._once = options.once;
    this.time = Math.floor(options.time);
    this._remainderTime = options.time - this.time;
  }
  static getDefaults() {
    return {
      callback: noOp,
      once: false,
      time: 0
    };
  }
  /**
   * Get the time and remainder time.
   */
  get floatTime() {
    return this.time + this._remainderTime;
  }
  /**
   * Invoke the event callback.
   * @param  time  The AudioContext time in seconds of the event
   */
  invoke(time2) {
    if (this.callback) {
      const tickDuration = this.transport.bpm.getDurationOfTicks(1, time2);
      this.callback(time2 + this._remainderTime * tickDuration);
      if (this._once) {
        this.transport.clear(this.id);
      }
    }
  }
  /**
   * Clean up
   */
  dispose() {
    this.callback = void 0;
    return this;
  }
};
TransportEvent._eventId = 0;

// node_modules/@magenta/music/node_modules/tone/build/esm/core/clock/TransportRepeatEvent.js
var TransportRepeatEvent = class _TransportRepeatEvent extends TransportEvent {
  /**
   * @param transport The transport object which the event belongs to
   */
  constructor(transport, opts) {
    super(transport, opts);
    this._currentId = -1;
    this._nextId = -1;
    this._nextTick = this.time;
    this._boundRestart = this._restart.bind(this);
    const options = Object.assign(_TransportRepeatEvent.getDefaults(), opts);
    this.duration = options.duration;
    this._interval = options.interval;
    this._nextTick = options.time;
    this.transport.on("start", this._boundRestart);
    this.transport.on("loopStart", this._boundRestart);
    this.transport.on("ticks", this._boundRestart);
    this.context = this.transport.context;
    this._restart();
  }
  static getDefaults() {
    return Object.assign({}, TransportEvent.getDefaults(), {
      duration: Infinity,
      interval: 1,
      once: false
    });
  }
  /**
   * Invoke the callback. Returns the tick time which
   * the next event should be scheduled at.
   * @param  time  The AudioContext time in seconds of the event
   */
  invoke(time2) {
    this._createEvents(time2);
    super.invoke(time2);
  }
  /**
   * Create an event on the transport on the nextTick
   */
  _createEvent() {
    if (LT(this._nextTick, this.floatTime + this.duration)) {
      return this.transport.scheduleOnce(this.invoke.bind(this), new TicksClass(this.context, this._nextTick).toSeconds());
    }
    return -1;
  }
  /**
   * Push more events onto the timeline to keep up with the position of the timeline
   */
  _createEvents(time2) {
    if (LT(this._nextTick + this._interval, this.floatTime + this.duration)) {
      this._nextTick += this._interval;
      this._currentId = this._nextId;
      this._nextId = this.transport.scheduleOnce(this.invoke.bind(this), new TicksClass(this.context, this._nextTick).toSeconds());
    }
  }
  /**
   * Re-compute the events when the transport time has changed from a start/ticks/loopStart event
   */
  _restart(time2) {
    this.transport.clear(this._currentId);
    this.transport.clear(this._nextId);
    this._nextTick = this.floatTime;
    const ticks = this.transport.getTicksAtTime(time2);
    if (GT(ticks, this.time)) {
      this._nextTick = this.floatTime + Math.ceil((ticks - this.floatTime) / this._interval) * this._interval;
    }
    this._currentId = this._createEvent();
    this._nextTick += this._interval;
    this._nextId = this._createEvent();
  }
  /**
   * Clean up
   */
  dispose() {
    super.dispose();
    this.transport.clear(this._currentId);
    this.transport.clear(this._nextId);
    this.transport.off("start", this._boundRestart);
    this.transport.off("loopStart", this._boundRestart);
    this.transport.off("ticks", this._boundRestart);
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/core/clock/Transport.js
var TransportClass = class _TransportClass extends ToneWithContext {
  constructor() {
    super(optionsFromArguments(_TransportClass.getDefaults(), arguments));
    this.name = "Transport";
    this._loop = new TimelineValue(false);
    this._loopStart = 0;
    this._loopEnd = 0;
    this._scheduledEvents = {};
    this._timeline = new Timeline();
    this._repeatedEvents = new IntervalTimeline();
    this._syncedSignals = [];
    this._swingAmount = 0;
    const options = optionsFromArguments(_TransportClass.getDefaults(), arguments);
    this._ppq = options.ppq;
    this._clock = new Clock({
      callback: this._processTick.bind(this),
      context: this.context,
      frequency: 0,
      units: "bpm"
    });
    this._bindClockEvents();
    this.bpm = this._clock.frequency;
    this._clock.frequency.multiplier = options.ppq;
    this.bpm.setValueAtTime(options.bpm, 0);
    readOnly(this, "bpm");
    this._timeSignature = options.timeSignature;
    this._swingTicks = options.ppq / 2;
  }
  static getDefaults() {
    return Object.assign(ToneWithContext.getDefaults(), {
      bpm: 120,
      loopEnd: "4m",
      loopStart: 0,
      ppq: 192,
      swing: 0,
      swingSubdivision: "8n",
      timeSignature: 4
    });
  }
  //-------------------------------------
  // 	TICKS
  //-------------------------------------
  /**
   * called on every tick
   * @param  tickTime clock relative tick time
   */
  _processTick(tickTime, ticks) {
    if (this._loop.get(tickTime)) {
      if (ticks >= this._loopEnd) {
        this.emit("loopEnd", tickTime);
        this._clock.setTicksAtTime(this._loopStart, tickTime);
        ticks = this._loopStart;
        this.emit("loopStart", tickTime, this._clock.getSecondsAtTime(tickTime));
        this.emit("loop", tickTime);
      }
    }
    if (this._swingAmount > 0 && ticks % this._ppq !== 0 && // not on a downbeat
    ticks % (this._swingTicks * 2) !== 0) {
      const progress = ticks % (this._swingTicks * 2) / (this._swingTicks * 2);
      const amount = Math.sin(progress * Math.PI) * this._swingAmount;
      tickTime += new TicksClass(this.context, this._swingTicks * 2 / 3).toSeconds() * amount;
    }
    enterScheduledCallback(true);
    this._timeline.forEachAtTime(ticks, (event) => event.invoke(tickTime));
    enterScheduledCallback(false);
  }
  //-------------------------------------
  // 	SCHEDULABLE EVENTS
  //-------------------------------------
  /**
   * Schedule an event along the timeline.
   * @param callback The callback to be invoked at the time.
   * @param time The time to invoke the callback at.
   * @return The id of the event which can be used for canceling the event.
   * @example
   * // schedule an event on the 16th measure
   * Tone.getTransport().schedule((time) => {
   * 	// invoked on measure 16
   * 	console.log("measure 16!");
   * }, "16:0:0");
   */
  schedule(callback, time2) {
    const event = new TransportEvent(this, {
      callback,
      time: new TransportTimeClass(this.context, time2).toTicks()
    });
    return this._addEvent(event, this._timeline);
  }
  /**
   * Schedule a repeated event along the timeline. The event will fire
   * at the `interval` starting at the `startTime` and for the specified
   * `duration`.
   * @param  callback   The callback to invoke.
   * @param  interval   The duration between successive callbacks. Must be a positive number.
   * @param  startTime  When along the timeline the events should start being invoked.
   * @param  duration How long the event should repeat.
   * @return  The ID of the scheduled event. Use this to cancel the event.
   * @example
   * const osc = new Tone.Oscillator().toDestination().start();
   * // a callback invoked every eighth note after the first measure
   * Tone.getTransport().scheduleRepeat((time) => {
   * 	osc.start(time).stop(time + 0.1);
   * }, "8n", "1m");
   */
  scheduleRepeat(callback, interval, startTime, duration = Infinity) {
    const event = new TransportRepeatEvent(this, {
      callback,
      duration: new TimeClass(this.context, duration).toTicks(),
      interval: new TimeClass(this.context, interval).toTicks(),
      time: new TransportTimeClass(this.context, startTime).toTicks()
    });
    return this._addEvent(event, this._repeatedEvents);
  }
  /**
   * Schedule an event that will be removed after it is invoked.
   * @param callback The callback to invoke once.
   * @param time The time the callback should be invoked.
   * @returns The ID of the scheduled event.
   */
  scheduleOnce(callback, time2) {
    const event = new TransportEvent(this, {
      callback,
      once: true,
      time: new TransportTimeClass(this.context, time2).toTicks()
    });
    return this._addEvent(event, this._timeline);
  }
  /**
   * Clear the passed in event id from the timeline
   * @param eventId The id of the event.
   */
  clear(eventId) {
    if (this._scheduledEvents.hasOwnProperty(eventId)) {
      const item = this._scheduledEvents[eventId.toString()];
      item.timeline.remove(item.event);
      item.event.dispose();
      delete this._scheduledEvents[eventId.toString()];
    }
    return this;
  }
  /**
   * Add an event to the correct timeline. Keep track of the
   * timeline it was added to.
   * @returns the event id which was just added
   */
  _addEvent(event, timeline) {
    this._scheduledEvents[event.id.toString()] = {
      event,
      timeline
    };
    timeline.add(event);
    return event.id;
  }
  /**
   * Remove scheduled events from the timeline after
   * the given time. Repeated events will be removed
   * if their startTime is after the given time
   * @param after Clear all events after this time.
   */
  cancel(after = 0) {
    const computedAfter = this.toTicks(after);
    this._timeline.forEachFrom(computedAfter, (event) => this.clear(event.id));
    this._repeatedEvents.forEachFrom(computedAfter, (event) => this.clear(event.id));
    return this;
  }
  //-------------------------------------
  // 	START/STOP/PAUSE
  //-------------------------------------
  /**
   * Bind start/stop/pause events from the clock and emit them.
   */
  _bindClockEvents() {
    this._clock.on("start", (time2, offset) => {
      offset = new TicksClass(this.context, offset).toSeconds();
      this.emit("start", time2, offset);
    });
    this._clock.on("stop", (time2) => {
      this.emit("stop", time2);
    });
    this._clock.on("pause", (time2) => {
      this.emit("pause", time2);
    });
  }
  /**
   * Returns the playback state of the source, either "started", "stopped", or "paused"
   */
  get state() {
    return this._clock.getStateAtTime(this.now());
  }
  /**
   * Start the transport and all sources synced to the transport.
   * @param  time The time when the transport should start.
   * @param  offset The timeline offset to start the transport.
   * @example
   * // start the transport in one second starting at beginning of the 5th measure.
   * Tone.getTransport().start("+1", "4:0:0");
   */
  start(time2, offset) {
    this.context.resume();
    let offsetTicks;
    if (isDefined(offset)) {
      offsetTicks = this.toTicks(offset);
    }
    this._clock.start(time2, offsetTicks);
    return this;
  }
  /**
   * Stop the transport and all sources synced to the transport.
   * @param time The time when the transport should stop.
   * @example
   * Tone.getTransport().stop();
   */
  stop(time2) {
    this._clock.stop(time2);
    return this;
  }
  /**
   * Pause the transport and all sources synced to the transport.
   */
  pause(time2) {
    this._clock.pause(time2);
    return this;
  }
  /**
   * Toggle the current state of the transport. If it is
   * started, it will stop it, otherwise it will start the Transport.
   * @param  time The time of the event
   */
  toggle(time2) {
    time2 = this.toSeconds(time2);
    if (this._clock.getStateAtTime(time2) !== "started") {
      this.start(time2);
    } else {
      this.stop(time2);
    }
    return this;
  }
  //-------------------------------------
  // 	SETTERS/GETTERS
  //-------------------------------------
  /**
   * The time signature as just the numerator over 4.
   * For example 4/4 would be just 4 and 6/8 would be 3.
   * @example
   * // common time
   * Tone.getTransport().timeSignature = 4;
   * // 7/8
   * Tone.getTransport().timeSignature = [7, 8];
   * // this will be reduced to a single number
   * Tone.getTransport().timeSignature; // returns 3.5
   */
  get timeSignature() {
    return this._timeSignature;
  }
  set timeSignature(timeSig) {
    if (isArray(timeSig)) {
      timeSig = timeSig[0] / timeSig[1] * 4;
    }
    this._timeSignature = timeSig;
  }
  /**
   * When the Transport.loop = true, this is the starting position of the loop.
   */
  get loopStart() {
    return new TimeClass(this.context, this._loopStart, "i").toSeconds();
  }
  set loopStart(startPosition) {
    this._loopStart = this.toTicks(startPosition);
  }
  /**
   * When the Transport.loop = true, this is the ending position of the loop.
   */
  get loopEnd() {
    return new TimeClass(this.context, this._loopEnd, "i").toSeconds();
  }
  set loopEnd(endPosition) {
    this._loopEnd = this.toTicks(endPosition);
  }
  /**
   * If the transport loops or not.
   */
  get loop() {
    return this._loop.get(this.now());
  }
  set loop(loop) {
    this._loop.set(loop, this.now());
  }
  /**
   * Set the loop start and stop at the same time.
   * @example
   * // loop over the first measure
   * Tone.getTransport().setLoopPoints(0, "1m");
   * Tone.getTransport().loop = true;
   */
  setLoopPoints(startPosition, endPosition) {
    this.loopStart = startPosition;
    this.loopEnd = endPosition;
    return this;
  }
  /**
   * The swing value. Between 0-1 where 1 equal to the note + half the subdivision.
   */
  get swing() {
    return this._swingAmount;
  }
  set swing(amount) {
    this._swingAmount = amount;
  }
  /**
   * Set the subdivision which the swing will be applied to.
   * The default value is an 8th note. Value must be less
   * than a quarter note.
   */
  get swingSubdivision() {
    return new TicksClass(this.context, this._swingTicks).toNotation();
  }
  set swingSubdivision(subdivision) {
    this._swingTicks = this.toTicks(subdivision);
  }
  /**
   * The Transport's position in Bars:Beats:Sixteenths.
   * Setting the value will jump to that position right away.
   */
  get position() {
    const now3 = this.now();
    const ticks = this._clock.getTicksAtTime(now3);
    return new TicksClass(this.context, ticks).toBarsBeatsSixteenths();
  }
  set position(progress) {
    const ticks = this.toTicks(progress);
    this.ticks = ticks;
  }
  /**
   * The Transport's position in seconds.
   * Setting the value will jump to that position right away.
   */
  get seconds() {
    return this._clock.seconds;
  }
  set seconds(s) {
    const now3 = this.now();
    const ticks = this._clock.frequency.timeToTicks(s, now3);
    this.ticks = ticks;
  }
  /**
   * The Transport's loop position as a normalized value. Always
   * returns 0 if the Transport.loop = false.
   */
  get progress() {
    if (this.loop) {
      const now3 = this.now();
      const ticks = this._clock.getTicksAtTime(now3);
      return (ticks - this._loopStart) / (this._loopEnd - this._loopStart);
    } else {
      return 0;
    }
  }
  /**
   * The Transport's current tick position.
   */
  get ticks() {
    return this._clock.ticks;
  }
  set ticks(t) {
    if (this._clock.ticks !== t) {
      const now3 = this.now();
      if (this.state === "started") {
        const ticks = this._clock.getTicksAtTime(now3);
        const remainingTick = this._clock.frequency.getDurationOfTicks(Math.ceil(ticks) - ticks, now3);
        const time2 = now3 + remainingTick;
        this.emit("stop", time2);
        this._clock.setTicksAtTime(t, time2);
        this.emit("start", time2, this._clock.getSecondsAtTime(time2));
      } else {
        this.emit("ticks", now3);
        this._clock.setTicksAtTime(t, now3);
      }
    }
  }
  /**
   * Get the clock's ticks at the given time.
   * @param  time  When to get the tick value
   * @return The tick value at the given time.
   */
  getTicksAtTime(time2) {
    return this._clock.getTicksAtTime(time2);
  }
  /**
   * Return the elapsed seconds at the given time.
   * @param  time  When to get the elapsed seconds
   * @return  The number of elapsed seconds
   */
  getSecondsAtTime(time2) {
    return this._clock.getSecondsAtTime(time2);
  }
  /**
   * Pulses Per Quarter note. This is the smallest resolution
   * the Transport timing supports. This should be set once
   * on initialization and not set again. Changing this value
   * after other objects have been created can cause problems.
   */
  get PPQ() {
    return this._clock.frequency.multiplier;
  }
  set PPQ(ppq) {
    this._clock.frequency.multiplier = ppq;
  }
  //-------------------------------------
  // 	SYNCING
  //-------------------------------------
  /**
   * Returns the time aligned to the next subdivision
   * of the Transport. If the Transport is not started,
   * it will return 0.
   * Note: this will not work precisely during tempo ramps.
   * @param  subdivision  The subdivision to quantize to
   * @return  The context time of the next subdivision.
   * @example
   * // the transport must be started, otherwise returns 0
   * Tone.getTransport().start();
   * Tone.getTransport().nextSubdivision("4n");
   */
  nextSubdivision(subdivision) {
    subdivision = this.toTicks(subdivision);
    if (this.state !== "started") {
      return 0;
    } else {
      const now3 = this.now();
      const transportPos = this.getTicksAtTime(now3);
      const remainingTicks = subdivision - transportPos % subdivision;
      return this._clock.nextTickTime(remainingTicks, now3);
    }
  }
  /**
   * Attaches the signal to the tempo control signal so that
   * any changes in the tempo will change the signal in the same
   * ratio.
   *
   * @param signal
   * @param ratio Optionally pass in the ratio between the two signals.
   * 			Otherwise it will be computed based on their current values.
   */
  syncSignal(signal, ratio) {
    const now3 = this.now();
    let source = this.bpm;
    let sourceValue = 1 / (60 / source.getValueAtTime(now3) / this.PPQ);
    let nodes = [];
    if (signal.units === "time") {
      const scaleFactor = 1 / 64 / sourceValue;
      const scaleBefore = new Gain(scaleFactor);
      const reciprocal = new Pow(-1);
      const scaleAfter = new Gain(scaleFactor);
      source.chain(scaleBefore, reciprocal, scaleAfter);
      source = scaleAfter;
      sourceValue = 1 / sourceValue;
      nodes = [scaleBefore, reciprocal, scaleAfter];
    }
    if (!ratio) {
      if (signal.getValueAtTime(now3) !== 0) {
        ratio = signal.getValueAtTime(now3) / sourceValue;
      } else {
        ratio = 0;
      }
    }
    const ratioSignal = new Gain(ratio);
    source.connect(ratioSignal);
    ratioSignal.connect(signal._param);
    nodes.push(ratioSignal);
    this._syncedSignals.push({
      initial: signal.value,
      nodes,
      signal
    });
    signal.value = 0;
    return this;
  }
  /**
   * Unsyncs a previously synced signal from the transport's control.
   * @see {@link syncSignal}.
   */
  unsyncSignal(signal) {
    for (let i = this._syncedSignals.length - 1; i >= 0; i--) {
      const syncedSignal = this._syncedSignals[i];
      if (syncedSignal.signal === signal) {
        syncedSignal.nodes.forEach((node) => node.dispose());
        syncedSignal.signal.value = syncedSignal.initial;
        this._syncedSignals.splice(i, 1);
      }
    }
    return this;
  }
  /**
   * Clean up.
   */
  dispose() {
    super.dispose();
    this._clock.dispose();
    writable(this, "bpm");
    this._timeline.dispose();
    this._repeatedEvents.dispose();
    return this;
  }
};
Emitter.mixin(TransportClass);
onContextInit((context2) => {
  context2.transport = new TransportClass({ context: context2 });
});
onContextClose((context2) => {
  context2.transport.dispose();
});

// node_modules/@magenta/music/node_modules/tone/build/esm/source/Source.js
var Source = class extends ToneAudioNode {
  constructor(options) {
    super(options);
    this.input = void 0;
    this._state = new StateTimeline("stopped");
    this._synced = false;
    this._scheduled = [];
    this._syncedStart = noOp;
    this._syncedStop = noOp;
    this._state.memory = 100;
    this._state.increasing = true;
    this._volume = this.output = new Volume({
      context: this.context,
      mute: options.mute,
      volume: options.volume
    });
    this.volume = this._volume.volume;
    readOnly(this, "volume");
    this.onstop = options.onstop;
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      mute: false,
      onstop: noOp,
      volume: 0
    });
  }
  /**
   * Returns the playback state of the source, either "started" or "stopped".
   * @example
   * const player = new Tone.Player("https://tonejs.github.io/audio/berklee/ahntone_c3.mp3", () => {
   * 	player.start();
   * 	console.log(player.state);
   * }).toDestination();
   */
  get state() {
    if (this._synced) {
      if (this.context.transport.state === "started") {
        return this._state.getValueAtTime(this.context.transport.seconds);
      } else {
        return "stopped";
      }
    } else {
      return this._state.getValueAtTime(this.now());
    }
  }
  /**
   * Mute the output.
   * @example
   * const osc = new Tone.Oscillator().toDestination().start();
   * // mute the output
   * osc.mute = true;
   */
  get mute() {
    return this._volume.mute;
  }
  set mute(mute) {
    this._volume.mute = mute;
  }
  /**
   * Ensure that the scheduled time is not before the current time.
   * Should only be used when scheduled unsynced.
   */
  _clampToCurrentTime(time2) {
    if (this._synced) {
      return time2;
    } else {
      return Math.max(time2, this.context.currentTime);
    }
  }
  /**
   * Start the source at the specified time. If no time is given,
   * start the source now.
   * @param  time When the source should be started.
   * @example
   * const source = new Tone.Oscillator().toDestination();
   * source.start("+0.5"); // starts the source 0.5 seconds from now
   */
  start(time2, offset, duration) {
    let computedTime = isUndef(time2) && this._synced ? this.context.transport.seconds : this.toSeconds(time2);
    computedTime = this._clampToCurrentTime(computedTime);
    if (!this._synced && this._state.getValueAtTime(computedTime) === "started") {
      assert(GT(computedTime, this._state.get(computedTime).time), "Start time must be strictly greater than previous start time");
      this._state.cancel(computedTime);
      this._state.setStateAtTime("started", computedTime);
      this.log("restart", computedTime);
      this.restart(computedTime, offset, duration);
    } else {
      this.log("start", computedTime);
      this._state.setStateAtTime("started", computedTime);
      if (this._synced) {
        const event = this._state.get(computedTime);
        if (event) {
          event.offset = this.toSeconds(defaultArg(offset, 0));
          event.duration = duration ? this.toSeconds(duration) : void 0;
        }
        const sched = this.context.transport.schedule((t) => {
          this._start(t, offset, duration);
        }, computedTime);
        this._scheduled.push(sched);
        if (this.context.transport.state === "started" && this.context.transport.getSecondsAtTime(this.immediate()) > computedTime) {
          this._syncedStart(this.now(), this.context.transport.seconds);
        }
      } else {
        assertContextRunning(this.context);
        this._start(computedTime, offset, duration);
      }
    }
    return this;
  }
  /**
   * Stop the source at the specified time. If no time is given,
   * stop the source now.
   * @param  time When the source should be stopped.
   * @example
   * const source = new Tone.Oscillator().toDestination();
   * source.start();
   * source.stop("+0.5"); // stops the source 0.5 seconds from now
   */
  stop(time2) {
    let computedTime = isUndef(time2) && this._synced ? this.context.transport.seconds : this.toSeconds(time2);
    computedTime = this._clampToCurrentTime(computedTime);
    if (this._state.getValueAtTime(computedTime) === "started" || isDefined(this._state.getNextState("started", computedTime))) {
      this.log("stop", computedTime);
      if (!this._synced) {
        this._stop(computedTime);
      } else {
        const sched = this.context.transport.schedule(this._stop.bind(this), computedTime);
        this._scheduled.push(sched);
      }
      this._state.cancel(computedTime);
      this._state.setStateAtTime("stopped", computedTime);
    }
    return this;
  }
  /**
   * Restart the source.
   */
  restart(time2, offset, duration) {
    time2 = this.toSeconds(time2);
    if (this._state.getValueAtTime(time2) === "started") {
      this._state.cancel(time2);
      this._restart(time2, offset, duration);
    }
    return this;
  }
  /**
   * Sync the source to the Transport so that all subsequent
   * calls to `start` and `stop` are synced to the TransportTime
   * instead of the AudioContext time.
   *
   * @example
   * const osc = new Tone.Oscillator().toDestination();
   * // sync the source so that it plays between 0 and 0.3 on the Transport's timeline
   * osc.sync().start(0).stop(0.3);
   * // start the transport.
   * Tone.Transport.start();
   * // set it to loop once a second
   * Tone.Transport.loop = true;
   * Tone.Transport.loopEnd = 1;
   */
  sync() {
    if (!this._synced) {
      this._synced = true;
      this._syncedStart = (time2, offset) => {
        if (GT(offset, 0)) {
          const stateEvent = this._state.get(offset);
          if (stateEvent && stateEvent.state === "started" && stateEvent.time !== offset) {
            const startOffset = offset - this.toSeconds(stateEvent.time);
            let duration;
            if (stateEvent.duration) {
              duration = this.toSeconds(stateEvent.duration) - startOffset;
            }
            this._start(time2, this.toSeconds(stateEvent.offset) + startOffset, duration);
          }
        }
      };
      this._syncedStop = (time2) => {
        const seconds = this.context.transport.getSecondsAtTime(Math.max(time2 - this.sampleTime, 0));
        if (this._state.getValueAtTime(seconds) === "started") {
          this._stop(time2);
        }
      };
      this.context.transport.on("start", this._syncedStart);
      this.context.transport.on("loopStart", this._syncedStart);
      this.context.transport.on("stop", this._syncedStop);
      this.context.transport.on("pause", this._syncedStop);
      this.context.transport.on("loopEnd", this._syncedStop);
    }
    return this;
  }
  /**
   * Unsync the source to the Transport.
   * @see {@link sync}
   */
  unsync() {
    if (this._synced) {
      this.context.transport.off("stop", this._syncedStop);
      this.context.transport.off("pause", this._syncedStop);
      this.context.transport.off("loopEnd", this._syncedStop);
      this.context.transport.off("start", this._syncedStart);
      this.context.transport.off("loopStart", this._syncedStart);
    }
    this._synced = false;
    this._scheduled.forEach((id) => this.context.transport.clear(id));
    this._scheduled = [];
    this._state.cancel(0);
    this._stop(0);
    return this;
  }
  /**
   * Clean up.
   */
  dispose() {
    super.dispose();
    this.onstop = noOp;
    this.unsync();
    this._volume.dispose();
    this._state.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/source/buffer/ToneBufferSource.js
var ToneBufferSource = class _ToneBufferSource extends OneShotSource {
  constructor() {
    super(optionsFromArguments(_ToneBufferSource.getDefaults(), arguments, ["url", "onload"]));
    this.name = "ToneBufferSource";
    this._source = this.context.createBufferSource();
    this._internalChannels = [this._source];
    this._sourceStarted = false;
    this._sourceStopped = false;
    const options = optionsFromArguments(_ToneBufferSource.getDefaults(), arguments, ["url", "onload"]);
    connect(this._source, this._gainNode);
    this._source.onended = () => this._stopSource();
    this.playbackRate = new Param({
      context: this.context,
      param: this._source.playbackRate,
      units: "positive",
      value: options.playbackRate
    });
    this.loop = options.loop;
    this.loopStart = options.loopStart;
    this.loopEnd = options.loopEnd;
    this._buffer = new ToneAudioBuffer(options.url, options.onload, options.onerror);
    this._internalChannels.push(this._source);
  }
  static getDefaults() {
    return Object.assign(OneShotSource.getDefaults(), {
      url: new ToneAudioBuffer(),
      loop: false,
      loopEnd: 0,
      loopStart: 0,
      onload: noOp,
      onerror: noOp,
      playbackRate: 1
    });
  }
  /**
   * The fadeIn time of the amplitude envelope.
   */
  get fadeIn() {
    return this._fadeIn;
  }
  set fadeIn(t) {
    this._fadeIn = t;
  }
  /**
   * The fadeOut time of the amplitude envelope.
   */
  get fadeOut() {
    return this._fadeOut;
  }
  set fadeOut(t) {
    this._fadeOut = t;
  }
  /**
   * The curve applied to the fades, either "linear" or "exponential"
   */
  get curve() {
    return this._curve;
  }
  set curve(t) {
    this._curve = t;
  }
  /**
   * Start the buffer
   * @param  time When the player should start.
   * @param  offset The offset from the beginning of the sample to start at.
   * @param  duration How long the sample should play. If no duration is given, it will default to the full length of the sample (minus any offset)
   * @param  gain  The gain to play the buffer back at.
   */
  start(time2, offset, duration, gain = 1) {
    assert(this.buffer.loaded, "buffer is either not set or not loaded");
    const computedTime = this.toSeconds(time2);
    this._startGain(computedTime, gain);
    if (this.loop) {
      offset = defaultArg(offset, this.loopStart);
    } else {
      offset = defaultArg(offset, 0);
    }
    let computedOffset = Math.max(this.toSeconds(offset), 0);
    if (this.loop) {
      const loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration;
      const loopStart = this.toSeconds(this.loopStart);
      const loopDuration = loopEnd - loopStart;
      if (GTE(computedOffset, loopEnd)) {
        computedOffset = (computedOffset - loopStart) % loopDuration + loopStart;
      }
      if (EQ(computedOffset, this.buffer.duration)) {
        computedOffset = 0;
      }
    }
    this._source.buffer = this.buffer.get();
    this._source.loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration;
    if (LT(computedOffset, this.buffer.duration)) {
      this._sourceStarted = true;
      this._source.start(computedTime, computedOffset);
    }
    if (isDefined(duration)) {
      let computedDur = this.toSeconds(duration);
      computedDur = Math.max(computedDur, 0);
      this.stop(computedTime + computedDur);
    }
    return this;
  }
  _stopSource(time2) {
    if (!this._sourceStopped && this._sourceStarted) {
      this._sourceStopped = true;
      this._source.stop(this.toSeconds(time2));
      this._onended();
    }
  }
  /**
   * If loop is true, the loop will start at this position.
   */
  get loopStart() {
    return this._source.loopStart;
  }
  set loopStart(loopStart) {
    this._source.loopStart = this.toSeconds(loopStart);
  }
  /**
   * If loop is true, the loop will end at this position.
   */
  get loopEnd() {
    return this._source.loopEnd;
  }
  set loopEnd(loopEnd) {
    this._source.loopEnd = this.toSeconds(loopEnd);
  }
  /**
   * The audio buffer belonging to the player.
   */
  get buffer() {
    return this._buffer;
  }
  set buffer(buffer2) {
    this._buffer.set(buffer2);
  }
  /**
   * If the buffer should loop once it's over.
   */
  get loop() {
    return this._source.loop;
  }
  set loop(loop) {
    this._source.loop = loop;
    if (this._sourceStarted) {
      this.cancelStop();
    }
  }
  /**
   * Clean up.
   */
  dispose() {
    super.dispose();
    this._source.onended = null;
    this._source.disconnect();
    this._buffer.dispose();
    this.playbackRate.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/source/Noise.js
var Noise = class _Noise extends Source {
  constructor() {
    super(optionsFromArguments(_Noise.getDefaults(), arguments, ["type"]));
    this.name = "Noise";
    this._source = null;
    const options = optionsFromArguments(_Noise.getDefaults(), arguments, ["type"]);
    this._playbackRate = options.playbackRate;
    this.type = options.type;
    this._fadeIn = options.fadeIn;
    this._fadeOut = options.fadeOut;
  }
  static getDefaults() {
    return Object.assign(Source.getDefaults(), {
      fadeIn: 0,
      fadeOut: 0,
      playbackRate: 1,
      type: "white"
    });
  }
  /**
   * The type of the noise. Can be "white", "brown", or "pink".
   * @example
   * const noise = new Tone.Noise().toDestination().start();
   * noise.type = "brown";
   */
  get type() {
    return this._type;
  }
  set type(type) {
    assert(type in _noiseBuffers, "Noise: invalid type: " + type);
    if (this._type !== type) {
      this._type = type;
      if (this.state === "started") {
        const now3 = this.now();
        this._stop(now3);
        this._start(now3);
      }
    }
  }
  /**
   * The playback rate of the noise. Affects
   * the "frequency" of the noise.
   */
  get playbackRate() {
    return this._playbackRate;
  }
  set playbackRate(rate) {
    this._playbackRate = rate;
    if (this._source) {
      this._source.playbackRate.value = rate;
    }
  }
  /**
   * internal start method
   */
  _start(time2) {
    const buffer2 = _noiseBuffers[this._type];
    this._source = new ToneBufferSource({
      url: buffer2,
      context: this.context,
      fadeIn: this._fadeIn,
      fadeOut: this._fadeOut,
      loop: true,
      onended: () => this.onstop(this),
      playbackRate: this._playbackRate
    }).connect(this.output);
    this._source.start(this.toSeconds(time2), Math.random() * (buffer2.duration - 1e-3));
  }
  /**
   * internal stop method
   */
  _stop(time2) {
    if (this._source) {
      this._source.stop(this.toSeconds(time2));
      this._source = null;
    }
  }
  /**
   * The fadeIn time of the amplitude envelope.
   */
  get fadeIn() {
    return this._fadeIn;
  }
  set fadeIn(time2) {
    this._fadeIn = time2;
    if (this._source) {
      this._source.fadeIn = this._fadeIn;
    }
  }
  /**
   * The fadeOut time of the amplitude envelope.
   */
  get fadeOut() {
    return this._fadeOut;
  }
  set fadeOut(time2) {
    this._fadeOut = time2;
    if (this._source) {
      this._source.fadeOut = this._fadeOut;
    }
  }
  _restart(time2) {
    this._stop(time2);
    this._start(time2);
  }
  /**
   * Clean up.
   */
  dispose() {
    super.dispose();
    if (this._source) {
      this._source.disconnect();
    }
    return this;
  }
};
var BUFFER_LENGTH = 44100 * 5;
var NUM_CHANNELS = 2;
var _noiseCache = {
  brown: null,
  pink: null,
  white: null
};
var _noiseBuffers = {
  get brown() {
    if (!_noiseCache.brown) {
      const buffer2 = [];
      for (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {
        const channel = new Float32Array(BUFFER_LENGTH);
        buffer2[channelNum] = channel;
        let lastOut = 0;
        for (let i = 0; i < BUFFER_LENGTH; i++) {
          const white = Math.random() * 2 - 1;
          channel[i] = (lastOut + 0.02 * white) / 1.02;
          lastOut = channel[i];
          channel[i] *= 3.5;
        }
      }
      _noiseCache.brown = new ToneAudioBuffer().fromArray(buffer2);
    }
    return _noiseCache.brown;
  },
  get pink() {
    if (!_noiseCache.pink) {
      const buffer2 = [];
      for (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {
        const channel = new Float32Array(BUFFER_LENGTH);
        buffer2[channelNum] = channel;
        let b0, b1, b2, b3, b4, b5, b6;
        b0 = b1 = b2 = b3 = b4 = b5 = b6 = 0;
        for (let i = 0; i < BUFFER_LENGTH; i++) {
          const white = Math.random() * 2 - 1;
          b0 = 0.99886 * b0 + white * 0.0555179;
          b1 = 0.99332 * b1 + white * 0.0750759;
          b2 = 0.969 * b2 + white * 0.153852;
          b3 = 0.8665 * b3 + white * 0.3104856;
          b4 = 0.55 * b4 + white * 0.5329522;
          b5 = -0.7616 * b5 - white * 0.016898;
          channel[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;
          channel[i] *= 0.11;
          b6 = white * 0.115926;
        }
      }
      _noiseCache.pink = new ToneAudioBuffer().fromArray(buffer2);
    }
    return _noiseCache.pink;
  },
  get white() {
    if (!_noiseCache.white) {
      const buffer2 = [];
      for (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {
        const channel = new Float32Array(BUFFER_LENGTH);
        buffer2[channelNum] = channel;
        for (let i = 0; i < BUFFER_LENGTH; i++) {
          channel[i] = Math.random() * 2 - 1;
        }
      }
      _noiseCache.white = new ToneAudioBuffer().fromArray(buffer2);
    }
    return _noiseCache.white;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/source/UserMedia.js
var UserMedia = class _UserMedia extends ToneAudioNode {
  constructor() {
    super(optionsFromArguments(_UserMedia.getDefaults(), arguments, ["volume"]));
    this.name = "UserMedia";
    const options = optionsFromArguments(_UserMedia.getDefaults(), arguments, ["volume"]);
    this._volume = this.output = new Volume({
      context: this.context,
      volume: options.volume
    });
    this.volume = this._volume.volume;
    readOnly(this, "volume");
    this.mute = options.mute;
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      mute: false,
      volume: 0
    });
  }
  /**
   * Open the media stream. If a string is passed in, it is assumed
   * to be the label or id of the stream, if a number is passed in,
   * it is the input number of the stream.
   * @param  labelOrId The label or id of the audio input media device.
   *                   With no argument, the default stream is opened.
   * @return The promise is resolved when the stream is open.
   */
  open(labelOrId) {
    return __awaiter(this, void 0, void 0, function* () {
      assert(_UserMedia.supported, "UserMedia is not supported");
      if (this.state === "started") {
        this.close();
      }
      const devices = yield _UserMedia.enumerateDevices();
      if (isNumber(labelOrId)) {
        this._device = devices[labelOrId];
      } else {
        this._device = devices.find((device) => {
          return device.label === labelOrId || device.deviceId === labelOrId;
        });
        if (!this._device && devices.length > 0) {
          this._device = devices[0];
        }
        assert(isDefined(this._device), `No matching device ${labelOrId}`);
      }
      const constraints = {
        audio: {
          echoCancellation: false,
          sampleRate: this.context.sampleRate,
          noiseSuppression: false,
          mozNoiseSuppression: false
        }
      };
      if (this._device) {
        constraints.audio.deviceId = this._device.deviceId;
      }
      const stream = yield navigator.mediaDevices.getUserMedia(constraints);
      if (!this._stream) {
        this._stream = stream;
        const mediaStreamNode = this.context.createMediaStreamSource(stream);
        connect(mediaStreamNode, this.output);
        this._mediaStream = mediaStreamNode;
      }
      return this;
    });
  }
  /**
   * Close the media stream
   */
  close() {
    if (this._stream && this._mediaStream) {
      this._stream.getAudioTracks().forEach((track) => {
        track.stop();
      });
      this._stream = void 0;
      this._mediaStream.disconnect();
      this._mediaStream = void 0;
    }
    this._device = void 0;
    return this;
  }
  /**
   * Returns a promise which resolves with the list of audio input devices available.
   * @return The promise that is resolved with the devices
   * @example
   * Tone.UserMedia.enumerateDevices().then((devices) => {
   * 	// print the device labels
   * 	console.log(devices.map(device => device.label));
   * });
   */
  static enumerateDevices() {
    return __awaiter(this, void 0, void 0, function* () {
      const allDevices = yield navigator.mediaDevices.enumerateDevices();
      return allDevices.filter((device) => {
        return device.kind === "audioinput";
      });
    });
  }
  /**
   * Returns the playback state of the source, "started" when the microphone is open
   * and "stopped" when the mic is closed.
   */
  get state() {
    return this._stream && this._stream.active ? "started" : "stopped";
  }
  /**
   * Returns an identifier for the represented device that is
   * persisted across sessions. It is un-guessable by other applications and
   * unique to the origin of the calling application. It is reset when the
   * user clears cookies (for Private Browsing, a different identifier is
   * used that is not persisted across sessions). Returns undefined when the
   * device is not open.
   */
  get deviceId() {
    if (this._device) {
      return this._device.deviceId;
    } else {
      return void 0;
    }
  }
  /**
   * Returns a group identifier. Two devices have the
   * same group identifier if they belong to the same physical device.
   * Returns null  when the device is not open.
   */
  get groupId() {
    if (this._device) {
      return this._device.groupId;
    } else {
      return void 0;
    }
  }
  /**
   * Returns a label describing this device (for example "Built-in Microphone").
   * Returns undefined when the device is not open or label is not available
   * because of permissions.
   */
  get label() {
    if (this._device) {
      return this._device.label;
    } else {
      return void 0;
    }
  }
  /**
   * Mute the output.
   * @example
   * const mic = new Tone.UserMedia();
   * mic.open().then(() => {
   * 	// promise resolves when input is available
   * });
   * // mute the output
   * mic.mute = true;
   */
  get mute() {
    return this._volume.mute;
  }
  set mute(mute) {
    this._volume.mute = mute;
  }
  dispose() {
    super.dispose();
    this.close();
    this._volume.dispose();
    this.volume.dispose();
    return this;
  }
  /**
   * If getUserMedia is supported by the browser.
   */
  static get supported() {
    return isDefined(navigator.mediaDevices) && isDefined(navigator.mediaDevices.getUserMedia);
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/source/oscillator/OscillatorInterface.js
function generateWaveform(instance, length) {
  return __awaiter(this, void 0, void 0, function* () {
    const duration = length / instance.context.sampleRate;
    const context2 = new OfflineContext(1, duration, instance.context.sampleRate);
    const clone2 = new instance.constructor(Object.assign(instance.get(), {
      // should do 2 iterations
      frequency: 2 / duration,
      // zero out the detune
      detune: 0,
      context: context2
    })).toDestination();
    clone2.start(0);
    const buffer2 = yield context2.render();
    return buffer2.getChannelData(0);
  });
}

// node_modules/@magenta/music/node_modules/tone/build/esm/source/oscillator/ToneOscillatorNode.js
var ToneOscillatorNode = class _ToneOscillatorNode extends OneShotSource {
  constructor() {
    super(optionsFromArguments(_ToneOscillatorNode.getDefaults(), arguments, ["frequency", "type"]));
    this.name = "ToneOscillatorNode";
    this._oscillator = this.context.createOscillator();
    this._internalChannels = [this._oscillator];
    const options = optionsFromArguments(_ToneOscillatorNode.getDefaults(), arguments, ["frequency", "type"]);
    connect(this._oscillator, this._gainNode);
    this.type = options.type;
    this.frequency = new Param({
      context: this.context,
      param: this._oscillator.frequency,
      units: "frequency",
      value: options.frequency
    });
    this.detune = new Param({
      context: this.context,
      param: this._oscillator.detune,
      units: "cents",
      value: options.detune
    });
    readOnly(this, ["frequency", "detune"]);
  }
  static getDefaults() {
    return Object.assign(OneShotSource.getDefaults(), {
      detune: 0,
      frequency: 440,
      type: "sine"
    });
  }
  /**
   * Start the oscillator node at the given time
   * @param  time When to start the oscillator
   */
  start(time2) {
    const computedTime = this.toSeconds(time2);
    this.log("start", computedTime);
    this._startGain(computedTime);
    this._oscillator.start(computedTime);
    return this;
  }
  _stopSource(time2) {
    this._oscillator.stop(time2);
  }
  /**
   * Sets an arbitrary custom periodic waveform given a PeriodicWave.
   * @param  periodicWave PeriodicWave should be created with context.createPeriodicWave
   */
  setPeriodicWave(periodicWave) {
    this._oscillator.setPeriodicWave(periodicWave);
    return this;
  }
  /**
   * The oscillator type. Either 'sine', 'sawtooth', 'square', or 'triangle'
   */
  get type() {
    return this._oscillator.type;
  }
  set type(type) {
    this._oscillator.type = type;
  }
  /**
   * Clean up.
   */
  dispose() {
    super.dispose();
    if (this.state === "started") {
      this.stop();
    }
    this._oscillator.disconnect();
    this.frequency.dispose();
    this.detune.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/source/oscillator/Oscillator.js
var Oscillator = class _Oscillator extends Source {
  constructor() {
    super(optionsFromArguments(_Oscillator.getDefaults(), arguments, ["frequency", "type"]));
    this.name = "Oscillator";
    this._oscillator = null;
    const options = optionsFromArguments(_Oscillator.getDefaults(), arguments, ["frequency", "type"]);
    this.frequency = new Signal({
      context: this.context,
      units: "frequency",
      value: options.frequency
    });
    readOnly(this, "frequency");
    this.detune = new Signal({
      context: this.context,
      units: "cents",
      value: options.detune
    });
    readOnly(this, "detune");
    this._partials = options.partials;
    this._partialCount = options.partialCount;
    this._type = options.type;
    if (options.partialCount && options.type !== "custom") {
      this._type = this.baseType + options.partialCount.toString();
    }
    this.phase = options.phase;
  }
  static getDefaults() {
    return Object.assign(Source.getDefaults(), {
      detune: 0,
      frequency: 440,
      partialCount: 0,
      partials: [],
      phase: 0,
      type: "sine"
    });
  }
  /**
   * start the oscillator
   */
  _start(time2) {
    const computedTime = this.toSeconds(time2);
    const oscillator = new ToneOscillatorNode({
      context: this.context,
      onended: () => this.onstop(this)
    });
    this._oscillator = oscillator;
    if (this._wave) {
      this._oscillator.setPeriodicWave(this._wave);
    } else {
      this._oscillator.type = this._type;
    }
    this._oscillator.connect(this.output);
    this.frequency.connect(this._oscillator.frequency);
    this.detune.connect(this._oscillator.detune);
    this._oscillator.start(computedTime);
  }
  /**
   * stop the oscillator
   */
  _stop(time2) {
    const computedTime = this.toSeconds(time2);
    if (this._oscillator) {
      this._oscillator.stop(computedTime);
    }
  }
  /**
   * Restart the oscillator. Does not stop the oscillator, but instead
   * just cancels any scheduled 'stop' from being invoked.
   */
  _restart(time2) {
    const computedTime = this.toSeconds(time2);
    this.log("restart", computedTime);
    if (this._oscillator) {
      this._oscillator.cancelStop();
    }
    this._state.cancel(computedTime);
    return this;
  }
  /**
   * Sync the signal to the Transport's bpm. Any changes to the transports bpm,
   * will also affect the oscillators frequency.
   * @example
   * const osc = new Tone.Oscillator().toDestination().start();
   * osc.frequency.value = 440;
   * // the ratio between the bpm and the frequency will be maintained
   * osc.syncFrequency();
   * // double the tempo
   * Tone.Transport.bpm.value *= 2;
   * // the frequency of the oscillator is doubled to 880
   */
  syncFrequency() {
    this.context.transport.syncSignal(this.frequency);
    return this;
  }
  /**
   * Unsync the oscillator's frequency from the Transport.
   * @see {@link syncFrequency}
   */
  unsyncFrequency() {
    this.context.transport.unsyncSignal(this.frequency);
    return this;
  }
  /**
   * Get a cached periodic wave. Avoids having to recompute
   * the oscillator values when they have already been computed
   * with the same values.
   */
  _getCachedPeriodicWave() {
    if (this._type === "custom") {
      const oscProps = _Oscillator._periodicWaveCache.find((description) => {
        return description.phase === this._phase && deepEquals(description.partials, this._partials);
      });
      return oscProps;
    } else {
      const oscProps = _Oscillator._periodicWaveCache.find((description) => {
        return description.type === this._type && description.phase === this._phase;
      });
      this._partialCount = oscProps ? oscProps.partialCount : this._partialCount;
      return oscProps;
    }
  }
  get type() {
    return this._type;
  }
  set type(type) {
    this._type = type;
    const isBasicType = ["sine", "square", "sawtooth", "triangle"].indexOf(type) !== -1;
    if (this._phase === 0 && isBasicType) {
      this._wave = void 0;
      this._partialCount = 0;
      if (this._oscillator !== null) {
        this._oscillator.type = type;
      }
    } else {
      const cache = this._getCachedPeriodicWave();
      if (isDefined(cache)) {
        const { partials, wave } = cache;
        this._wave = wave;
        this._partials = partials;
        if (this._oscillator !== null) {
          this._oscillator.setPeriodicWave(this._wave);
        }
      } else {
        const [real, imag] = this._getRealImaginary(type, this._phase);
        const periodicWave = this.context.createPeriodicWave(real, imag);
        this._wave = periodicWave;
        if (this._oscillator !== null) {
          this._oscillator.setPeriodicWave(this._wave);
        }
        _Oscillator._periodicWaveCache.push({
          imag,
          partialCount: this._partialCount,
          partials: this._partials,
          phase: this._phase,
          real,
          type: this._type,
          wave: this._wave
        });
        if (_Oscillator._periodicWaveCache.length > 100) {
          _Oscillator._periodicWaveCache.shift();
        }
      }
    }
  }
  get baseType() {
    return this._type.replace(this.partialCount.toString(), "");
  }
  set baseType(baseType) {
    if (this.partialCount && this._type !== "custom" && baseType !== "custom") {
      this.type = baseType + this.partialCount;
    } else {
      this.type = baseType;
    }
  }
  get partialCount() {
    return this._partialCount;
  }
  set partialCount(p) {
    assertRange(p, 0);
    let type = this._type;
    const partial = /^(sine|triangle|square|sawtooth)(\d+)$/.exec(this._type);
    if (partial) {
      type = partial[1];
    }
    if (this._type !== "custom") {
      if (p === 0) {
        this.type = type;
      } else {
        this.type = type + p.toString();
      }
    } else {
      const fullPartials = new Float32Array(p);
      this._partials.forEach((v, i) => fullPartials[i] = v);
      this._partials = Array.from(fullPartials);
      this.type = this._type;
    }
  }
  /**
   * Returns the real and imaginary components based
   * on the oscillator type.
   * @returns [real: Float32Array, imaginary: Float32Array]
   */
  _getRealImaginary(type, phase) {
    const fftSize = 4096;
    let periodicWaveSize = fftSize / 2;
    const real = new Float32Array(periodicWaveSize);
    const imag = new Float32Array(periodicWaveSize);
    let partialCount = 1;
    if (type === "custom") {
      partialCount = this._partials.length + 1;
      this._partialCount = this._partials.length;
      periodicWaveSize = partialCount;
      if (this._partials.length === 0) {
        return [real, imag];
      }
    } else {
      const partial = /^(sine|triangle|square|sawtooth)(\d+)$/.exec(type);
      if (partial) {
        partialCount = parseInt(partial[2], 10) + 1;
        this._partialCount = parseInt(partial[2], 10);
        type = partial[1];
        partialCount = Math.max(partialCount, 2);
        periodicWaveSize = partialCount;
      } else {
        this._partialCount = 0;
      }
      this._partials = [];
    }
    for (let n = 1; n < periodicWaveSize; ++n) {
      const piFactor = 2 / (n * Math.PI);
      let b;
      switch (type) {
        case "sine":
          b = n <= partialCount ? 1 : 0;
          this._partials[n - 1] = b;
          break;
        case "square":
          b = n & 1 ? 2 * piFactor : 0;
          this._partials[n - 1] = b;
          break;
        case "sawtooth":
          b = piFactor * (n & 1 ? 1 : -1);
          this._partials[n - 1] = b;
          break;
        case "triangle":
          if (n & 1) {
            b = 2 * (piFactor * piFactor) * (n - 1 >> 1 & 1 ? -1 : 1);
          } else {
            b = 0;
          }
          this._partials[n - 1] = b;
          break;
        case "custom":
          b = this._partials[n - 1];
          break;
        default:
          throw new TypeError("Oscillator: invalid type: " + type);
      }
      if (b !== 0) {
        real[n] = -b * Math.sin(phase * n);
        imag[n] = b * Math.cos(phase * n);
      } else {
        real[n] = 0;
        imag[n] = 0;
      }
    }
    return [real, imag];
  }
  /**
   * Compute the inverse FFT for a given phase.
   */
  _inverseFFT(real, imag, phase) {
    let sum2 = 0;
    const len = real.length;
    for (let i = 0; i < len; i++) {
      sum2 += real[i] * Math.cos(i * phase) + imag[i] * Math.sin(i * phase);
    }
    return sum2;
  }
  /**
   * Returns the initial value of the oscillator when stopped.
   * E.g. a "sine" oscillator with phase = 90 would return an initial value of -1.
   */
  getInitialValue() {
    const [real, imag] = this._getRealImaginary(this._type, 0);
    let maxValue = 0;
    const twoPi = Math.PI * 2;
    const testPositions = 32;
    for (let i = 0; i < testPositions; i++) {
      maxValue = Math.max(this._inverseFFT(real, imag, i / testPositions * twoPi), maxValue);
    }
    return clamp(-this._inverseFFT(real, imag, this._phase) / maxValue, -1, 1);
  }
  get partials() {
    return this._partials.slice(0, this.partialCount);
  }
  set partials(partials) {
    this._partials = partials;
    this._partialCount = this._partials.length;
    if (partials.length) {
      this.type = "custom";
    }
  }
  get phase() {
    return this._phase * (180 / Math.PI);
  }
  set phase(phase) {
    this._phase = phase * Math.PI / 180;
    this.type = this._type;
  }
  asArray(length = 1024) {
    return __awaiter(this, void 0, void 0, function* () {
      return generateWaveform(this, length);
    });
  }
  dispose() {
    super.dispose();
    if (this._oscillator !== null) {
      this._oscillator.dispose();
    }
    this._wave = void 0;
    this.frequency.dispose();
    this.detune.dispose();
    return this;
  }
};
Oscillator._periodicWaveCache = [];

// node_modules/@magenta/music/node_modules/tone/build/esm/signal/AudioToGain.js
var AudioToGain = class extends SignalOperator {
  constructor() {
    super(...arguments);
    this.name = "AudioToGain";
    this._norm = new WaveShaper({
      context: this.context,
      mapping: (x) => (x + 1) / 2
    });
    this.input = this._norm;
    this.output = this._norm;
  }
  /**
   * clean up
   */
  dispose() {
    super.dispose();
    this._norm.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/signal/Multiply.js
var Multiply = class _Multiply extends Signal {
  constructor() {
    super(Object.assign(optionsFromArguments(_Multiply.getDefaults(), arguments, ["value"])));
    this.name = "Multiply";
    this.override = false;
    const options = optionsFromArguments(_Multiply.getDefaults(), arguments, ["value"]);
    this._mult = this.input = this.output = new Gain({
      context: this.context,
      minValue: options.minValue,
      maxValue: options.maxValue
    });
    this.factor = this._param = this._mult.gain;
    this.factor.setValueAtTime(options.value, 0);
  }
  static getDefaults() {
    return Object.assign(Signal.getDefaults(), {
      value: 0
    });
  }
  dispose() {
    super.dispose();
    this._mult.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/source/oscillator/AMOscillator.js
var AMOscillator = class _AMOscillator extends Source {
  constructor() {
    super(optionsFromArguments(_AMOscillator.getDefaults(), arguments, ["frequency", "type", "modulationType"]));
    this.name = "AMOscillator";
    this._modulationScale = new AudioToGain({ context: this.context });
    this._modulationNode = new Gain({
      context: this.context
    });
    const options = optionsFromArguments(_AMOscillator.getDefaults(), arguments, ["frequency", "type", "modulationType"]);
    this._carrier = new Oscillator({
      context: this.context,
      detune: options.detune,
      frequency: options.frequency,
      onstop: () => this.onstop(this),
      phase: options.phase,
      type: options.type
    });
    this.frequency = this._carrier.frequency, this.detune = this._carrier.detune;
    this._modulator = new Oscillator({
      context: this.context,
      phase: options.phase,
      type: options.modulationType
    });
    this.harmonicity = new Multiply({
      context: this.context,
      units: "positive",
      value: options.harmonicity
    });
    this.frequency.chain(this.harmonicity, this._modulator.frequency);
    this._modulator.chain(this._modulationScale, this._modulationNode.gain);
    this._carrier.chain(this._modulationNode, this.output);
    readOnly(this, ["frequency", "detune", "harmonicity"]);
  }
  static getDefaults() {
    return Object.assign(Oscillator.getDefaults(), {
      harmonicity: 1,
      modulationType: "square"
    });
  }
  /**
   * start the oscillator
   */
  _start(time2) {
    this._modulator.start(time2);
    this._carrier.start(time2);
  }
  /**
   * stop the oscillator
   */
  _stop(time2) {
    this._modulator.stop(time2);
    this._carrier.stop(time2);
  }
  _restart(time2) {
    this._modulator.restart(time2);
    this._carrier.restart(time2);
  }
  /**
   * The type of the carrier oscillator
   */
  get type() {
    return this._carrier.type;
  }
  set type(type) {
    this._carrier.type = type;
  }
  get baseType() {
    return this._carrier.baseType;
  }
  set baseType(baseType) {
    this._carrier.baseType = baseType;
  }
  get partialCount() {
    return this._carrier.partialCount;
  }
  set partialCount(partialCount) {
    this._carrier.partialCount = partialCount;
  }
  /**
   * The type of the modulator oscillator
   */
  get modulationType() {
    return this._modulator.type;
  }
  set modulationType(type) {
    this._modulator.type = type;
  }
  get phase() {
    return this._carrier.phase;
  }
  set phase(phase) {
    this._carrier.phase = phase;
    this._modulator.phase = phase;
  }
  get partials() {
    return this._carrier.partials;
  }
  set partials(partials) {
    this._carrier.partials = partials;
  }
  asArray(length = 1024) {
    return __awaiter(this, void 0, void 0, function* () {
      return generateWaveform(this, length);
    });
  }
  /**
   * Clean up.
   */
  dispose() {
    super.dispose();
    this.frequency.dispose();
    this.detune.dispose();
    this.harmonicity.dispose();
    this._carrier.dispose();
    this._modulator.dispose();
    this._modulationNode.dispose();
    this._modulationScale.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/source/oscillator/FMOscillator.js
var FMOscillator = class _FMOscillator extends Source {
  constructor() {
    super(optionsFromArguments(_FMOscillator.getDefaults(), arguments, ["frequency", "type", "modulationType"]));
    this.name = "FMOscillator";
    this._modulationNode = new Gain({
      context: this.context,
      gain: 0
    });
    const options = optionsFromArguments(_FMOscillator.getDefaults(), arguments, ["frequency", "type", "modulationType"]);
    this._carrier = new Oscillator({
      context: this.context,
      detune: options.detune,
      frequency: 0,
      onstop: () => this.onstop(this),
      phase: options.phase,
      type: options.type
    });
    this.detune = this._carrier.detune;
    this.frequency = new Signal({
      context: this.context,
      units: "frequency",
      value: options.frequency
    });
    this._modulator = new Oscillator({
      context: this.context,
      phase: options.phase,
      type: options.modulationType
    });
    this.harmonicity = new Multiply({
      context: this.context,
      units: "positive",
      value: options.harmonicity
    });
    this.modulationIndex = new Multiply({
      context: this.context,
      units: "positive",
      value: options.modulationIndex
    });
    this.frequency.connect(this._carrier.frequency);
    this.frequency.chain(this.harmonicity, this._modulator.frequency);
    this.frequency.chain(this.modulationIndex, this._modulationNode);
    this._modulator.connect(this._modulationNode.gain);
    this._modulationNode.connect(this._carrier.frequency);
    this._carrier.connect(this.output);
    this.detune.connect(this._modulator.detune);
    readOnly(this, ["modulationIndex", "frequency", "detune", "harmonicity"]);
  }
  static getDefaults() {
    return Object.assign(Oscillator.getDefaults(), {
      harmonicity: 1,
      modulationIndex: 2,
      modulationType: "square"
    });
  }
  /**
   * start the oscillator
   */
  _start(time2) {
    this._modulator.start(time2);
    this._carrier.start(time2);
  }
  /**
   * stop the oscillator
   */
  _stop(time2) {
    this._modulator.stop(time2);
    this._carrier.stop(time2);
  }
  _restart(time2) {
    this._modulator.restart(time2);
    this._carrier.restart(time2);
    return this;
  }
  get type() {
    return this._carrier.type;
  }
  set type(type) {
    this._carrier.type = type;
  }
  get baseType() {
    return this._carrier.baseType;
  }
  set baseType(baseType) {
    this._carrier.baseType = baseType;
  }
  get partialCount() {
    return this._carrier.partialCount;
  }
  set partialCount(partialCount) {
    this._carrier.partialCount = partialCount;
  }
  /**
   * The type of the modulator oscillator
   */
  get modulationType() {
    return this._modulator.type;
  }
  set modulationType(type) {
    this._modulator.type = type;
  }
  get phase() {
    return this._carrier.phase;
  }
  set phase(phase) {
    this._carrier.phase = phase;
    this._modulator.phase = phase;
  }
  get partials() {
    return this._carrier.partials;
  }
  set partials(partials) {
    this._carrier.partials = partials;
  }
  asArray(length = 1024) {
    return __awaiter(this, void 0, void 0, function* () {
      return generateWaveform(this, length);
    });
  }
  /**
   * Clean up.
   */
  dispose() {
    super.dispose();
    this.frequency.dispose();
    this.harmonicity.dispose();
    this._carrier.dispose();
    this._modulator.dispose();
    this._modulationNode.dispose();
    this.modulationIndex.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/source/oscillator/PulseOscillator.js
var PulseOscillator = class _PulseOscillator extends Source {
  constructor() {
    super(optionsFromArguments(_PulseOscillator.getDefaults(), arguments, ["frequency", "width"]));
    this.name = "PulseOscillator";
    this._widthGate = new Gain({
      context: this.context,
      gain: 0
    });
    this._thresh = new WaveShaper({
      context: this.context,
      mapping: (val) => val <= 0 ? -1 : 1
    });
    const options = optionsFromArguments(_PulseOscillator.getDefaults(), arguments, ["frequency", "width"]);
    this.width = new Signal({
      context: this.context,
      units: "audioRange",
      value: options.width
    });
    this._triangle = new Oscillator({
      context: this.context,
      detune: options.detune,
      frequency: options.frequency,
      onstop: () => this.onstop(this),
      phase: options.phase,
      type: "triangle"
    });
    this.frequency = this._triangle.frequency;
    this.detune = this._triangle.detune;
    this._triangle.chain(this._thresh, this.output);
    this.width.chain(this._widthGate, this._thresh);
    readOnly(this, ["width", "frequency", "detune"]);
  }
  static getDefaults() {
    return Object.assign(Source.getDefaults(), {
      detune: 0,
      frequency: 440,
      phase: 0,
      type: "pulse",
      width: 0.2
    });
  }
  /**
   * start the oscillator
   */
  _start(time2) {
    time2 = this.toSeconds(time2);
    this._triangle.start(time2);
    this._widthGate.gain.setValueAtTime(1, time2);
  }
  /**
   * stop the oscillator
   */
  _stop(time2) {
    time2 = this.toSeconds(time2);
    this._triangle.stop(time2);
    this._widthGate.gain.cancelScheduledValues(time2);
    this._widthGate.gain.setValueAtTime(0, time2);
  }
  _restart(time2) {
    this._triangle.restart(time2);
    this._widthGate.gain.cancelScheduledValues(time2);
    this._widthGate.gain.setValueAtTime(1, time2);
  }
  /**
   * The phase of the oscillator in degrees.
   */
  get phase() {
    return this._triangle.phase;
  }
  set phase(phase) {
    this._triangle.phase = phase;
  }
  /**
   * The type of the oscillator. Always returns "pulse".
   */
  get type() {
    return "pulse";
  }
  /**
   * The baseType of the oscillator. Always returns "pulse".
   */
  get baseType() {
    return "pulse";
  }
  /**
   * The partials of the waveform. Cannot set partials for this waveform type
   */
  get partials() {
    return [];
  }
  /**
   * No partials for this waveform type.
   */
  get partialCount() {
    return 0;
  }
  /**
   * *Internal use* The carrier oscillator type is fed through the
   * waveshaper node to create the pulse. Using different carrier oscillators
   * changes oscillator's behavior.
   */
  set carrierType(type) {
    this._triangle.type = type;
  }
  asArray(length = 1024) {
    return __awaiter(this, void 0, void 0, function* () {
      return generateWaveform(this, length);
    });
  }
  /**
   * Clean up method.
   */
  dispose() {
    super.dispose();
    this._triangle.dispose();
    this.width.dispose();
    this._widthGate.dispose();
    this._thresh.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/source/oscillator/FatOscillator.js
var FatOscillator = class _FatOscillator extends Source {
  constructor() {
    super(optionsFromArguments(_FatOscillator.getDefaults(), arguments, ["frequency", "type", "spread"]));
    this.name = "FatOscillator";
    this._oscillators = [];
    const options = optionsFromArguments(_FatOscillator.getDefaults(), arguments, ["frequency", "type", "spread"]);
    this.frequency = new Signal({
      context: this.context,
      units: "frequency",
      value: options.frequency
    });
    this.detune = new Signal({
      context: this.context,
      units: "cents",
      value: options.detune
    });
    this._spread = options.spread;
    this._type = options.type;
    this._phase = options.phase;
    this._partials = options.partials;
    this._partialCount = options.partialCount;
    this.count = options.count;
    readOnly(this, ["frequency", "detune"]);
  }
  static getDefaults() {
    return Object.assign(Oscillator.getDefaults(), {
      count: 3,
      spread: 20,
      type: "sawtooth"
    });
  }
  /**
   * start the oscillator
   */
  _start(time2) {
    time2 = this.toSeconds(time2);
    this._forEach((osc) => osc.start(time2));
  }
  /**
   * stop the oscillator
   */
  _stop(time2) {
    time2 = this.toSeconds(time2);
    this._forEach((osc) => osc.stop(time2));
  }
  _restart(time2) {
    this._forEach((osc) => osc.restart(time2));
  }
  /**
   * Iterate over all of the oscillators
   */
  _forEach(iterator) {
    for (let i = 0; i < this._oscillators.length; i++) {
      iterator(this._oscillators[i], i);
    }
  }
  /**
   * The type of the oscillator
   */
  get type() {
    return this._type;
  }
  set type(type) {
    this._type = type;
    this._forEach((osc) => osc.type = type);
  }
  /**
   * The detune spread between the oscillators. If "count" is
   * set to 3 oscillators and the "spread" is set to 40,
   * the three oscillators would be detuned like this: [-20, 0, 20]
   * for a total detune spread of 40 cents.
   * @example
   * const fatOsc = new Tone.FatOscillator().toDestination().start();
   * fatOsc.spread = 70;
   */
  get spread() {
    return this._spread;
  }
  set spread(spread) {
    this._spread = spread;
    if (this._oscillators.length > 1) {
      const start2 = -spread / 2;
      const step = spread / (this._oscillators.length - 1);
      this._forEach((osc, i) => osc.detune.value = start2 + step * i);
    }
  }
  /**
   * The number of detuned oscillators. Must be an integer greater than 1.
   * @example
   * const fatOsc = new Tone.FatOscillator("C#3", "sawtooth").toDestination().start();
   * // use 4 sawtooth oscillators
   * fatOsc.count = 4;
   */
  get count() {
    return this._oscillators.length;
  }
  set count(count) {
    assertRange(count, 1);
    if (this._oscillators.length !== count) {
      this._forEach((osc) => osc.dispose());
      this._oscillators = [];
      for (let i = 0; i < count; i++) {
        const osc = new Oscillator({
          context: this.context,
          volume: -6 - count * 1.1,
          type: this._type,
          phase: this._phase + i / count * 360,
          partialCount: this._partialCount,
          onstop: i === 0 ? () => this.onstop(this) : noOp
        });
        if (this.type === "custom") {
          osc.partials = this._partials;
        }
        this.frequency.connect(osc.frequency);
        this.detune.connect(osc.detune);
        osc.detune.overridden = false;
        osc.connect(this.output);
        this._oscillators[i] = osc;
      }
      this.spread = this._spread;
      if (this.state === "started") {
        this._forEach((osc) => osc.start());
      }
    }
  }
  get phase() {
    return this._phase;
  }
  set phase(phase) {
    this._phase = phase;
    this._forEach((osc, i) => osc.phase = this._phase + i / this.count * 360);
  }
  get baseType() {
    return this._oscillators[0].baseType;
  }
  set baseType(baseType) {
    this._forEach((osc) => osc.baseType = baseType);
    this._type = this._oscillators[0].type;
  }
  get partials() {
    return this._oscillators[0].partials;
  }
  set partials(partials) {
    this._partials = partials;
    this._partialCount = this._partials.length;
    if (partials.length) {
      this._type = "custom";
      this._forEach((osc) => osc.partials = partials);
    }
  }
  get partialCount() {
    return this._oscillators[0].partialCount;
  }
  set partialCount(partialCount) {
    this._partialCount = partialCount;
    this._forEach((osc) => osc.partialCount = partialCount);
    this._type = this._oscillators[0].type;
  }
  asArray(length = 1024) {
    return __awaiter(this, void 0, void 0, function* () {
      return generateWaveform(this, length);
    });
  }
  /**
   * Clean up.
   */
  dispose() {
    super.dispose();
    this.frequency.dispose();
    this.detune.dispose();
    this._forEach((osc) => osc.dispose());
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/source/oscillator/PWMOscillator.js
var PWMOscillator = class _PWMOscillator extends Source {
  constructor() {
    super(optionsFromArguments(_PWMOscillator.getDefaults(), arguments, ["frequency", "modulationFrequency"]));
    this.name = "PWMOscillator";
    this.sourceType = "pwm";
    this._scale = new Multiply({
      context: this.context,
      value: 2
    });
    const options = optionsFromArguments(_PWMOscillator.getDefaults(), arguments, ["frequency", "modulationFrequency"]);
    this._pulse = new PulseOscillator({
      context: this.context,
      frequency: options.modulationFrequency
    });
    this._pulse.carrierType = "sine";
    this.modulationFrequency = this._pulse.frequency;
    this._modulator = new Oscillator({
      context: this.context,
      detune: options.detune,
      frequency: options.frequency,
      onstop: () => this.onstop(this),
      phase: options.phase
    });
    this.frequency = this._modulator.frequency;
    this.detune = this._modulator.detune;
    this._modulator.chain(this._scale, this._pulse.width);
    this._pulse.connect(this.output);
    readOnly(this, ["modulationFrequency", "frequency", "detune"]);
  }
  static getDefaults() {
    return Object.assign(Source.getDefaults(), {
      detune: 0,
      frequency: 440,
      modulationFrequency: 0.4,
      phase: 0,
      type: "pwm"
    });
  }
  /**
   * start the oscillator
   */
  _start(time2) {
    time2 = this.toSeconds(time2);
    this._modulator.start(time2);
    this._pulse.start(time2);
  }
  /**
   * stop the oscillator
   */
  _stop(time2) {
    time2 = this.toSeconds(time2);
    this._modulator.stop(time2);
    this._pulse.stop(time2);
  }
  /**
   * restart the oscillator
   */
  _restart(time2) {
    this._modulator.restart(time2);
    this._pulse.restart(time2);
  }
  /**
   * The type of the oscillator. Always returns "pwm".
   */
  get type() {
    return "pwm";
  }
  /**
   * The baseType of the oscillator. Always returns "pwm".
   */
  get baseType() {
    return "pwm";
  }
  /**
   * The partials of the waveform. Cannot set partials for this waveform type
   */
  get partials() {
    return [];
  }
  /**
   * No partials for this waveform type.
   */
  get partialCount() {
    return 0;
  }
  /**
   * The phase of the oscillator in degrees.
   */
  get phase() {
    return this._modulator.phase;
  }
  set phase(phase) {
    this._modulator.phase = phase;
  }
  asArray(length = 1024) {
    return __awaiter(this, void 0, void 0, function* () {
      return generateWaveform(this, length);
    });
  }
  /**
   * Clean up.
   */
  dispose() {
    super.dispose();
    this._pulse.dispose();
    this._scale.dispose();
    this._modulator.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/source/oscillator/OmniOscillator.js
var OmniOscillatorSourceMap = {
  am: AMOscillator,
  fat: FatOscillator,
  fm: FMOscillator,
  oscillator: Oscillator,
  pulse: PulseOscillator,
  pwm: PWMOscillator
};
var OmniOscillator = class _OmniOscillator extends Source {
  constructor() {
    super(optionsFromArguments(_OmniOscillator.getDefaults(), arguments, ["frequency", "type"]));
    this.name = "OmniOscillator";
    const options = optionsFromArguments(_OmniOscillator.getDefaults(), arguments, ["frequency", "type"]);
    this.frequency = new Signal({
      context: this.context,
      units: "frequency",
      value: options.frequency
    });
    this.detune = new Signal({
      context: this.context,
      units: "cents",
      value: options.detune
    });
    readOnly(this, ["frequency", "detune"]);
    this.set(options);
  }
  static getDefaults() {
    return Object.assign(Oscillator.getDefaults(), FMOscillator.getDefaults(), AMOscillator.getDefaults(), FatOscillator.getDefaults(), PulseOscillator.getDefaults(), PWMOscillator.getDefaults());
  }
  /**
   * start the oscillator
   */
  _start(time2) {
    this._oscillator.start(time2);
  }
  /**
   * start the oscillator
   */
  _stop(time2) {
    this._oscillator.stop(time2);
  }
  _restart(time2) {
    this._oscillator.restart(time2);
    return this;
  }
  /**
   * The type of the oscillator. Can be any of the basic types: sine, square, triangle, sawtooth. Or
   * prefix the basic types with "fm", "am", or "fat" to use the FMOscillator, AMOscillator or FatOscillator
   * types. The oscillator could also be set to "pwm" or "pulse". All of the parameters of the
   * oscillator's class are accessible when the oscillator is set to that type, but throws an error
   * when it's not.
   * @example
   * const omniOsc = new Tone.OmniOscillator().toDestination().start();
   * omniOsc.type = "pwm";
   * // modulationFrequency is parameter which is available
   * // only when the type is "pwm".
   * omniOsc.modulationFrequency.value = 0.5;
   */
  get type() {
    let prefix = "";
    if (["am", "fm", "fat"].some((p) => this._sourceType === p)) {
      prefix = this._sourceType;
    }
    return prefix + this._oscillator.type;
  }
  set type(type) {
    if (type.substr(0, 2) === "fm") {
      this._createNewOscillator("fm");
      this._oscillator = this._oscillator;
      this._oscillator.type = type.substr(2);
    } else if (type.substr(0, 2) === "am") {
      this._createNewOscillator("am");
      this._oscillator = this._oscillator;
      this._oscillator.type = type.substr(2);
    } else if (type.substr(0, 3) === "fat") {
      this._createNewOscillator("fat");
      this._oscillator = this._oscillator;
      this._oscillator.type = type.substr(3);
    } else if (type === "pwm") {
      this._createNewOscillator("pwm");
      this._oscillator = this._oscillator;
    } else if (type === "pulse") {
      this._createNewOscillator("pulse");
    } else {
      this._createNewOscillator("oscillator");
      this._oscillator = this._oscillator;
      this._oscillator.type = type;
    }
  }
  /**
   * The value is an empty array when the type is not "custom".
   * This is not available on "pwm" and "pulse" oscillator types.
   * @see {@link Oscillator.partials}
   */
  get partials() {
    return this._oscillator.partials;
  }
  set partials(partials) {
    if (!this._getOscType(this._oscillator, "pulse") && !this._getOscType(this._oscillator, "pwm")) {
      this._oscillator.partials = partials;
    }
  }
  get partialCount() {
    return this._oscillator.partialCount;
  }
  set partialCount(partialCount) {
    if (!this._getOscType(this._oscillator, "pulse") && !this._getOscType(this._oscillator, "pwm")) {
      this._oscillator.partialCount = partialCount;
    }
  }
  set(props) {
    if (Reflect.has(props, "type") && props.type) {
      this.type = props.type;
    }
    super.set(props);
    return this;
  }
  /**
   * connect the oscillator to the frequency and detune signals
   */
  _createNewOscillator(oscType) {
    if (oscType !== this._sourceType) {
      this._sourceType = oscType;
      const OscConstructor = OmniOscillatorSourceMap[oscType];
      const now3 = this.now();
      if (this._oscillator) {
        const oldOsc = this._oscillator;
        oldOsc.stop(now3);
        this.context.setTimeout(() => oldOsc.dispose(), this.blockTime);
      }
      this._oscillator = new OscConstructor({
        context: this.context
      });
      this.frequency.connect(this._oscillator.frequency);
      this.detune.connect(this._oscillator.detune);
      this._oscillator.connect(this.output);
      this._oscillator.onstop = () => this.onstop(this);
      if (this.state === "started") {
        this._oscillator.start(now3);
      }
    }
  }
  get phase() {
    return this._oscillator.phase;
  }
  set phase(phase) {
    this._oscillator.phase = phase;
  }
  /**
   * The source type of the oscillator.
   * @example
   * const omniOsc = new Tone.OmniOscillator(440, "fmsquare");
   * console.log(omniOsc.sourceType); // 'fm'
   */
  get sourceType() {
    return this._sourceType;
  }
  set sourceType(sType) {
    let baseType = "sine";
    if (this._oscillator.type !== "pwm" && this._oscillator.type !== "pulse") {
      baseType = this._oscillator.type;
    }
    if (sType === "fm") {
      this.type = "fm" + baseType;
    } else if (sType === "am") {
      this.type = "am" + baseType;
    } else if (sType === "fat") {
      this.type = "fat" + baseType;
    } else if (sType === "oscillator") {
      this.type = baseType;
    } else if (sType === "pulse") {
      this.type = "pulse";
    } else if (sType === "pwm") {
      this.type = "pwm";
    }
  }
  _getOscType(osc, sourceType) {
    return osc instanceof OmniOscillatorSourceMap[sourceType];
  }
  /**
   * The base type of the oscillator.
   * @see {@link Oscillator.baseType}
   * @example
   * const omniOsc = new Tone.OmniOscillator(440, "fmsquare4");
   * console.log(omniOsc.sourceType, omniOsc.baseType, omniOsc.partialCount);
   */
  get baseType() {
    return this._oscillator.baseType;
  }
  set baseType(baseType) {
    if (!this._getOscType(this._oscillator, "pulse") && !this._getOscType(this._oscillator, "pwm") && baseType !== "pulse" && baseType !== "pwm") {
      this._oscillator.baseType = baseType;
    }
  }
  /**
   * The width of the oscillator when sourceType === "pulse".
   * @see {@link PWMOscillator}
   */
  get width() {
    if (this._getOscType(this._oscillator, "pulse")) {
      return this._oscillator.width;
    } else {
      return void 0;
    }
  }
  /**
   * The number of detuned oscillators when sourceType === "fat".
   * @see {@link FatOscillator.count}
   */
  get count() {
    if (this._getOscType(this._oscillator, "fat")) {
      return this._oscillator.count;
    } else {
      return void 0;
    }
  }
  set count(count) {
    if (this._getOscType(this._oscillator, "fat") && isNumber(count)) {
      this._oscillator.count = count;
    }
  }
  /**
   * The detune spread between the oscillators when sourceType === "fat".
   * @see {@link FatOscillator.count}
   */
  get spread() {
    if (this._getOscType(this._oscillator, "fat")) {
      return this._oscillator.spread;
    } else {
      return void 0;
    }
  }
  set spread(spread) {
    if (this._getOscType(this._oscillator, "fat") && isNumber(spread)) {
      this._oscillator.spread = spread;
    }
  }
  /**
   * The type of the modulator oscillator. Only if the oscillator is set to "am" or "fm" types.
   * @see {@link AMOscillator} or {@link FMOscillator}
   */
  get modulationType() {
    if (this._getOscType(this._oscillator, "fm") || this._getOscType(this._oscillator, "am")) {
      return this._oscillator.modulationType;
    } else {
      return void 0;
    }
  }
  set modulationType(mType) {
    if ((this._getOscType(this._oscillator, "fm") || this._getOscType(this._oscillator, "am")) && isString(mType)) {
      this._oscillator.modulationType = mType;
    }
  }
  /**
   * The modulation index when the sourceType === "fm"
   * @see {@link FMOscillator}.
   */
  get modulationIndex() {
    if (this._getOscType(this._oscillator, "fm")) {
      return this._oscillator.modulationIndex;
    } else {
      return void 0;
    }
  }
  /**
   * Harmonicity is the frequency ratio between the carrier and the modulator oscillators.
   * @see {@link AMOscillator} or {@link FMOscillator}
   */
  get harmonicity() {
    if (this._getOscType(this._oscillator, "fm") || this._getOscType(this._oscillator, "am")) {
      return this._oscillator.harmonicity;
    } else {
      return void 0;
    }
  }
  /**
   * The modulationFrequency Signal of the oscillator when sourceType === "pwm"
   * see {@link PWMOscillator}
   * @min 0.1
   * @max 5
   */
  get modulationFrequency() {
    if (this._getOscType(this._oscillator, "pwm")) {
      return this._oscillator.modulationFrequency;
    } else {
      return void 0;
    }
  }
  asArray(length = 1024) {
    return __awaiter(this, void 0, void 0, function* () {
      return generateWaveform(this, length);
    });
  }
  dispose() {
    super.dispose();
    this.detune.dispose();
    this.frequency.dispose();
    this._oscillator.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/signal/Add.js
var Add = class _Add extends Signal {
  constructor() {
    super(Object.assign(optionsFromArguments(_Add.getDefaults(), arguments, ["value"])));
    this.override = false;
    this.name = "Add";
    this._sum = new Gain({ context: this.context });
    this.input = this._sum;
    this.output = this._sum;
    this.addend = this._param;
    connectSeries(this._constantSource, this._sum);
  }
  static getDefaults() {
    return Object.assign(Signal.getDefaults(), {
      value: 0
    });
  }
  dispose() {
    super.dispose();
    this._sum.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/signal/Scale.js
var Scale = class _Scale extends SignalOperator {
  constructor() {
    super(Object.assign(optionsFromArguments(_Scale.getDefaults(), arguments, ["min", "max"])));
    this.name = "Scale";
    const options = optionsFromArguments(_Scale.getDefaults(), arguments, ["min", "max"]);
    this._mult = this.input = new Multiply({
      context: this.context,
      value: options.max - options.min
    });
    this._add = this.output = new Add({
      context: this.context,
      value: options.min
    });
    this._min = options.min;
    this._max = options.max;
    this.input.connect(this.output);
  }
  static getDefaults() {
    return Object.assign(SignalOperator.getDefaults(), {
      max: 1,
      min: 0
    });
  }
  /**
   * The minimum output value. This number is output when the value input value is 0.
   */
  get min() {
    return this._min;
  }
  set min(min2) {
    this._min = min2;
    this._setRange();
  }
  /**
   * The maximum output value. This number is output when the value input value is 1.
   */
  get max() {
    return this._max;
  }
  set max(max2) {
    this._max = max2;
    this._setRange();
  }
  /**
   * set the values
   */
  _setRange() {
    this._add.value = this._min;
    this._mult.value = this._max - this._min;
  }
  dispose() {
    super.dispose();
    this._add.dispose();
    this._mult.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/signal/Zero.js
var Zero = class _Zero extends SignalOperator {
  constructor() {
    super(Object.assign(optionsFromArguments(_Zero.getDefaults(), arguments)));
    this.name = "Zero";
    this._gain = new Gain({ context: this.context });
    this.output = this._gain;
    this.input = void 0;
    connect(this.context.getConstant(0), this._gain);
  }
  /**
   * clean up
   */
  dispose() {
    super.dispose();
    disconnect(this.context.getConstant(0), this._gain);
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/source/oscillator/LFO.js
var LFO = class _LFO extends ToneAudioNode {
  constructor() {
    super(optionsFromArguments(_LFO.getDefaults(), arguments, ["frequency", "min", "max"]));
    this.name = "LFO";
    this._stoppedValue = 0;
    this._units = "number";
    this.convert = true;
    this._fromType = Param.prototype._fromType;
    this._toType = Param.prototype._toType;
    this._is = Param.prototype._is;
    this._clampValue = Param.prototype._clampValue;
    const options = optionsFromArguments(_LFO.getDefaults(), arguments, ["frequency", "min", "max"]);
    this._oscillator = new Oscillator(options);
    this.frequency = this._oscillator.frequency;
    this._amplitudeGain = new Gain({
      context: this.context,
      gain: options.amplitude,
      units: "normalRange"
    });
    this.amplitude = this._amplitudeGain.gain;
    this._stoppedSignal = new Signal({
      context: this.context,
      units: "audioRange",
      value: 0
    });
    this._zeros = new Zero({ context: this.context });
    this._a2g = new AudioToGain({ context: this.context });
    this._scaler = this.output = new Scale({
      context: this.context,
      max: options.max,
      min: options.min
    });
    this.units = options.units;
    this.min = options.min;
    this.max = options.max;
    this._oscillator.chain(this._amplitudeGain, this._a2g, this._scaler);
    this._zeros.connect(this._a2g);
    this._stoppedSignal.connect(this._a2g);
    readOnly(this, ["amplitude", "frequency"]);
    this.phase = options.phase;
  }
  static getDefaults() {
    return Object.assign(Oscillator.getDefaults(), {
      amplitude: 1,
      frequency: "4n",
      max: 1,
      min: 0,
      type: "sine",
      units: "number"
    });
  }
  /**
   * Start the LFO.
   * @param time The time the LFO will start
   */
  start(time2) {
    time2 = this.toSeconds(time2);
    this._stoppedSignal.setValueAtTime(0, time2);
    this._oscillator.start(time2);
    return this;
  }
  /**
   * Stop the LFO.
   * @param  time The time the LFO will stop
   */
  stop(time2) {
    time2 = this.toSeconds(time2);
    this._stoppedSignal.setValueAtTime(this._stoppedValue, time2);
    this._oscillator.stop(time2);
    return this;
  }
  /**
   * Sync the start/stop/pause to the transport
   * and the frequency to the bpm of the transport
   * @example
   * const lfo = new Tone.LFO("8n");
   * lfo.sync().start(0);
   * // the rate of the LFO will always be an eighth note, even as the tempo changes
   */
  sync() {
    this._oscillator.sync();
    this._oscillator.syncFrequency();
    return this;
  }
  /**
   * unsync the LFO from transport control
   */
  unsync() {
    this._oscillator.unsync();
    this._oscillator.unsyncFrequency();
    return this;
  }
  /**
   * After the oscillator waveform is updated, reset the `_stoppedSignal` value to match the updated waveform
   */
  _setStoppedValue() {
    this._stoppedValue = this._oscillator.getInitialValue();
    this._stoppedSignal.value = this._stoppedValue;
  }
  /**
   * The minimum output of the LFO.
   */
  get min() {
    return this._toType(this._scaler.min);
  }
  set min(min2) {
    min2 = this._fromType(min2);
    this._scaler.min = min2;
  }
  /**
   * The maximum output of the LFO.
   */
  get max() {
    return this._toType(this._scaler.max);
  }
  set max(max2) {
    max2 = this._fromType(max2);
    this._scaler.max = max2;
  }
  /**
   * The type of the oscillator.
   * @see {@link Oscillator.type}
   */
  get type() {
    return this._oscillator.type;
  }
  set type(type) {
    this._oscillator.type = type;
    this._setStoppedValue();
  }
  /**
   * The oscillator's partials array.
   * @see {@link Oscillator.partials}
   */
  get partials() {
    return this._oscillator.partials;
  }
  set partials(partials) {
    this._oscillator.partials = partials;
    this._setStoppedValue();
  }
  /**
   * The phase of the LFO.
   */
  get phase() {
    return this._oscillator.phase;
  }
  set phase(phase) {
    this._oscillator.phase = phase;
    this._setStoppedValue();
  }
  /**
   * The output units of the LFO.
   */
  get units() {
    return this._units;
  }
  set units(val) {
    const currentMin = this.min;
    const currentMax = this.max;
    this._units = val;
    this.min = currentMin;
    this.max = currentMax;
  }
  /**
   * Returns the playback state of the source, either "started" or "stopped".
   */
  get state() {
    return this._oscillator.state;
  }
  /**
   * @param node the destination to connect to
   * @param outputNum the optional output number
   * @param inputNum the input number
   */
  connect(node, outputNum, inputNum) {
    if (node instanceof Param || node instanceof Signal) {
      this.convert = node.convert;
      this.units = node.units;
    }
    connectSignal(this, node, outputNum, inputNum);
    return this;
  }
  dispose() {
    super.dispose();
    this._oscillator.dispose();
    this._stoppedSignal.dispose();
    this._zeros.dispose();
    this._scaler.dispose();
    this._a2g.dispose();
    this._amplitudeGain.dispose();
    this.amplitude.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/core/util/Decorator.js
function range(min2, max2 = Infinity) {
  const valueMap = /* @__PURE__ */ new WeakMap();
  return function(target, propertyKey) {
    Reflect.defineProperty(target, propertyKey, {
      configurable: true,
      enumerable: true,
      get: function() {
        return valueMap.get(this);
      },
      set: function(newValue) {
        assertRange(newValue, min2, max2);
        valueMap.set(this, newValue);
      }
    });
  };
}
function timeRange(min2, max2 = Infinity) {
  const valueMap = /* @__PURE__ */ new WeakMap();
  return function(target, propertyKey) {
    Reflect.defineProperty(target, propertyKey, {
      configurable: true,
      enumerable: true,
      get: function() {
        return valueMap.get(this);
      },
      set: function(newValue) {
        assertRange(this.toSeconds(newValue), min2, max2);
        valueMap.set(this, newValue);
      }
    });
  };
}

// node_modules/@magenta/music/node_modules/tone/build/esm/source/buffer/Player.js
var Player = class _Player extends Source {
  constructor() {
    super(optionsFromArguments(_Player.getDefaults(), arguments, [
      "url",
      "onload"
    ]));
    this.name = "Player";
    this._activeSources = /* @__PURE__ */ new Set();
    const options = optionsFromArguments(_Player.getDefaults(), arguments, [
      "url",
      "onload"
    ]);
    this._buffer = new ToneAudioBuffer({
      onload: this._onload.bind(this, options.onload),
      onerror: options.onerror,
      reverse: options.reverse,
      url: options.url
    });
    this.autostart = options.autostart;
    this._loop = options.loop;
    this._loopStart = options.loopStart;
    this._loopEnd = options.loopEnd;
    this._playbackRate = options.playbackRate;
    this.fadeIn = options.fadeIn;
    this.fadeOut = options.fadeOut;
  }
  static getDefaults() {
    return Object.assign(Source.getDefaults(), {
      autostart: false,
      fadeIn: 0,
      fadeOut: 0,
      loop: false,
      loopEnd: 0,
      loopStart: 0,
      onload: noOp,
      onerror: noOp,
      playbackRate: 1,
      reverse: false
    });
  }
  /**
   * Load the audio file as an audio buffer.
   * Decodes the audio asynchronously and invokes
   * the callback once the audio buffer loads.
   * Note: this does not need to be called if a url
   * was passed in to the constructor. Only use this
   * if you want to manually load a new url.
   * @param url The url of the buffer to load. Filetype support depends on the browser.
   */
  load(url) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this._buffer.load(url);
      this._onload();
      return this;
    });
  }
  /**
   * Internal callback when the buffer is loaded.
   */
  _onload(callback = noOp) {
    callback();
    if (this.autostart) {
      this.start();
    }
  }
  /**
   * Internal callback when the buffer is done playing.
   */
  _onSourceEnd(source) {
    this.onstop(this);
    this._activeSources.delete(source);
    if (this._activeSources.size === 0 && !this._synced && this._state.getValueAtTime(this.now()) === "started") {
      this._state.cancel(this.now());
      this._state.setStateAtTime("stopped", this.now());
    }
  }
  /**
   * Play the buffer at the given startTime. Optionally add an offset
   * and/or duration which will play the buffer from a position
   * within the buffer for the given duration.
   *
   * @param  time When the player should start.
   * @param  offset The offset from the beginning of the sample to start at.
   * @param  duration How long the sample should play. If no duration is given, it will default to the full length of the sample (minus any offset)
   */
  start(time2, offset, duration) {
    super.start(time2, offset, duration);
    return this;
  }
  /**
   * Internal start method
   */
  _start(startTime, offset, duration) {
    if (this._loop) {
      offset = defaultArg(offset, this._loopStart);
    } else {
      offset = defaultArg(offset, 0);
    }
    const computedOffset = this.toSeconds(offset);
    const origDuration = duration;
    duration = defaultArg(duration, Math.max(this._buffer.duration - computedOffset, 0));
    let computedDuration = this.toSeconds(duration);
    computedDuration = computedDuration / this._playbackRate;
    startTime = this.toSeconds(startTime);
    const source = new ToneBufferSource({
      url: this._buffer,
      context: this.context,
      fadeIn: this.fadeIn,
      fadeOut: this.fadeOut,
      loop: this._loop,
      loopEnd: this._loopEnd,
      loopStart: this._loopStart,
      onended: this._onSourceEnd.bind(this),
      playbackRate: this._playbackRate
    }).connect(this.output);
    if (!this._loop && !this._synced) {
      this._state.cancel(startTime + computedDuration);
      this._state.setStateAtTime("stopped", startTime + computedDuration, {
        implicitEnd: true
      });
    }
    this._activeSources.add(source);
    if (this._loop && isUndef(origDuration)) {
      source.start(startTime, computedOffset);
    } else {
      source.start(startTime, computedOffset, computedDuration - this.toSeconds(this.fadeOut));
    }
  }
  /**
   * Stop playback.
   */
  _stop(time2) {
    const computedTime = this.toSeconds(time2);
    this._activeSources.forEach((source) => source.stop(computedTime));
  }
  /**
   * Stop and then restart the player from the beginning (or offset)
   * @param  time When the player should start.
   * @param  offset The offset from the beginning of the sample to start at.
   * @param  duration How long the sample should play. If no duration is given,
   * 					it will default to the full length of the sample (minus any offset)
   */
  restart(time2, offset, duration) {
    super.restart(time2, offset, duration);
    return this;
  }
  _restart(time2, offset, duration) {
    var _a;
    (_a = [...this._activeSources].pop()) === null || _a === void 0 ? void 0 : _a.stop(time2);
    this._start(time2, offset, duration);
  }
  /**
   * Seek to a specific time in the player's buffer. If the
   * source is no longer playing at that time, it will stop.
   * @param offset The time to seek to.
   * @param when The time for the seek event to occur.
   * @example
   * const player = new Tone.Player("https://tonejs.github.io/audio/berklee/gurgling_theremin_1.mp3", () => {
   * 	player.start();
   * 	// seek to the offset in 1 second from now
   * 	player.seek(0.4, "+1");
   * }).toDestination();
   */
  seek(offset, when) {
    const computedTime = this.toSeconds(when);
    if (this._state.getValueAtTime(computedTime) === "started") {
      const computedOffset = this.toSeconds(offset);
      this._stop(computedTime);
      this._start(computedTime, computedOffset);
    }
    return this;
  }
  /**
   * Set the loop start and end. Will only loop if loop is set to true.
   * @param loopStart The loop start time
   * @param loopEnd The loop end time
   * @example
   * const player = new Tone.Player("https://tonejs.github.io/audio/berklee/malevoices_aa2_F3.mp3").toDestination();
   * // loop between the given points
   * player.setLoopPoints(0.2, 0.3);
   * player.loop = true;
   * player.autostart = true;
   */
  setLoopPoints(loopStart, loopEnd) {
    this.loopStart = loopStart;
    this.loopEnd = loopEnd;
    return this;
  }
  /**
   * If loop is true, the loop will start at this position.
   */
  get loopStart() {
    return this._loopStart;
  }
  set loopStart(loopStart) {
    this._loopStart = loopStart;
    if (this.buffer.loaded) {
      assertRange(this.toSeconds(loopStart), 0, this.buffer.duration);
    }
    this._activeSources.forEach((source) => {
      source.loopStart = loopStart;
    });
  }
  /**
   * If loop is true, the loop will end at this position.
   */
  get loopEnd() {
    return this._loopEnd;
  }
  set loopEnd(loopEnd) {
    this._loopEnd = loopEnd;
    if (this.buffer.loaded) {
      assertRange(this.toSeconds(loopEnd), 0, this.buffer.duration);
    }
    this._activeSources.forEach((source) => {
      source.loopEnd = loopEnd;
    });
  }
  /**
   * The audio buffer belonging to the player.
   */
  get buffer() {
    return this._buffer;
  }
  set buffer(buffer2) {
    this._buffer.set(buffer2);
  }
  /**
   * If the buffer should loop once it's over.
   * @example
   * const player = new Tone.Player("https://tonejs.github.io/audio/drum-samples/breakbeat.mp3").toDestination();
   * player.loop = true;
   * player.autostart = true;
   */
  get loop() {
    return this._loop;
  }
  set loop(loop) {
    if (this._loop === loop) {
      return;
    }
    this._loop = loop;
    this._activeSources.forEach((source) => {
      source.loop = loop;
    });
    if (loop) {
      const stopEvent = this._state.getNextState("stopped", this.now());
      if (stopEvent) {
        this._state.cancel(stopEvent.time);
      }
    }
  }
  /**
   * Normal speed is 1. The pitch will change with the playback rate.
   * @example
   * const player = new Tone.Player("https://tonejs.github.io/audio/berklee/femalevoices_aa2_A5.mp3").toDestination();
   * // play at 1/4 speed
   * player.playbackRate = 0.25;
   * // play as soon as the buffer is loaded
   * player.autostart = true;
   */
  get playbackRate() {
    return this._playbackRate;
  }
  set playbackRate(rate) {
    this._playbackRate = rate;
    const now3 = this.now();
    const stopEvent = this._state.getNextState("stopped", now3);
    if (stopEvent && stopEvent.implicitEnd) {
      this._state.cancel(stopEvent.time);
      this._activeSources.forEach((source) => source.cancelStop());
    }
    this._activeSources.forEach((source) => {
      source.playbackRate.setValueAtTime(rate, now3);
    });
  }
  /**
   * If the buffer should be reversed. Note that this sets the underlying {@link ToneAudioBuffer.reverse}, so
   * if multiple players are pointing at the same ToneAudioBuffer, they will all be reversed.
   * @example
   * const player = new Tone.Player("https://tonejs.github.io/audio/berklee/chime_1.mp3").toDestination();
   * player.autostart = true;
   * player.reverse = true;
   */
  get reverse() {
    return this._buffer.reverse;
  }
  set reverse(rev) {
    this._buffer.reverse = rev;
  }
  /**
   * If the buffer is loaded
   */
  get loaded() {
    return this._buffer.loaded;
  }
  dispose() {
    super.dispose();
    this._activeSources.forEach((source) => source.dispose());
    this._activeSources.clear();
    this._buffer.dispose();
    return this;
  }
};
__decorate([
  timeRange(0)
], Player.prototype, "fadeIn", void 0);
__decorate([
  timeRange(0)
], Player.prototype, "fadeOut", void 0);

// node_modules/@magenta/music/node_modules/tone/build/esm/source/buffer/Players.js
var Players = class _Players extends ToneAudioNode {
  constructor() {
    super(optionsFromArguments(_Players.getDefaults(), arguments, ["urls", "onload"], "urls"));
    this.name = "Players";
    this.input = void 0;
    this._players = /* @__PURE__ */ new Map();
    const options = optionsFromArguments(_Players.getDefaults(), arguments, ["urls", "onload"], "urls");
    this._volume = this.output = new Volume({
      context: this.context,
      volume: options.volume
    });
    this.volume = this._volume.volume;
    readOnly(this, "volume");
    this._buffers = new ToneAudioBuffers({
      urls: options.urls,
      onload: options.onload,
      baseUrl: options.baseUrl,
      onerror: options.onerror
    });
    this.mute = options.mute;
    this._fadeIn = options.fadeIn;
    this._fadeOut = options.fadeOut;
  }
  static getDefaults() {
    return Object.assign(Source.getDefaults(), {
      baseUrl: "",
      fadeIn: 0,
      fadeOut: 0,
      mute: false,
      onload: noOp,
      onerror: noOp,
      urls: {},
      volume: 0
    });
  }
  /**
   * Mute the output.
   */
  get mute() {
    return this._volume.mute;
  }
  set mute(mute) {
    this._volume.mute = mute;
  }
  /**
   * The fadeIn time of the envelope applied to the source.
   */
  get fadeIn() {
    return this._fadeIn;
  }
  set fadeIn(fadeIn) {
    this._fadeIn = fadeIn;
    this._players.forEach((player) => {
      player.fadeIn = fadeIn;
    });
  }
  /**
   * The fadeOut time of the each of the sources.
   */
  get fadeOut() {
    return this._fadeOut;
  }
  set fadeOut(fadeOut) {
    this._fadeOut = fadeOut;
    this._players.forEach((player) => {
      player.fadeOut = fadeOut;
    });
  }
  /**
   * The state of the players object. Returns "started" if any of the players are playing.
   */
  get state() {
    const playing = Array.from(this._players).some(([_, player]) => player.state === "started");
    return playing ? "started" : "stopped";
  }
  /**
   * True if the buffers object has a buffer by that name.
   * @param name  The key or index of the buffer.
   */
  has(name) {
    return this._buffers.has(name);
  }
  /**
   * Get a player by name.
   * @param  name  The players name as defined in the constructor object or `add` method.
   */
  player(name) {
    assert(this.has(name), `No Player with the name ${name} exists on this object`);
    if (!this._players.has(name)) {
      const player = new Player({
        context: this.context,
        fadeIn: this._fadeIn,
        fadeOut: this._fadeOut,
        url: this._buffers.get(name)
      }).connect(this.output);
      this._players.set(name, player);
    }
    return this._players.get(name);
  }
  /**
   * If all the buffers are loaded or not
   */
  get loaded() {
    return this._buffers.loaded;
  }
  /**
   * Add a player by name and url to the Players
   * @param  name A unique name to give the player
   * @param  url  Either the url of the bufer or a buffer which will be added with the given name.
   * @param callback  The callback to invoke when the url is loaded.
   * @example
   * const players = new Tone.Players();
   * players.add("gong", "https://tonejs.github.io/audio/berklee/gong_1.mp3", () => {
   * 	console.log("gong loaded");
   * 	players.player("gong").start();
   * });
   */
  add(name, url, callback) {
    assert(!this._buffers.has(name), "A buffer with that name already exists on this object");
    this._buffers.add(name, url, callback);
    return this;
  }
  /**
   * Stop all of the players at the given time
   * @param time The time to stop all of the players.
   */
  stopAll(time2) {
    this._players.forEach((player) => player.stop(time2));
    return this;
  }
  dispose() {
    super.dispose();
    this._volume.dispose();
    this.volume.dispose();
    this._players.forEach((player) => player.dispose());
    this._buffers.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/source/buffer/GrainPlayer.js
var GrainPlayer = class _GrainPlayer extends Source {
  constructor() {
    super(optionsFromArguments(_GrainPlayer.getDefaults(), arguments, ["url", "onload"]));
    this.name = "GrainPlayer";
    this._loopStart = 0;
    this._loopEnd = 0;
    this._activeSources = [];
    const options = optionsFromArguments(_GrainPlayer.getDefaults(), arguments, ["url", "onload"]);
    this.buffer = new ToneAudioBuffer({
      onload: options.onload,
      onerror: options.onerror,
      reverse: options.reverse,
      url: options.url
    });
    this._clock = new Clock({
      context: this.context,
      callback: this._tick.bind(this),
      frequency: 1 / options.grainSize
    });
    this._playbackRate = options.playbackRate;
    this._grainSize = options.grainSize;
    this._overlap = options.overlap;
    this.detune = options.detune;
    this.overlap = options.overlap;
    this.loop = options.loop;
    this.playbackRate = options.playbackRate;
    this.grainSize = options.grainSize;
    this.loopStart = options.loopStart;
    this.loopEnd = options.loopEnd;
    this.reverse = options.reverse;
    this._clock.on("stop", this._onstop.bind(this));
  }
  static getDefaults() {
    return Object.assign(Source.getDefaults(), {
      onload: noOp,
      onerror: noOp,
      overlap: 0.1,
      grainSize: 0.2,
      playbackRate: 1,
      detune: 0,
      loop: false,
      loopStart: 0,
      loopEnd: 0,
      reverse: false
    });
  }
  /**
   * Internal start method
   */
  _start(time2, offset, duration) {
    offset = defaultArg(offset, 0);
    offset = this.toSeconds(offset);
    time2 = this.toSeconds(time2);
    const grainSize = 1 / this._clock.frequency.getValueAtTime(time2);
    this._clock.start(time2, offset / grainSize);
    if (duration) {
      this.stop(time2 + this.toSeconds(duration));
    }
  }
  /**
   * Stop and then restart the player from the beginning (or offset)
   * @param  time When the player should start.
   * @param  offset The offset from the beginning of the sample to start at.
   * @param  duration How long the sample should play. If no duration is given,
   * 					it will default to the full length of the sample (minus any offset)
   */
  restart(time2, offset, duration) {
    super.restart(time2, offset, duration);
    return this;
  }
  _restart(time2, offset, duration) {
    this._stop(time2);
    this._start(time2, offset, duration);
  }
  /**
   * Internal stop method
   */
  _stop(time2) {
    this._clock.stop(time2);
  }
  /**
   * Invoked when the clock is stopped
   */
  _onstop(time2) {
    this._activeSources.forEach((source) => {
      source.fadeOut = 0;
      source.stop(time2);
    });
    this.onstop(this);
  }
  /**
   * Invoked on each clock tick. scheduled a new grain at this time.
   */
  _tick(time2) {
    const ticks = this._clock.getTicksAtTime(time2);
    const offset = ticks * this._grainSize;
    this.log("offset", offset);
    if (!this.loop && offset > this.buffer.duration) {
      this.stop(time2);
      return;
    }
    const fadeIn = offset < this._overlap ? 0 : this._overlap;
    const source = new ToneBufferSource({
      context: this.context,
      url: this.buffer,
      fadeIn,
      fadeOut: this._overlap,
      loop: this.loop,
      loopStart: this._loopStart,
      loopEnd: this._loopEnd,
      // compute the playbackRate based on the detune
      playbackRate: intervalToFrequencyRatio(this.detune / 100)
    }).connect(this.output);
    source.start(time2, this._grainSize * ticks);
    source.stop(time2 + this._grainSize / this.playbackRate);
    this._activeSources.push(source);
    source.onended = () => {
      const index = this._activeSources.indexOf(source);
      if (index !== -1) {
        this._activeSources.splice(index, 1);
      }
    };
  }
  /**
   * The playback rate of the sample
   */
  get playbackRate() {
    return this._playbackRate;
  }
  set playbackRate(rate) {
    assertRange(rate, 1e-3);
    this._playbackRate = rate;
    this.grainSize = this._grainSize;
  }
  /**
   * The loop start time.
   */
  get loopStart() {
    return this._loopStart;
  }
  set loopStart(time2) {
    if (this.buffer.loaded) {
      assertRange(this.toSeconds(time2), 0, this.buffer.duration);
    }
    this._loopStart = this.toSeconds(time2);
  }
  /**
   * The loop end time.
   */
  get loopEnd() {
    return this._loopEnd;
  }
  set loopEnd(time2) {
    if (this.buffer.loaded) {
      assertRange(this.toSeconds(time2), 0, this.buffer.duration);
    }
    this._loopEnd = this.toSeconds(time2);
  }
  /**
   * The direction the buffer should play in
   */
  get reverse() {
    return this.buffer.reverse;
  }
  set reverse(rev) {
    this.buffer.reverse = rev;
  }
  /**
   * The size of each chunk of audio that the
   * buffer is chopped into and played back at.
   */
  get grainSize() {
    return this._grainSize;
  }
  set grainSize(size) {
    this._grainSize = this.toSeconds(size);
    this._clock.frequency.setValueAtTime(this._playbackRate / this._grainSize, this.now());
  }
  /**
   * The duration of the cross-fade between successive grains.
   */
  get overlap() {
    return this._overlap;
  }
  set overlap(time2) {
    const computedTime = this.toSeconds(time2);
    assertRange(computedTime, 0);
    this._overlap = computedTime;
  }
  /**
   * If all the buffer is loaded
   */
  get loaded() {
    return this.buffer.loaded;
  }
  dispose() {
    super.dispose();
    this.buffer.dispose();
    this._clock.dispose();
    this._activeSources.forEach((source) => source.dispose());
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/signal/Abs.js
var Abs = class extends SignalOperator {
  constructor() {
    super(...arguments);
    this.name = "Abs";
    this._abs = new WaveShaper({
      context: this.context,
      mapping: (val) => {
        if (Math.abs(val) < 1e-3) {
          return 0;
        } else {
          return Math.abs(val);
        }
      }
    });
    this.input = this._abs;
    this.output = this._abs;
  }
  /**
   * clean up
   */
  dispose() {
    super.dispose();
    this._abs.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/signal/GainToAudio.js
var GainToAudio = class extends SignalOperator {
  constructor() {
    super(...arguments);
    this.name = "GainToAudio";
    this._norm = new WaveShaper({
      context: this.context,
      mapping: (x) => Math.abs(x) * 2 - 1
    });
    this.input = this._norm;
    this.output = this._norm;
  }
  /**
   * clean up
   */
  dispose() {
    super.dispose();
    this._norm.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/signal/Negate.js
var Negate = class extends SignalOperator {
  constructor() {
    super(...arguments);
    this.name = "Negate";
    this._multiply = new Multiply({
      context: this.context,
      value: -1
    });
    this.input = this._multiply;
    this.output = this._multiply;
  }
  /**
   * clean up
   * @returns {Negate} this
   */
  dispose() {
    super.dispose();
    this._multiply.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/signal/Subtract.js
var Subtract = class _Subtract extends Signal {
  constructor() {
    super(Object.assign(optionsFromArguments(_Subtract.getDefaults(), arguments, ["value"])));
    this.override = false;
    this.name = "Subtract";
    this._sum = new Gain({ context: this.context });
    this.input = this._sum;
    this.output = this._sum;
    this._neg = new Negate({ context: this.context });
    this.subtrahend = this._param;
    connectSeries(this._constantSource, this._neg, this._sum);
  }
  static getDefaults() {
    return Object.assign(Signal.getDefaults(), {
      value: 0
    });
  }
  dispose() {
    super.dispose();
    this._neg.dispose();
    this._sum.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/signal/GreaterThanZero.js
var GreaterThanZero = class _GreaterThanZero extends SignalOperator {
  constructor() {
    super(Object.assign(optionsFromArguments(_GreaterThanZero.getDefaults(), arguments)));
    this.name = "GreaterThanZero";
    this._thresh = this.output = new WaveShaper({
      context: this.context,
      length: 127,
      mapping: (val) => {
        if (val <= 0) {
          return 0;
        } else {
          return 1;
        }
      }
    });
    this._scale = this.input = new Multiply({
      context: this.context,
      value: 1e4
    });
    this._scale.connect(this._thresh);
  }
  dispose() {
    super.dispose();
    this._scale.dispose();
    this._thresh.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/signal/GreaterThan.js
var GreaterThan = class _GreaterThan extends Signal {
  constructor() {
    super(Object.assign(optionsFromArguments(_GreaterThan.getDefaults(), arguments, ["value"])));
    this.name = "GreaterThan";
    this.override = false;
    const options = optionsFromArguments(_GreaterThan.getDefaults(), arguments, ["value"]);
    this._subtract = this.input = new Subtract({
      context: this.context,
      value: options.value
    });
    this._gtz = this.output = new GreaterThanZero({ context: this.context });
    this.comparator = this._param = this._subtract.subtrahend;
    readOnly(this, "comparator");
    this._subtract.connect(this._gtz);
  }
  static getDefaults() {
    return Object.assign(Signal.getDefaults(), {
      value: 0
    });
  }
  dispose() {
    super.dispose();
    this._gtz.dispose();
    this._subtract.dispose();
    this.comparator.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/signal/ScaleExp.js
var ScaleExp = class _ScaleExp extends Scale {
  constructor() {
    super(Object.assign(optionsFromArguments(_ScaleExp.getDefaults(), arguments, ["min", "max", "exponent"])));
    this.name = "ScaleExp";
    const options = optionsFromArguments(_ScaleExp.getDefaults(), arguments, ["min", "max", "exponent"]);
    this.input = this._exp = new Pow({
      context: this.context,
      value: options.exponent
    });
    this._exp.connect(this._mult);
  }
  static getDefaults() {
    return Object.assign(Scale.getDefaults(), {
      exponent: 1
    });
  }
  /**
   * Instead of interpolating linearly between the {@link min} and
   * {@link max} values, setting the exponent will interpolate between
   * the two values with an exponential curve.
   */
  get exponent() {
    return this._exp.value;
  }
  set exponent(exp2) {
    this._exp.value = exp2;
  }
  dispose() {
    super.dispose();
    this._exp.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/signal/SyncedSignal.js
var SyncedSignal = class extends Signal {
  constructor() {
    super(optionsFromArguments(Signal.getDefaults(), arguments, ["value", "units"]));
    this.name = "SyncedSignal";
    this.override = false;
    const options = optionsFromArguments(Signal.getDefaults(), arguments, ["value", "units"]);
    this._lastVal = options.value;
    this._synced = this.context.transport.scheduleRepeat(this._onTick.bind(this), "1i");
    this._syncedCallback = this._anchorValue.bind(this);
    this.context.transport.on("start", this._syncedCallback);
    this.context.transport.on("pause", this._syncedCallback);
    this.context.transport.on("stop", this._syncedCallback);
    this._constantSource.disconnect();
    this._constantSource.stop(0);
    this._constantSource = this.output = new ToneConstantSource({
      context: this.context,
      offset: options.value,
      units: options.units
    }).start(0);
    this.setValueAtTime(options.value, 0);
  }
  /**
   * Callback which is invoked every tick.
   */
  _onTick(time2) {
    const val = super.getValueAtTime(this.context.transport.seconds);
    if (this._lastVal !== val) {
      this._lastVal = val;
      this._constantSource.offset.setValueAtTime(val, time2);
    }
  }
  /**
   * Anchor the value at the start and stop of the Transport
   */
  _anchorValue(time2) {
    const val = super.getValueAtTime(this.context.transport.seconds);
    this._lastVal = val;
    this._constantSource.offset.cancelAndHoldAtTime(time2);
    this._constantSource.offset.setValueAtTime(val, time2);
  }
  getValueAtTime(time2) {
    const computedTime = new TransportTimeClass(this.context, time2).toSeconds();
    return super.getValueAtTime(computedTime);
  }
  setValueAtTime(value, time2) {
    const computedTime = new TransportTimeClass(this.context, time2).toSeconds();
    super.setValueAtTime(value, computedTime);
    return this;
  }
  linearRampToValueAtTime(value, time2) {
    const computedTime = new TransportTimeClass(this.context, time2).toSeconds();
    super.linearRampToValueAtTime(value, computedTime);
    return this;
  }
  exponentialRampToValueAtTime(value, time2) {
    const computedTime = new TransportTimeClass(this.context, time2).toSeconds();
    super.exponentialRampToValueAtTime(value, computedTime);
    return this;
  }
  setTargetAtTime(value, startTime, timeConstant) {
    const computedTime = new TransportTimeClass(this.context, startTime).toSeconds();
    super.setTargetAtTime(value, computedTime, timeConstant);
    return this;
  }
  cancelScheduledValues(startTime) {
    const computedTime = new TransportTimeClass(this.context, startTime).toSeconds();
    super.cancelScheduledValues(computedTime);
    return this;
  }
  setValueCurveAtTime(values, startTime, duration, scaling) {
    const computedTime = new TransportTimeClass(this.context, startTime).toSeconds();
    duration = this.toSeconds(duration);
    super.setValueCurveAtTime(values, computedTime, duration, scaling);
    return this;
  }
  cancelAndHoldAtTime(time2) {
    const computedTime = new TransportTimeClass(this.context, time2).toSeconds();
    super.cancelAndHoldAtTime(computedTime);
    return this;
  }
  setRampPoint(time2) {
    const computedTime = new TransportTimeClass(this.context, time2).toSeconds();
    super.setRampPoint(computedTime);
    return this;
  }
  exponentialRampTo(value, rampTime, startTime) {
    const computedTime = new TransportTimeClass(this.context, startTime).toSeconds();
    super.exponentialRampTo(value, rampTime, computedTime);
    return this;
  }
  linearRampTo(value, rampTime, startTime) {
    const computedTime = new TransportTimeClass(this.context, startTime).toSeconds();
    super.linearRampTo(value, rampTime, computedTime);
    return this;
  }
  targetRampTo(value, rampTime, startTime) {
    const computedTime = new TransportTimeClass(this.context, startTime).toSeconds();
    super.targetRampTo(value, rampTime, computedTime);
    return this;
  }
  dispose() {
    super.dispose();
    this.context.transport.clear(this._synced);
    this.context.transport.off("start", this._syncedCallback);
    this.context.transport.off("pause", this._syncedCallback);
    this.context.transport.off("stop", this._syncedCallback);
    this._constantSource.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/component/envelope/Envelope.js
var Envelope = class _Envelope extends ToneAudioNode {
  constructor() {
    super(optionsFromArguments(_Envelope.getDefaults(), arguments, ["attack", "decay", "sustain", "release"]));
    this.name = "Envelope";
    this._sig = new Signal({
      context: this.context,
      value: 0
    });
    this.output = this._sig;
    this.input = void 0;
    const options = optionsFromArguments(_Envelope.getDefaults(), arguments, ["attack", "decay", "sustain", "release"]);
    this.attack = options.attack;
    this.decay = options.decay;
    this.sustain = options.sustain;
    this.release = options.release;
    this.attackCurve = options.attackCurve;
    this.releaseCurve = options.releaseCurve;
    this.decayCurve = options.decayCurve;
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      attack: 0.01,
      attackCurve: "linear",
      decay: 0.1,
      decayCurve: "exponential",
      release: 1,
      releaseCurve: "exponential",
      sustain: 0.5
    });
  }
  /**
   * Read the current value of the envelope. Useful for
   * synchronizing visual output to the envelope.
   */
  get value() {
    return this.getValueAtTime(this.now());
  }
  /**
   * Get the curve
   * @param  curve
   * @param  direction  In/Out
   * @return The curve name
   */
  _getCurve(curve, direction) {
    if (isString(curve)) {
      return curve;
    } else {
      let curveName;
      for (curveName in EnvelopeCurves) {
        if (EnvelopeCurves[curveName][direction] === curve) {
          return curveName;
        }
      }
      return curve;
    }
  }
  /**
   * Assign a the curve to the given name using the direction
   * @param  name
   * @param  direction In/Out
   * @param  curve
   */
  _setCurve(name, direction, curve) {
    if (isString(curve) && Reflect.has(EnvelopeCurves, curve)) {
      const curveDef = EnvelopeCurves[curve];
      if (isObject(curveDef)) {
        if (name !== "_decayCurve") {
          this[name] = curveDef[direction];
        }
      } else {
        this[name] = curveDef;
      }
    } else if (isArray(curve) && name !== "_decayCurve") {
      this[name] = curve;
    } else {
      throw new Error("Envelope: invalid curve: " + curve);
    }
  }
  /**
   * The shape of the attack.
   * Can be any of these strings:
   * * "linear"
   * * "exponential"
   * * "sine"
   * * "cosine"
   * * "bounce"
   * * "ripple"
   * * "step"
   *
   * Can also be an array which describes the curve. Values
   * in the array are evenly subdivided and linearly
   * interpolated over the duration of the attack.
   * @example
   * return Tone.Offline(() => {
   * 	const env = new Tone.Envelope(0.4).toDestination();
   * 	env.attackCurve = "linear";
   * 	env.triggerAttack();
   * }, 1, 1);
   */
  get attackCurve() {
    return this._getCurve(this._attackCurve, "In");
  }
  set attackCurve(curve) {
    this._setCurve("_attackCurve", "In", curve);
  }
  /**
   * The shape of the release. See the attack curve types.
   * @example
   * return Tone.Offline(() => {
   * 	const env = new Tone.Envelope({
   * 		release: 0.8
   * 	}).toDestination();
   * 	env.triggerAttack();
   * 	// release curve could also be defined by an array
   * 	env.releaseCurve = [1, 0.3, 0.4, 0.2, 0.7, 0];
   * 	env.triggerRelease(0.2);
   * }, 1, 1);
   */
  get releaseCurve() {
    return this._getCurve(this._releaseCurve, "Out");
  }
  set releaseCurve(curve) {
    this._setCurve("_releaseCurve", "Out", curve);
  }
  /**
   * The shape of the decay either "linear" or "exponential"
   * @example
   * return Tone.Offline(() => {
   * 	const env = new Tone.Envelope({
   * 		sustain: 0.1,
   * 		decay: 0.5
   * 	}).toDestination();
   * 	env.decayCurve = "linear";
   * 	env.triggerAttack();
   * }, 1, 1);
   */
  get decayCurve() {
    return this._getCurve(this._decayCurve, "Out");
  }
  set decayCurve(curve) {
    this._setCurve("_decayCurve", "Out", curve);
  }
  /**
   * Trigger the attack/decay portion of the ADSR envelope.
   * @param  time When the attack should start.
   * @param velocity The velocity of the envelope scales the vales.
   *                             number between 0-1
   * @example
   * const env = new Tone.AmplitudeEnvelope().toDestination();
   * const osc = new Tone.Oscillator().connect(env).start();
   * // trigger the attack 0.5 seconds from now with a velocity of 0.2
   * env.triggerAttack("+0.5", 0.2);
   */
  triggerAttack(time2, velocity = 1) {
    this.log("triggerAttack", time2, velocity);
    time2 = this.toSeconds(time2);
    const originalAttack = this.toSeconds(this.attack);
    let attack = originalAttack;
    const decay = this.toSeconds(this.decay);
    const currentValue = this.getValueAtTime(time2);
    if (currentValue > 0) {
      const attackRate = 1 / attack;
      const remainingDistance = 1 - currentValue;
      attack = remainingDistance / attackRate;
    }
    if (attack < this.sampleTime) {
      this._sig.cancelScheduledValues(time2);
      this._sig.setValueAtTime(velocity, time2);
    } else if (this._attackCurve === "linear") {
      this._sig.linearRampTo(velocity, attack, time2);
    } else if (this._attackCurve === "exponential") {
      this._sig.targetRampTo(velocity, attack, time2);
    } else {
      this._sig.cancelAndHoldAtTime(time2);
      let curve = this._attackCurve;
      for (let i = 1; i < curve.length; i++) {
        if (curve[i - 1] <= currentValue && currentValue <= curve[i]) {
          curve = this._attackCurve.slice(i);
          curve[0] = currentValue;
          break;
        }
      }
      this._sig.setValueCurveAtTime(curve, time2, attack, velocity);
    }
    if (decay && this.sustain < 1) {
      const decayValue = velocity * this.sustain;
      const decayStart = time2 + attack;
      this.log("decay", decayStart);
      if (this._decayCurve === "linear") {
        this._sig.linearRampToValueAtTime(decayValue, decay + decayStart);
      } else {
        this._sig.exponentialApproachValueAtTime(decayValue, decayStart, decay);
      }
    }
    return this;
  }
  /**
   * Triggers the release of the envelope.
   * @param  time When the release portion of the envelope should start.
   * @example
   * const env = new Tone.AmplitudeEnvelope().toDestination();
   * const osc = new Tone.Oscillator({
   * 	type: "sawtooth"
   * }).connect(env).start();
   * env.triggerAttack();
   * // trigger the release half a second after the attack
   * env.triggerRelease("+0.5");
   */
  triggerRelease(time2) {
    this.log("triggerRelease", time2);
    time2 = this.toSeconds(time2);
    const currentValue = this.getValueAtTime(time2);
    if (currentValue > 0) {
      const release = this.toSeconds(this.release);
      if (release < this.sampleTime) {
        this._sig.setValueAtTime(0, time2);
      } else if (this._releaseCurve === "linear") {
        this._sig.linearRampTo(0, release, time2);
      } else if (this._releaseCurve === "exponential") {
        this._sig.targetRampTo(0, release, time2);
      } else {
        assert(isArray(this._releaseCurve), "releaseCurve must be either 'linear', 'exponential' or an array");
        this._sig.cancelAndHoldAtTime(time2);
        this._sig.setValueCurveAtTime(this._releaseCurve, time2, release, currentValue);
      }
    }
    return this;
  }
  /**
   * Get the scheduled value at the given time. This will
   * return the unconverted (raw) value.
   * @example
   * const env = new Tone.Envelope(0.5, 1, 0.4, 2);
   * env.triggerAttackRelease(2);
   * setInterval(() => console.log(env.getValueAtTime(Tone.now())), 100);
   */
  getValueAtTime(time2) {
    return this._sig.getValueAtTime(time2);
  }
  /**
   * triggerAttackRelease is shorthand for triggerAttack, then waiting
   * some duration, then triggerRelease.
   * @param duration The duration of the sustain.
   * @param time When the attack should be triggered.
   * @param velocity The velocity of the envelope.
   * @example
   * const env = new Tone.AmplitudeEnvelope().toDestination();
   * const osc = new Tone.Oscillator().connect(env).start();
   * // trigger the release 0.5 seconds after the attack
   * env.triggerAttackRelease(0.5);
   */
  triggerAttackRelease(duration, time2, velocity = 1) {
    time2 = this.toSeconds(time2);
    this.triggerAttack(time2, velocity);
    this.triggerRelease(time2 + this.toSeconds(duration));
    return this;
  }
  /**
   * Cancels all scheduled envelope changes after the given time.
   */
  cancel(after) {
    this._sig.cancelScheduledValues(this.toSeconds(after));
    return this;
  }
  /**
   * Connect the envelope to a destination node.
   */
  connect(destination, outputNumber = 0, inputNumber = 0) {
    connectSignal(this, destination, outputNumber, inputNumber);
    return this;
  }
  /**
   * Render the envelope curve to an array of the given length.
   * Good for visualizing the envelope curve. Rescales the duration of the
   * envelope to fit the length.
   */
  asArray(length = 1024) {
    return __awaiter(this, void 0, void 0, function* () {
      const duration = length / this.context.sampleRate;
      const context2 = new OfflineContext(1, duration, this.context.sampleRate);
      const attackPortion = this.toSeconds(this.attack) + this.toSeconds(this.decay);
      const envelopeDuration = attackPortion + this.toSeconds(this.release);
      const sustainTime = envelopeDuration * 0.1;
      const totalDuration = envelopeDuration + sustainTime;
      const clone2 = new this.constructor(Object.assign(this.get(), {
        attack: duration * this.toSeconds(this.attack) / totalDuration,
        decay: duration * this.toSeconds(this.decay) / totalDuration,
        release: duration * this.toSeconds(this.release) / totalDuration,
        context: context2
      }));
      clone2._sig.toDestination();
      clone2.triggerAttackRelease(duration * (attackPortion + sustainTime) / totalDuration, 0);
      const buffer2 = yield context2.render();
      return buffer2.getChannelData(0);
    });
  }
  dispose() {
    super.dispose();
    this._sig.dispose();
    return this;
  }
};
__decorate([
  timeRange(0)
], Envelope.prototype, "attack", void 0);
__decorate([
  timeRange(0)
], Envelope.prototype, "decay", void 0);
__decorate([
  range(0, 1)
], Envelope.prototype, "sustain", void 0);
__decorate([
  timeRange(0)
], Envelope.prototype, "release", void 0);
var EnvelopeCurves = (() => {
  const curveLen = 128;
  let i;
  let k;
  const cosineCurve = [];
  for (i = 0; i < curveLen; i++) {
    cosineCurve[i] = Math.sin(i / (curveLen - 1) * (Math.PI / 2));
  }
  const rippleCurve = [];
  const rippleCurveFreq = 6.4;
  for (i = 0; i < curveLen - 1; i++) {
    k = i / (curveLen - 1);
    const sineWave = Math.sin(k * (Math.PI * 2) * rippleCurveFreq - Math.PI / 2) + 1;
    rippleCurve[i] = sineWave / 10 + k * 0.83;
  }
  rippleCurve[curveLen - 1] = 1;
  const stairsCurve = [];
  const steps = 5;
  for (i = 0; i < curveLen; i++) {
    stairsCurve[i] = Math.ceil(i / (curveLen - 1) * steps) / steps;
  }
  const sineCurve = [];
  for (i = 0; i < curveLen; i++) {
    k = i / (curveLen - 1);
    sineCurve[i] = 0.5 * (1 - Math.cos(Math.PI * k));
  }
  const bounceCurve = [];
  for (i = 0; i < curveLen; i++) {
    k = i / (curveLen - 1);
    const freq = Math.pow(k, 3) * 4 + 0.2;
    const val = Math.cos(freq * Math.PI * 2 * k);
    bounceCurve[i] = Math.abs(val * (1 - k));
  }
  function invertCurve(curve) {
    const out = new Array(curve.length);
    for (let j = 0; j < curve.length; j++) {
      out[j] = 1 - curve[j];
    }
    return out;
  }
  function reverseCurve(curve) {
    return curve.slice(0).reverse();
  }
  return {
    bounce: {
      In: invertCurve(bounceCurve),
      Out: bounceCurve
    },
    cosine: {
      In: cosineCurve,
      Out: reverseCurve(cosineCurve)
    },
    exponential: "exponential",
    linear: "linear",
    ripple: {
      In: rippleCurve,
      Out: invertCurve(rippleCurve)
    },
    sine: {
      In: sineCurve,
      Out: invertCurve(sineCurve)
    },
    step: {
      In: stairsCurve,
      Out: invertCurve(stairsCurve)
    }
  };
})();

// node_modules/@magenta/music/node_modules/tone/build/esm/instrument/Instrument.js
var Instrument = class _Instrument extends ToneAudioNode {
  constructor() {
    super(optionsFromArguments(_Instrument.getDefaults(), arguments));
    this._scheduledEvents = [];
    this._synced = false;
    this._original_triggerAttack = this.triggerAttack;
    this._original_triggerRelease = this.triggerRelease;
    this._syncedRelease = (time2) => this._original_triggerRelease(time2);
    const options = optionsFromArguments(_Instrument.getDefaults(), arguments);
    this._volume = this.output = new Volume({
      context: this.context,
      volume: options.volume
    });
    this.volume = this._volume.volume;
    readOnly(this, "volume");
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      volume: 0
    });
  }
  /**
   * Sync the instrument to the Transport. All subsequent calls of
   * {@link triggerAttack} and {@link triggerRelease} will be scheduled along the transport.
   * @example
   * const fmSynth = new Tone.FMSynth().toDestination();
   * fmSynth.volume.value = -6;
   * fmSynth.sync();
   * // schedule 3 notes when the transport first starts
   * fmSynth.triggerAttackRelease("C4", "8n", 0);
   * fmSynth.triggerAttackRelease("E4", "8n", "8n");
   * fmSynth.triggerAttackRelease("G4", "8n", "4n");
   * // start the transport to hear the notes
   * Tone.Transport.start();
   */
  sync() {
    if (this._syncState()) {
      this._syncMethod("triggerAttack", 1);
      this._syncMethod("triggerRelease", 0);
      this.context.transport.on("stop", this._syncedRelease);
      this.context.transport.on("pause", this._syncedRelease);
      this.context.transport.on("loopEnd", this._syncedRelease);
    }
    return this;
  }
  /**
   * set _sync
   */
  _syncState() {
    let changed = false;
    if (!this._synced) {
      this._synced = true;
      changed = true;
    }
    return changed;
  }
  /**
   * Wrap the given method so that it can be synchronized
   * @param method Which method to wrap and sync
   * @param  timePosition What position the time argument appears in
   */
  _syncMethod(method, timePosition) {
    const originalMethod = this["_original_" + method] = this[method];
    this[method] = (...args) => {
      const time2 = args[timePosition];
      const id = this.context.transport.schedule((t) => {
        args[timePosition] = t;
        originalMethod.apply(this, args);
      }, time2);
      this._scheduledEvents.push(id);
    };
  }
  /**
   * Unsync the instrument from the Transport
   */
  unsync() {
    this._scheduledEvents.forEach((id) => this.context.transport.clear(id));
    this._scheduledEvents = [];
    if (this._synced) {
      this._synced = false;
      this.triggerAttack = this._original_triggerAttack;
      this.triggerRelease = this._original_triggerRelease;
      this.context.transport.off("stop", this._syncedRelease);
      this.context.transport.off("pause", this._syncedRelease);
      this.context.transport.off("loopEnd", this._syncedRelease);
    }
    return this;
  }
  /**
   * Trigger the attack and then the release after the duration.
   * @param  note     The note to trigger.
   * @param  duration How long the note should be held for before
   *                         triggering the release. This value must be greater than 0.
   * @param time  When the note should be triggered.
   * @param  velocity The velocity the note should be triggered at.
   * @example
   * const synth = new Tone.Synth().toDestination();
   * // trigger "C4" for the duration of an 8th note
   * synth.triggerAttackRelease("C4", "8n");
   */
  triggerAttackRelease(note, duration, time2, velocity) {
    const computedTime = this.toSeconds(time2);
    const computedDuration = this.toSeconds(duration);
    this.triggerAttack(note, computedTime, velocity);
    this.triggerRelease(computedTime + computedDuration);
    return this;
  }
  /**
   * clean up
   * @returns {Instrument} this
   */
  dispose() {
    super.dispose();
    this._volume.dispose();
    this.unsync();
    this._scheduledEvents = [];
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/instrument/Monophonic.js
var Monophonic = class _Monophonic extends Instrument {
  constructor() {
    super(optionsFromArguments(_Monophonic.getDefaults(), arguments));
    const options = optionsFromArguments(_Monophonic.getDefaults(), arguments);
    this.portamento = options.portamento;
    this.onsilence = options.onsilence;
  }
  static getDefaults() {
    return Object.assign(Instrument.getDefaults(), {
      detune: 0,
      onsilence: noOp,
      portamento: 0
    });
  }
  /**
   * Trigger the attack of the note optionally with a given velocity.
   * @param  note The note to trigger.
   * @param  time When the note should start.
   * @param  velocity The velocity determines how "loud" the note will be.
   * @example
   * const synth = new Tone.Synth().toDestination();
   * // trigger the note a half second from now at half velocity
   * synth.triggerAttack("C4", "+0.5", 0.5);
   */
  triggerAttack(note, time2, velocity = 1) {
    this.log("triggerAttack", note, time2, velocity);
    const seconds = this.toSeconds(time2);
    this._triggerEnvelopeAttack(seconds, velocity);
    this.setNote(note, seconds);
    return this;
  }
  /**
   * Trigger the release portion of the envelope.
   * @param  time If no time is given, the release happens immediately.
   * @example
   * const synth = new Tone.Synth().toDestination();
   * synth.triggerAttack("C4");
   * // trigger the release a second from now
   * synth.triggerRelease("+1");
   */
  triggerRelease(time2) {
    this.log("triggerRelease", time2);
    const seconds = this.toSeconds(time2);
    this._triggerEnvelopeRelease(seconds);
    return this;
  }
  /**
   * Set the note at the given time. If no time is given, the note
   * will set immediately.
   * @param note The note to change to.
   * @param  time The time when the note should be set.
   * @example
   * const synth = new Tone.Synth().toDestination();
   * synth.triggerAttack("C4");
   * // change to F#6 in one quarter note from now.
   * synth.setNote("F#6", "+4n");
   */
  setNote(note, time2) {
    const computedTime = this.toSeconds(time2);
    const computedFrequency = note instanceof FrequencyClass ? note.toFrequency() : note;
    if (this.portamento > 0 && this.getLevelAtTime(computedTime) > 0.05) {
      const portTime = this.toSeconds(this.portamento);
      this.frequency.exponentialRampTo(computedFrequency, portTime, computedTime);
    } else {
      this.frequency.setValueAtTime(computedFrequency, computedTime);
    }
    return this;
  }
};
__decorate([
  timeRange(0)
], Monophonic.prototype, "portamento", void 0);

// node_modules/@magenta/music/node_modules/tone/build/esm/component/envelope/AmplitudeEnvelope.js
var AmplitudeEnvelope = class _AmplitudeEnvelope extends Envelope {
  constructor() {
    super(optionsFromArguments(_AmplitudeEnvelope.getDefaults(), arguments, ["attack", "decay", "sustain", "release"]));
    this.name = "AmplitudeEnvelope";
    this._gainNode = new Gain({
      context: this.context,
      gain: 0
    });
    this.output = this._gainNode;
    this.input = this._gainNode;
    this._sig.connect(this._gainNode.gain);
    this.output = this._gainNode;
    this.input = this._gainNode;
  }
  /**
   * Clean up
   */
  dispose() {
    super.dispose();
    this._gainNode.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/instrument/Synth.js
var Synth = class _Synth extends Monophonic {
  constructor() {
    super(optionsFromArguments(_Synth.getDefaults(), arguments));
    this.name = "Synth";
    const options = optionsFromArguments(_Synth.getDefaults(), arguments);
    this.oscillator = new OmniOscillator(Object.assign({
      context: this.context,
      detune: options.detune,
      onstop: () => this.onsilence(this)
    }, options.oscillator));
    this.frequency = this.oscillator.frequency;
    this.detune = this.oscillator.detune;
    this.envelope = new AmplitudeEnvelope(Object.assign({
      context: this.context
    }, options.envelope));
    this.oscillator.chain(this.envelope, this.output);
    readOnly(this, ["oscillator", "frequency", "detune", "envelope"]);
  }
  static getDefaults() {
    return Object.assign(Monophonic.getDefaults(), {
      envelope: Object.assign(omitFromObject(Envelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())), {
        attack: 5e-3,
        decay: 0.1,
        release: 1,
        sustain: 0.3
      }),
      oscillator: Object.assign(omitFromObject(OmniOscillator.getDefaults(), [...Object.keys(Source.getDefaults()), "frequency", "detune"]), {
        type: "triangle"
      })
    });
  }
  /**
   * start the attack portion of the envelope
   * @param time the time the attack should start
   * @param velocity the velocity of the note (0-1)
   */
  _triggerEnvelopeAttack(time2, velocity) {
    this.envelope.triggerAttack(time2, velocity);
    this.oscillator.start(time2);
    if (this.envelope.sustain === 0) {
      const computedAttack = this.toSeconds(this.envelope.attack);
      const computedDecay = this.toSeconds(this.envelope.decay);
      this.oscillator.stop(time2 + computedAttack + computedDecay);
    }
  }
  /**
   * start the release portion of the envelope
   * @param time the time the release should start
   */
  _triggerEnvelopeRelease(time2) {
    this.envelope.triggerRelease(time2);
    this.oscillator.stop(time2 + this.toSeconds(this.envelope.release));
  }
  getLevelAtTime(time2) {
    time2 = this.toSeconds(time2);
    return this.envelope.getValueAtTime(time2);
  }
  /**
   * clean up
   */
  dispose() {
    super.dispose();
    this.oscillator.dispose();
    this.envelope.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/instrument/ModulationSynth.js
var ModulationSynth = class _ModulationSynth extends Monophonic {
  constructor() {
    super(optionsFromArguments(_ModulationSynth.getDefaults(), arguments));
    this.name = "ModulationSynth";
    const options = optionsFromArguments(_ModulationSynth.getDefaults(), arguments);
    this._carrier = new Synth({
      context: this.context,
      oscillator: options.oscillator,
      envelope: options.envelope,
      onsilence: () => this.onsilence(this),
      volume: -10
    });
    this._modulator = new Synth({
      context: this.context,
      oscillator: options.modulation,
      envelope: options.modulationEnvelope,
      volume: -10
    });
    this.oscillator = this._carrier.oscillator;
    this.envelope = this._carrier.envelope;
    this.modulation = this._modulator.oscillator;
    this.modulationEnvelope = this._modulator.envelope;
    this.frequency = new Signal({
      context: this.context,
      units: "frequency"
    });
    this.detune = new Signal({
      context: this.context,
      value: options.detune,
      units: "cents"
    });
    this.harmonicity = new Multiply({
      context: this.context,
      value: options.harmonicity,
      minValue: 0
    });
    this._modulationNode = new Gain({
      context: this.context,
      gain: 0
    });
    readOnly(this, ["frequency", "harmonicity", "oscillator", "envelope", "modulation", "modulationEnvelope", "detune"]);
  }
  static getDefaults() {
    return Object.assign(Monophonic.getDefaults(), {
      harmonicity: 3,
      oscillator: Object.assign(omitFromObject(OmniOscillator.getDefaults(), [
        ...Object.keys(Source.getDefaults()),
        "frequency",
        "detune"
      ]), {
        type: "sine"
      }),
      envelope: Object.assign(omitFromObject(Envelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())), {
        attack: 0.01,
        decay: 0.01,
        sustain: 1,
        release: 0.5
      }),
      modulation: Object.assign(omitFromObject(OmniOscillator.getDefaults(), [
        ...Object.keys(Source.getDefaults()),
        "frequency",
        "detune"
      ]), {
        type: "square"
      }),
      modulationEnvelope: Object.assign(omitFromObject(Envelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())), {
        attack: 0.5,
        decay: 0,
        sustain: 1,
        release: 0.5
      })
    });
  }
  /**
   * Trigger the attack portion of the note
   */
  _triggerEnvelopeAttack(time2, velocity) {
    this._carrier._triggerEnvelopeAttack(time2, velocity);
    this._modulator._triggerEnvelopeAttack(time2, velocity);
  }
  /**
   * Trigger the release portion of the note
   */
  _triggerEnvelopeRelease(time2) {
    this._carrier._triggerEnvelopeRelease(time2);
    this._modulator._triggerEnvelopeRelease(time2);
    return this;
  }
  getLevelAtTime(time2) {
    time2 = this.toSeconds(time2);
    return this.envelope.getValueAtTime(time2);
  }
  dispose() {
    super.dispose();
    this._carrier.dispose();
    this._modulator.dispose();
    this.frequency.dispose();
    this.detune.dispose();
    this.harmonicity.dispose();
    this._modulationNode.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/instrument/AMSynth.js
var AMSynth = class _AMSynth extends ModulationSynth {
  constructor() {
    super(optionsFromArguments(_AMSynth.getDefaults(), arguments));
    this.name = "AMSynth";
    this._modulationScale = new AudioToGain({
      context: this.context
    });
    this.frequency.connect(this._carrier.frequency);
    this.frequency.chain(this.harmonicity, this._modulator.frequency);
    this.detune.fan(this._carrier.detune, this._modulator.detune);
    this._modulator.chain(this._modulationScale, this._modulationNode.gain);
    this._carrier.chain(this._modulationNode, this.output);
  }
  dispose() {
    super.dispose();
    this._modulationScale.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/component/filter/BiquadFilter.js
var BiquadFilter = class _BiquadFilter extends ToneAudioNode {
  constructor() {
    super(optionsFromArguments(_BiquadFilter.getDefaults(), arguments, ["frequency", "type"]));
    this.name = "BiquadFilter";
    const options = optionsFromArguments(_BiquadFilter.getDefaults(), arguments, ["frequency", "type"]);
    this._filter = this.context.createBiquadFilter();
    this.input = this.output = this._filter;
    this.Q = new Param({
      context: this.context,
      units: "number",
      value: options.Q,
      param: this._filter.Q
    });
    this.frequency = new Param({
      context: this.context,
      units: "frequency",
      value: options.frequency,
      param: this._filter.frequency
    });
    this.detune = new Param({
      context: this.context,
      units: "cents",
      value: options.detune,
      param: this._filter.detune
    });
    this.gain = new Param({
      context: this.context,
      units: "decibels",
      convert: false,
      value: options.gain,
      param: this._filter.gain
    });
    this.type = options.type;
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      Q: 1,
      type: "lowpass",
      frequency: 350,
      detune: 0,
      gain: 0
    });
  }
  /**
   * The type of this BiquadFilterNode. For a complete list of types and their attributes, see the
   * [Web Audio API](https://webaudio.github.io/web-audio-api/#dom-biquadfiltertype-lowpass)
   */
  get type() {
    return this._filter.type;
  }
  set type(type) {
    const types = [
      "lowpass",
      "highpass",
      "bandpass",
      "lowshelf",
      "highshelf",
      "notch",
      "allpass",
      "peaking"
    ];
    assert(types.indexOf(type) !== -1, `Invalid filter type: ${type}`);
    this._filter.type = type;
  }
  /**
   * Get the frequency response curve. This curve represents how the filter
   * responses to frequencies between 20hz-20khz.
   * @param  len The number of values to return
   * @return The frequency response curve between 20-20kHz
   */
  getFrequencyResponse(len = 128) {
    const freqValues = new Float32Array(len);
    for (let i = 0; i < len; i++) {
      const norm = Math.pow(i / len, 2);
      const freq = norm * (2e4 - 20) + 20;
      freqValues[i] = freq;
    }
    const magValues = new Float32Array(len);
    const phaseValues = new Float32Array(len);
    const filterClone = this.context.createBiquadFilter();
    filterClone.type = this.type;
    filterClone.Q.value = this.Q.value;
    filterClone.frequency.value = this.frequency.value;
    filterClone.gain.value = this.gain.value;
    filterClone.getFrequencyResponse(freqValues, magValues, phaseValues);
    return magValues;
  }
  dispose() {
    super.dispose();
    this._filter.disconnect();
    this.Q.dispose();
    this.frequency.dispose();
    this.gain.dispose();
    this.detune.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/component/filter/Filter.js
var Filter = class _Filter extends ToneAudioNode {
  constructor() {
    super(optionsFromArguments(_Filter.getDefaults(), arguments, ["frequency", "type", "rolloff"]));
    this.name = "Filter";
    this.input = new Gain({ context: this.context });
    this.output = new Gain({ context: this.context });
    this._filters = [];
    const options = optionsFromArguments(_Filter.getDefaults(), arguments, ["frequency", "type", "rolloff"]);
    this._filters = [];
    this.Q = new Signal({
      context: this.context,
      units: "positive",
      value: options.Q
    });
    this.frequency = new Signal({
      context: this.context,
      units: "frequency",
      value: options.frequency
    });
    this.detune = new Signal({
      context: this.context,
      units: "cents",
      value: options.detune
    });
    this.gain = new Signal({
      context: this.context,
      units: "decibels",
      convert: false,
      value: options.gain
    });
    this._type = options.type;
    this.rolloff = options.rolloff;
    readOnly(this, ["detune", "frequency", "gain", "Q"]);
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      Q: 1,
      detune: 0,
      frequency: 350,
      gain: 0,
      rolloff: -12,
      type: "lowpass"
    });
  }
  /**
   * The type of the filter. Types: "lowpass", "highpass",
   * "bandpass", "lowshelf", "highshelf", "notch", "allpass", or "peaking".
   */
  get type() {
    return this._type;
  }
  set type(type) {
    const types = [
      "lowpass",
      "highpass",
      "bandpass",
      "lowshelf",
      "highshelf",
      "notch",
      "allpass",
      "peaking"
    ];
    assert(types.indexOf(type) !== -1, `Invalid filter type: ${type}`);
    this._type = type;
    this._filters.forEach((filter) => filter.type = type);
  }
  /**
   * The rolloff of the filter which is the drop in db
   * per octave. Implemented internally by cascading filters.
   * Only accepts the values -12, -24, -48 and -96.
   */
  get rolloff() {
    return this._rolloff;
  }
  set rolloff(rolloff) {
    const rolloffNum = isNumber(rolloff) ? rolloff : parseInt(rolloff, 10);
    const possibilities = [-12, -24, -48, -96];
    let cascadingCount = possibilities.indexOf(rolloffNum);
    assert(cascadingCount !== -1, `rolloff can only be ${possibilities.join(", ")}`);
    cascadingCount += 1;
    this._rolloff = rolloffNum;
    this.input.disconnect();
    this._filters.forEach((filter) => filter.disconnect());
    this._filters = new Array(cascadingCount);
    for (let count = 0; count < cascadingCount; count++) {
      const filter = new BiquadFilter({
        context: this.context
      });
      filter.type = this._type;
      this.frequency.connect(filter.frequency);
      this.detune.connect(filter.detune);
      this.Q.connect(filter.Q);
      this.gain.connect(filter.gain);
      this._filters[count] = filter;
    }
    this._internalChannels = this._filters;
    connectSeries(this.input, ...this._internalChannels, this.output);
  }
  /**
   * Get the frequency response curve. This curve represents how the filter
   * responses to frequencies between 20hz-20khz.
   * @param  len The number of values to return
   * @return The frequency response curve between 20-20kHz
   */
  getFrequencyResponse(len = 128) {
    const filterClone = new BiquadFilter({
      frequency: this.frequency.value,
      gain: this.gain.value,
      Q: this.Q.value,
      type: this._type,
      detune: this.detune.value
    });
    const totalResponse = new Float32Array(len).map(() => 1);
    this._filters.forEach(() => {
      const response = filterClone.getFrequencyResponse(len);
      response.forEach((val, i) => totalResponse[i] *= val);
    });
    filterClone.dispose();
    return totalResponse;
  }
  /**
   * Clean up.
   */
  dispose() {
    super.dispose();
    this._filters.forEach((filter) => {
      filter.dispose();
    });
    writable(this, ["detune", "frequency", "gain", "Q"]);
    this.frequency.dispose();
    this.Q.dispose();
    this.detune.dispose();
    this.gain.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/component/envelope/FrequencyEnvelope.js
var FrequencyEnvelope = class _FrequencyEnvelope extends Envelope {
  constructor() {
    super(optionsFromArguments(_FrequencyEnvelope.getDefaults(), arguments, ["attack", "decay", "sustain", "release"]));
    this.name = "FrequencyEnvelope";
    const options = optionsFromArguments(_FrequencyEnvelope.getDefaults(), arguments, ["attack", "decay", "sustain", "release"]);
    this._octaves = options.octaves;
    this._baseFrequency = this.toFrequency(options.baseFrequency);
    this._exponent = this.input = new Pow({
      context: this.context,
      value: options.exponent
    });
    this._scale = this.output = new Scale({
      context: this.context,
      min: this._baseFrequency,
      max: this._baseFrequency * Math.pow(2, this._octaves)
    });
    this._sig.chain(this._exponent, this._scale);
  }
  static getDefaults() {
    return Object.assign(Envelope.getDefaults(), {
      baseFrequency: 200,
      exponent: 1,
      octaves: 4
    });
  }
  /**
   * The envelope's minimum output value. This is the value which it
   * starts at.
   */
  get baseFrequency() {
    return this._baseFrequency;
  }
  set baseFrequency(min2) {
    const freq = this.toFrequency(min2);
    assertRange(freq, 0);
    this._baseFrequency = freq;
    this._scale.min = this._baseFrequency;
    this.octaves = this._octaves;
  }
  /**
   * The number of octaves above the baseFrequency that the
   * envelope will scale to.
   */
  get octaves() {
    return this._octaves;
  }
  set octaves(octaves) {
    this._octaves = octaves;
    this._scale.max = this._baseFrequency * Math.pow(2, octaves);
  }
  /**
   * The envelope's exponent value.
   */
  get exponent() {
    return this._exponent.value;
  }
  set exponent(exponent) {
    this._exponent.value = exponent;
  }
  /**
   * Clean up
   */
  dispose() {
    super.dispose();
    this._exponent.dispose();
    this._scale.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/instrument/MonoSynth.js
var MonoSynth = class _MonoSynth extends Monophonic {
  constructor() {
    super(optionsFromArguments(_MonoSynth.getDefaults(), arguments));
    this.name = "MonoSynth";
    const options = optionsFromArguments(_MonoSynth.getDefaults(), arguments);
    this.oscillator = new OmniOscillator(Object.assign(options.oscillator, {
      context: this.context,
      detune: options.detune,
      onstop: () => this.onsilence(this)
    }));
    this.frequency = this.oscillator.frequency;
    this.detune = this.oscillator.detune;
    this.filter = new Filter(Object.assign(options.filter, { context: this.context }));
    this.filterEnvelope = new FrequencyEnvelope(Object.assign(options.filterEnvelope, { context: this.context }));
    this.envelope = new AmplitudeEnvelope(Object.assign(options.envelope, { context: this.context }));
    this.oscillator.chain(this.filter, this.envelope, this.output);
    this.filterEnvelope.connect(this.filter.frequency);
    readOnly(this, ["oscillator", "frequency", "detune", "filter", "filterEnvelope", "envelope"]);
  }
  static getDefaults() {
    return Object.assign(Monophonic.getDefaults(), {
      envelope: Object.assign(omitFromObject(Envelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())), {
        attack: 5e-3,
        decay: 0.1,
        release: 1,
        sustain: 0.9
      }),
      filter: Object.assign(omitFromObject(Filter.getDefaults(), Object.keys(ToneAudioNode.getDefaults())), {
        Q: 1,
        rolloff: -12,
        type: "lowpass"
      }),
      filterEnvelope: Object.assign(omitFromObject(FrequencyEnvelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())), {
        attack: 0.6,
        baseFrequency: 200,
        decay: 0.2,
        exponent: 2,
        octaves: 3,
        release: 2,
        sustain: 0.5
      }),
      oscillator: Object.assign(omitFromObject(OmniOscillator.getDefaults(), Object.keys(Source.getDefaults())), {
        type: "sawtooth"
      })
    });
  }
  /**
   * start the attack portion of the envelope
   * @param time the time the attack should start
   * @param velocity the velocity of the note (0-1)
   */
  _triggerEnvelopeAttack(time2, velocity = 1) {
    this.envelope.triggerAttack(time2, velocity);
    this.filterEnvelope.triggerAttack(time2);
    this.oscillator.start(time2);
    if (this.envelope.sustain === 0) {
      const computedAttack = this.toSeconds(this.envelope.attack);
      const computedDecay = this.toSeconds(this.envelope.decay);
      this.oscillator.stop(time2 + computedAttack + computedDecay);
    }
  }
  /**
   * start the release portion of the envelope
   * @param time the time the release should start
   */
  _triggerEnvelopeRelease(time2) {
    this.envelope.triggerRelease(time2);
    this.filterEnvelope.triggerRelease(time2);
    this.oscillator.stop(time2 + this.toSeconds(this.envelope.release));
  }
  getLevelAtTime(time2) {
    time2 = this.toSeconds(time2);
    return this.envelope.getValueAtTime(time2);
  }
  dispose() {
    super.dispose();
    this.oscillator.dispose();
    this.envelope.dispose();
    this.filterEnvelope.dispose();
    this.filter.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/instrument/DuoSynth.js
var DuoSynth = class _DuoSynth extends Monophonic {
  constructor() {
    super(optionsFromArguments(_DuoSynth.getDefaults(), arguments));
    this.name = "DuoSynth";
    const options = optionsFromArguments(_DuoSynth.getDefaults(), arguments);
    this.voice0 = new MonoSynth(Object.assign(options.voice0, {
      context: this.context,
      onsilence: () => this.onsilence(this)
    }));
    this.voice1 = new MonoSynth(Object.assign(options.voice1, {
      context: this.context
    }));
    this.harmonicity = new Multiply({
      context: this.context,
      units: "positive",
      value: options.harmonicity
    });
    this._vibrato = new LFO({
      frequency: options.vibratoRate,
      context: this.context,
      min: -50,
      max: 50
    });
    this._vibrato.start();
    this.vibratoRate = this._vibrato.frequency;
    this._vibratoGain = new Gain({
      context: this.context,
      units: "normalRange",
      gain: options.vibratoAmount
    });
    this.vibratoAmount = this._vibratoGain.gain;
    this.frequency = new Signal({
      context: this.context,
      units: "frequency",
      value: 440
    });
    this.detune = new Signal({
      context: this.context,
      units: "cents",
      value: options.detune
    });
    this.frequency.connect(this.voice0.frequency);
    this.frequency.chain(this.harmonicity, this.voice1.frequency);
    this._vibrato.connect(this._vibratoGain);
    this._vibratoGain.fan(this.voice0.detune, this.voice1.detune);
    this.detune.fan(this.voice0.detune, this.voice1.detune);
    this.voice0.connect(this.output);
    this.voice1.connect(this.output);
    readOnly(this, ["voice0", "voice1", "frequency", "vibratoAmount", "vibratoRate"]);
  }
  getLevelAtTime(time2) {
    time2 = this.toSeconds(time2);
    return this.voice0.envelope.getValueAtTime(time2) + this.voice1.envelope.getValueAtTime(time2);
  }
  static getDefaults() {
    return deepMerge(Monophonic.getDefaults(), {
      vibratoAmount: 0.5,
      vibratoRate: 5,
      harmonicity: 1.5,
      voice0: deepMerge(omitFromObject(MonoSynth.getDefaults(), Object.keys(Monophonic.getDefaults())), {
        filterEnvelope: {
          attack: 0.01,
          decay: 0,
          sustain: 1,
          release: 0.5
        },
        envelope: {
          attack: 0.01,
          decay: 0,
          sustain: 1,
          release: 0.5
        }
      }),
      voice1: deepMerge(omitFromObject(MonoSynth.getDefaults(), Object.keys(Monophonic.getDefaults())), {
        filterEnvelope: {
          attack: 0.01,
          decay: 0,
          sustain: 1,
          release: 0.5
        },
        envelope: {
          attack: 0.01,
          decay: 0,
          sustain: 1,
          release: 0.5
        }
      })
    });
  }
  /**
   * Trigger the attack portion of the note
   */
  _triggerEnvelopeAttack(time2, velocity) {
    this.voice0._triggerEnvelopeAttack(time2, velocity);
    this.voice1._triggerEnvelopeAttack(time2, velocity);
  }
  /**
   * Trigger the release portion of the note
   */
  _triggerEnvelopeRelease(time2) {
    this.voice0._triggerEnvelopeRelease(time2);
    this.voice1._triggerEnvelopeRelease(time2);
    return this;
  }
  dispose() {
    super.dispose();
    this.voice0.dispose();
    this.voice1.dispose();
    this.frequency.dispose();
    this.detune.dispose();
    this._vibrato.dispose();
    this.vibratoRate.dispose();
    this._vibratoGain.dispose();
    this.harmonicity.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/instrument/FMSynth.js
var FMSynth = class _FMSynth extends ModulationSynth {
  constructor() {
    super(optionsFromArguments(_FMSynth.getDefaults(), arguments));
    this.name = "FMSynth";
    const options = optionsFromArguments(_FMSynth.getDefaults(), arguments);
    this.modulationIndex = new Multiply({
      context: this.context,
      value: options.modulationIndex
    });
    this.frequency.connect(this._carrier.frequency);
    this.frequency.chain(this.harmonicity, this._modulator.frequency);
    this.frequency.chain(this.modulationIndex, this._modulationNode);
    this.detune.fan(this._carrier.detune, this._modulator.detune);
    this._modulator.connect(this._modulationNode.gain);
    this._modulationNode.connect(this._carrier.frequency);
    this._carrier.connect(this.output);
  }
  static getDefaults() {
    return Object.assign(ModulationSynth.getDefaults(), {
      modulationIndex: 10
    });
  }
  dispose() {
    super.dispose();
    this.modulationIndex.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/instrument/MetalSynth.js
var inharmRatios = [1, 1.483, 1.932, 2.546, 2.63, 3.897];
var MetalSynth = class _MetalSynth extends Monophonic {
  constructor() {
    super(optionsFromArguments(_MetalSynth.getDefaults(), arguments));
    this.name = "MetalSynth";
    this._oscillators = [];
    this._freqMultipliers = [];
    const options = optionsFromArguments(_MetalSynth.getDefaults(), arguments);
    this.detune = new Signal({
      context: this.context,
      units: "cents",
      value: options.detune
    });
    this.frequency = new Signal({
      context: this.context,
      units: "frequency"
    });
    this._amplitude = new Gain({
      context: this.context,
      gain: 0
    }).connect(this.output);
    this._highpass = new Filter({
      // Q: -3.0102999566398125,
      Q: 0,
      context: this.context,
      type: "highpass"
    }).connect(this._amplitude);
    for (let i = 0; i < inharmRatios.length; i++) {
      const osc = new FMOscillator({
        context: this.context,
        harmonicity: options.harmonicity,
        modulationIndex: options.modulationIndex,
        modulationType: "square",
        onstop: i === 0 ? () => this.onsilence(this) : noOp,
        type: "square"
      });
      osc.connect(this._highpass);
      this._oscillators[i] = osc;
      const mult = new Multiply({
        context: this.context,
        value: inharmRatios[i]
      });
      this._freqMultipliers[i] = mult;
      this.frequency.chain(mult, osc.frequency);
      this.detune.connect(osc.detune);
    }
    this._filterFreqScaler = new Scale({
      context: this.context,
      max: 7e3,
      min: this.toFrequency(options.resonance)
    });
    this.envelope = new Envelope({
      attack: options.envelope.attack,
      attackCurve: "linear",
      context: this.context,
      decay: options.envelope.decay,
      release: options.envelope.release,
      sustain: 0
    });
    this.envelope.chain(this._filterFreqScaler, this._highpass.frequency);
    this.envelope.connect(this._amplitude.gain);
    this._octaves = options.octaves;
    this.octaves = options.octaves;
  }
  static getDefaults() {
    return deepMerge(Monophonic.getDefaults(), {
      envelope: Object.assign(omitFromObject(Envelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())), {
        attack: 1e-3,
        decay: 1.4,
        release: 0.2
      }),
      harmonicity: 5.1,
      modulationIndex: 32,
      octaves: 1.5,
      resonance: 4e3
    });
  }
  /**
   * Trigger the attack.
   * @param time When the attack should be triggered.
   * @param velocity The velocity that the envelope should be triggered at.
   */
  _triggerEnvelopeAttack(time2, velocity = 1) {
    this.envelope.triggerAttack(time2, velocity);
    this._oscillators.forEach((osc) => osc.start(time2));
    if (this.envelope.sustain === 0) {
      this._oscillators.forEach((osc) => {
        osc.stop(time2 + this.toSeconds(this.envelope.attack) + this.toSeconds(this.envelope.decay));
      });
    }
    return this;
  }
  /**
   * Trigger the release of the envelope.
   * @param time When the release should be triggered.
   */
  _triggerEnvelopeRelease(time2) {
    this.envelope.triggerRelease(time2);
    this._oscillators.forEach((osc) => osc.stop(time2 + this.toSeconds(this.envelope.release)));
    return this;
  }
  getLevelAtTime(time2) {
    time2 = this.toSeconds(time2);
    return this.envelope.getValueAtTime(time2);
  }
  /**
   * The modulationIndex of the oscillators which make up the source.
   * see {@link FMOscillator.modulationIndex}
   * @min 1
   * @max 100
   */
  get modulationIndex() {
    return this._oscillators[0].modulationIndex.value;
  }
  set modulationIndex(val) {
    this._oscillators.forEach((osc) => osc.modulationIndex.value = val);
  }
  /**
   * The harmonicity of the oscillators which make up the source.
   * see Tone.FMOscillator.harmonicity
   * @min 0.1
   * @max 10
   */
  get harmonicity() {
    return this._oscillators[0].harmonicity.value;
  }
  set harmonicity(val) {
    this._oscillators.forEach((osc) => osc.harmonicity.value = val);
  }
  /**
   * The lower level of the highpass filter which is attached to the envelope.
   * This value should be between [0, 7000]
   * @min 0
   * @max 7000
   */
  get resonance() {
    return this._filterFreqScaler.min;
  }
  set resonance(val) {
    this._filterFreqScaler.min = this.toFrequency(val);
    this.octaves = this._octaves;
  }
  /**
   * The number of octaves above the "resonance" frequency
   * that the filter ramps during the attack/decay envelope
   * @min 0
   * @max 8
   */
  get octaves() {
    return this._octaves;
  }
  set octaves(val) {
    this._octaves = val;
    this._filterFreqScaler.max = this._filterFreqScaler.min * Math.pow(2, val);
  }
  dispose() {
    super.dispose();
    this._oscillators.forEach((osc) => osc.dispose());
    this._freqMultipliers.forEach((freqMult) => freqMult.dispose());
    this.frequency.dispose();
    this.detune.dispose();
    this._filterFreqScaler.dispose();
    this._amplitude.dispose();
    this.envelope.dispose();
    this._highpass.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/instrument/MembraneSynth.js
var MembraneSynth = class _MembraneSynth extends Synth {
  constructor() {
    super(optionsFromArguments(_MembraneSynth.getDefaults(), arguments));
    this.name = "MembraneSynth";
    this.portamento = 0;
    const options = optionsFromArguments(_MembraneSynth.getDefaults(), arguments);
    this.pitchDecay = options.pitchDecay;
    this.octaves = options.octaves;
    readOnly(this, ["oscillator", "envelope"]);
  }
  static getDefaults() {
    return deepMerge(Monophonic.getDefaults(), Synth.getDefaults(), {
      envelope: {
        attack: 1e-3,
        attackCurve: "exponential",
        decay: 0.4,
        release: 1.4,
        sustain: 0.01
      },
      octaves: 10,
      oscillator: {
        type: "sine"
      },
      pitchDecay: 0.05
    });
  }
  setNote(note, time2) {
    const seconds = this.toSeconds(time2);
    const hertz = this.toFrequency(note instanceof FrequencyClass ? note.toFrequency() : note);
    const maxNote = hertz * this.octaves;
    this.oscillator.frequency.setValueAtTime(maxNote, seconds);
    this.oscillator.frequency.exponentialRampToValueAtTime(hertz, seconds + this.toSeconds(this.pitchDecay));
    return this;
  }
  dispose() {
    super.dispose();
    return this;
  }
};
__decorate([
  range(0)
], MembraneSynth.prototype, "octaves", void 0);
__decorate([
  timeRange(0)
], MembraneSynth.prototype, "pitchDecay", void 0);

// node_modules/@magenta/music/node_modules/tone/build/esm/instrument/NoiseSynth.js
var NoiseSynth = class _NoiseSynth extends Instrument {
  constructor() {
    super(optionsFromArguments(_NoiseSynth.getDefaults(), arguments));
    this.name = "NoiseSynth";
    const options = optionsFromArguments(_NoiseSynth.getDefaults(), arguments);
    this.noise = new Noise(Object.assign({
      context: this.context
    }, options.noise));
    this.envelope = new AmplitudeEnvelope(Object.assign({
      context: this.context
    }, options.envelope));
    this.noise.chain(this.envelope, this.output);
  }
  static getDefaults() {
    return Object.assign(Instrument.getDefaults(), {
      envelope: Object.assign(omitFromObject(Envelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())), {
        decay: 0.1,
        sustain: 0
      }),
      noise: Object.assign(omitFromObject(Noise.getDefaults(), Object.keys(Source.getDefaults())), {
        type: "white"
      })
    });
  }
  /**
   * Start the attack portion of the envelopes. Unlike other
   * instruments, Tone.NoiseSynth doesn't have a note.
   * @example
   * const noiseSynth = new Tone.NoiseSynth().toDestination();
   * noiseSynth.triggerAttack();
   */
  triggerAttack(time2, velocity = 1) {
    time2 = this.toSeconds(time2);
    this.envelope.triggerAttack(time2, velocity);
    this.noise.start(time2);
    if (this.envelope.sustain === 0) {
      this.noise.stop(time2 + this.toSeconds(this.envelope.attack) + this.toSeconds(this.envelope.decay));
    }
    return this;
  }
  /**
   * Start the release portion of the envelopes.
   */
  triggerRelease(time2) {
    time2 = this.toSeconds(time2);
    this.envelope.triggerRelease(time2);
    this.noise.stop(time2 + this.toSeconds(this.envelope.release));
    return this;
  }
  sync() {
    if (this._syncState()) {
      this._syncMethod("triggerAttack", 0);
      this._syncMethod("triggerRelease", 0);
    }
    return this;
  }
  /**
   * Trigger the attack and then the release after the duration.
   * @param duration The amount of time to hold the note for
   * @param time The time the note should start
   * @param velocity The volume of the note (0-1)
   * @example
   * const noiseSynth = new Tone.NoiseSynth().toDestination();
   * // hold the note for 0.5 seconds
   * noiseSynth.triggerAttackRelease(0.5);
   */
  triggerAttackRelease(duration, time2, velocity = 1) {
    time2 = this.toSeconds(time2);
    duration = this.toSeconds(duration);
    this.triggerAttack(time2, velocity);
    this.triggerRelease(time2 + duration);
    return this;
  }
  dispose() {
    super.dispose();
    this.noise.dispose();
    this.envelope.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/core/worklet/WorkletGlobalScope.js
var workletContext = /* @__PURE__ */ new Set();
function addToWorklet(classOrFunction) {
  workletContext.add(classOrFunction);
}
function registerProcessor(name, classDesc) {
  const processor = (
    /* javascript */
    `registerProcessor("${name}", ${classDesc})`
  );
  workletContext.add(processor);
}
function getWorkletGlobalScope() {
  return Array.from(workletContext).join("\n");
}

// node_modules/@magenta/music/node_modules/tone/build/esm/core/worklet/ToneAudioWorklet.js
var ToneAudioWorklet = class extends ToneAudioNode {
  constructor(options) {
    super(options);
    this.name = "ToneAudioWorklet";
    this.workletOptions = {};
    this.onprocessorerror = noOp;
    const blobUrl = URL.createObjectURL(new Blob([getWorkletGlobalScope()], { type: "text/javascript" }));
    const name = this._audioWorkletName();
    this._dummyGain = this.context.createGain();
    this._dummyParam = this._dummyGain.gain;
    this.context.addAudioWorkletModule(blobUrl).then(() => {
      if (!this.disposed) {
        this._worklet = this.context.createAudioWorkletNode(name, this.workletOptions);
        this._worklet.onprocessorerror = this.onprocessorerror.bind(this);
        this.onReady(this._worklet);
      }
    });
  }
  dispose() {
    super.dispose();
    this._dummyGain.disconnect();
    if (this._worklet) {
      this._worklet.port.postMessage("dispose");
      this._worklet.disconnect();
    }
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/core/worklet/ToneAudioWorkletProcessor.worklet.js
var toneAudioWorkletProcessor = (
  /* javascript */
  `
	/**
	 * The base AudioWorkletProcessor for use in Tone.js. Works with the {@link ToneAudioWorklet}. 
	 */
	class ToneAudioWorkletProcessor extends AudioWorkletProcessor {

		constructor(options) {
			
			super(options);
			/**
			 * If the processor was disposed or not. Keep alive until it's disposed.
			 */
			this.disposed = false;
		   	/** 
			 * The number of samples in the processing block
			 */
			this.blockSize = 128;
			/**
			 * the sample rate
			 */
			this.sampleRate = sampleRate;

			this.port.onmessage = (event) => {
				// when it receives a dispose 
				if (event.data === "dispose") {
					this.disposed = true;
				}
			};
		}
	}
`
);
addToWorklet(toneAudioWorkletProcessor);

// node_modules/@magenta/music/node_modules/tone/build/esm/core/worklet/SingleIOProcessor.worklet.js
var singleIOProcess = (
  /* javascript */
  `
	/**
	 * Abstract class for a single input/output processor. 
	 * has a 'generate' function which processes one sample at a time
	 */
	class SingleIOProcessor extends ToneAudioWorkletProcessor {

		constructor(options) {
			super(Object.assign(options, {
				numberOfInputs: 1,
				numberOfOutputs: 1
			}));
			/**
			 * Holds the name of the parameter and a single value of that
			 * parameter at the current sample
			 * @type { [name: string]: number }
			 */
			this.params = {}
		}

		/**
		 * Generate an output sample from the input sample and parameters
		 * @abstract
		 * @param input number
		 * @param channel number
		 * @param parameters { [name: string]: number }
		 * @returns number
		 */
		generate(){}

		/**
		 * Update the private params object with the 
		 * values of the parameters at the given index
		 * @param parameters { [name: string]: Float32Array },
		 * @param index number
		 */
		updateParams(parameters, index) {
			for (const paramName in parameters) {
				const param = parameters[paramName];
				if (param.length > 1) {
					this.params[paramName] = parameters[paramName][index];
				} else {
					this.params[paramName] = parameters[paramName][0];
				}
			}
		}

		/**
		 * Process a single frame of the audio
		 * @param inputs Float32Array[][]
		 * @param outputs Float32Array[][]
		 */
		process(inputs, outputs, parameters) {
			const input = inputs[0];
			const output = outputs[0];
			// get the parameter values
			const channelCount = Math.max(input && input.length || 0, output.length);
			for (let sample = 0; sample < this.blockSize; sample++) {
				this.updateParams(parameters, sample);
				for (let channel = 0; channel < channelCount; channel++) {
					const inputSample = input && input.length ? input[channel][sample] : 0;
					output[channel][sample] = this.generate(inputSample, channel, this.params);
				}
			}
			return !this.disposed;
		}
	};
`
);
addToWorklet(singleIOProcess);

// node_modules/@magenta/music/node_modules/tone/build/esm/core/worklet/DelayLine.worklet.js
var delayLine = (
  /* javascript */
  `
	/**
	 * A multichannel buffer for use within an AudioWorkletProcessor as a delay line
	 */
	class DelayLine {
		
		constructor(size, channels) {
			this.buffer = [];
			this.writeHead = []
			this.size = size;

			// create the empty channels
			for (let i = 0; i < channels; i++) {
				this.buffer[i] = new Float32Array(this.size);
				this.writeHead[i] = 0;
			}
		}

		/**
		 * Push a value onto the end
		 * @param channel number
		 * @param value number
		 */
		push(channel, value) {
			this.writeHead[channel] += 1;
			if (this.writeHead[channel] > this.size) {
				this.writeHead[channel] = 0;
			}
			this.buffer[channel][this.writeHead[channel]] = value;
		}

		/**
		 * Get the recorded value of the channel given the delay
		 * @param channel number
		 * @param delay number delay samples
		 */
		get(channel, delay) {
			let readHead = this.writeHead[channel] - Math.floor(delay);
			if (readHead < 0) {
				readHead += this.size;
			}
			return this.buffer[channel][readHead];
		}
	}
`
);
addToWorklet(delayLine);

// node_modules/@magenta/music/node_modules/tone/build/esm/component/filter/FeedbackCombFilter.worklet.js
var workletName = "feedback-comb-filter";
var feedbackCombFilter = (
  /* javascript */
  `
	class FeedbackCombFilterWorklet extends SingleIOProcessor {

		constructor(options) {
			super(options);
			this.delayLine = new DelayLine(this.sampleRate, options.channelCount || 2);
		}

		static get parameterDescriptors() {
			return [{
				name: "delayTime",
				defaultValue: 0.1,
				minValue: 0,
				maxValue: 1,
				automationRate: "k-rate"
			}, {
				name: "feedback",
				defaultValue: 0.5,
				minValue: 0,
				maxValue: 0.9999,
				automationRate: "k-rate"
			}];
		}

		generate(input, channel, parameters) {
			const delayedSample = this.delayLine.get(channel, parameters.delayTime * this.sampleRate);
			this.delayLine.push(channel, input + delayedSample * parameters.feedback);
			return delayedSample;
		}
	}
`
);
registerProcessor(workletName, feedbackCombFilter);

// node_modules/@magenta/music/node_modules/tone/build/esm/component/filter/FeedbackCombFilter.js
var FeedbackCombFilter = class _FeedbackCombFilter extends ToneAudioWorklet {
  constructor() {
    super(optionsFromArguments(_FeedbackCombFilter.getDefaults(), arguments, ["delayTime", "resonance"]));
    this.name = "FeedbackCombFilter";
    const options = optionsFromArguments(_FeedbackCombFilter.getDefaults(), arguments, ["delayTime", "resonance"]);
    this.input = new Gain({ context: this.context });
    this.output = new Gain({ context: this.context });
    this.delayTime = new Param({
      context: this.context,
      value: options.delayTime,
      units: "time",
      minValue: 0,
      maxValue: 1,
      param: this._dummyParam,
      swappable: true
    });
    this.resonance = new Param({
      context: this.context,
      value: options.resonance,
      units: "normalRange",
      param: this._dummyParam,
      swappable: true
    });
    readOnly(this, ["resonance", "delayTime"]);
  }
  _audioWorkletName() {
    return workletName;
  }
  /**
   * The default parameters
   */
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      delayTime: 0.1,
      resonance: 0.5
    });
  }
  onReady(node) {
    connectSeries(this.input, node, this.output);
    const delayTime = node.parameters.get("delayTime");
    this.delayTime.setParam(delayTime);
    const feedback = node.parameters.get("feedback");
    this.resonance.setParam(feedback);
  }
  dispose() {
    super.dispose();
    this.input.dispose();
    this.output.dispose();
    this.delayTime.dispose();
    this.resonance.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/component/filter/OnePoleFilter.js
var OnePoleFilter = class _OnePoleFilter extends ToneAudioNode {
  constructor() {
    super(optionsFromArguments(_OnePoleFilter.getDefaults(), arguments, ["frequency", "type"]));
    this.name = "OnePoleFilter";
    const options = optionsFromArguments(_OnePoleFilter.getDefaults(), arguments, ["frequency", "type"]);
    this._frequency = options.frequency;
    this._type = options.type;
    this.input = new Gain({ context: this.context });
    this.output = new Gain({ context: this.context });
    this._createFilter();
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      frequency: 880,
      type: "lowpass"
    });
  }
  /**
   * Create a filter and dispose the old one
   */
  _createFilter() {
    const oldFilter = this._filter;
    const freq = this.toFrequency(this._frequency);
    const t = 1 / (2 * Math.PI * freq);
    if (this._type === "lowpass") {
      const a0 = 1 / (t * this.context.sampleRate);
      const b1 = a0 - 1;
      this._filter = this.context.createIIRFilter([a0, 0], [1, b1]);
    } else {
      const b1 = 1 / (t * this.context.sampleRate) - 1;
      this._filter = this.context.createIIRFilter([1, -1], [1, b1]);
    }
    this.input.chain(this._filter, this.output);
    if (oldFilter) {
      this.context.setTimeout(() => {
        if (!this.disposed) {
          this.input.disconnect(oldFilter);
          oldFilter.disconnect();
        }
      }, this.blockTime);
    }
  }
  /**
   * The frequency value.
   */
  get frequency() {
    return this._frequency;
  }
  set frequency(fq) {
    this._frequency = fq;
    this._createFilter();
  }
  /**
   * The OnePole Filter type, either "highpass" or "lowpass"
   */
  get type() {
    return this._type;
  }
  set type(t) {
    this._type = t;
    this._createFilter();
  }
  /**
   * Get the frequency response curve. This curve represents how the filter
   * responses to frequencies between 20hz-20khz.
   * @param  len The number of values to return
   * @return The frequency response curve between 20-20kHz
   */
  getFrequencyResponse(len = 128) {
    const freqValues = new Float32Array(len);
    for (let i = 0; i < len; i++) {
      const norm = Math.pow(i / len, 2);
      const freq = norm * (2e4 - 20) + 20;
      freqValues[i] = freq;
    }
    const magValues = new Float32Array(len);
    const phaseValues = new Float32Array(len);
    this._filter.getFrequencyResponse(freqValues, magValues, phaseValues);
    return magValues;
  }
  dispose() {
    super.dispose();
    this.input.dispose();
    this.output.dispose();
    this._filter.disconnect();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/component/filter/LowpassCombFilter.js
var LowpassCombFilter = class _LowpassCombFilter extends ToneAudioNode {
  constructor() {
    super(optionsFromArguments(_LowpassCombFilter.getDefaults(), arguments, ["delayTime", "resonance", "dampening"]));
    this.name = "LowpassCombFilter";
    const options = optionsFromArguments(_LowpassCombFilter.getDefaults(), arguments, ["delayTime", "resonance", "dampening"]);
    this._combFilter = this.output = new FeedbackCombFilter({
      context: this.context,
      delayTime: options.delayTime,
      resonance: options.resonance
    });
    this.delayTime = this._combFilter.delayTime;
    this.resonance = this._combFilter.resonance;
    this._lowpass = this.input = new OnePoleFilter({
      context: this.context,
      frequency: options.dampening,
      type: "lowpass"
    });
    this._lowpass.connect(this._combFilter);
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      dampening: 3e3,
      delayTime: 0.1,
      resonance: 0.5
    });
  }
  /**
   * The dampening control of the feedback
   */
  get dampening() {
    return this._lowpass.frequency;
  }
  set dampening(fq) {
    this._lowpass.frequency = fq;
  }
  dispose() {
    super.dispose();
    this._combFilter.dispose();
    this._lowpass.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/instrument/PluckSynth.js
var PluckSynth = class _PluckSynth extends Instrument {
  constructor() {
    super(optionsFromArguments(_PluckSynth.getDefaults(), arguments));
    this.name = "PluckSynth";
    const options = optionsFromArguments(_PluckSynth.getDefaults(), arguments);
    this._noise = new Noise({
      context: this.context,
      type: "pink"
    });
    this.attackNoise = options.attackNoise;
    this._lfcf = new LowpassCombFilter({
      context: this.context,
      dampening: options.dampening,
      resonance: options.resonance
    });
    this.resonance = options.resonance;
    this.release = options.release;
    this._noise.connect(this._lfcf);
    this._lfcf.connect(this.output);
  }
  static getDefaults() {
    return deepMerge(Instrument.getDefaults(), {
      attackNoise: 1,
      dampening: 4e3,
      resonance: 0.7,
      release: 1
    });
  }
  /**
   * The dampening control. i.e. the lowpass filter frequency of the comb filter
   * @min 0
   * @max 7000
   */
  get dampening() {
    return this._lfcf.dampening;
  }
  set dampening(fq) {
    this._lfcf.dampening = fq;
  }
  triggerAttack(note, time2) {
    const freq = this.toFrequency(note);
    time2 = this.toSeconds(time2);
    const delayAmount = 1 / freq;
    this._lfcf.delayTime.setValueAtTime(delayAmount, time2);
    this._noise.start(time2);
    this._noise.stop(time2 + delayAmount * this.attackNoise);
    this._lfcf.resonance.cancelScheduledValues(time2);
    this._lfcf.resonance.setValueAtTime(this.resonance, time2);
    return this;
  }
  /**
   * Ramp down the {@link resonance} to 0 over the duration of the release time.
   */
  triggerRelease(time2) {
    this._lfcf.resonance.linearRampTo(0, this.release, time2);
    return this;
  }
  dispose() {
    super.dispose();
    this._noise.dispose();
    this._lfcf.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/instrument/PolySynth.js
var PolySynth = class _PolySynth extends Instrument {
  constructor() {
    super(optionsFromArguments(_PolySynth.getDefaults(), arguments, ["voice", "options"]));
    this.name = "PolySynth";
    this._availableVoices = [];
    this._activeVoices = [];
    this._voices = [];
    this._gcTimeout = -1;
    this._averageActiveVoices = 0;
    this._syncedRelease = (time2) => this.releaseAll(time2);
    const options = optionsFromArguments(_PolySynth.getDefaults(), arguments, ["voice", "options"]);
    assert(!isNumber(options.voice), "DEPRECATED: The polyphony count is no longer the first argument.");
    const defaults = options.voice.getDefaults();
    this.options = Object.assign(defaults, options.options);
    this.voice = options.voice;
    this.maxPolyphony = options.maxPolyphony;
    this._dummyVoice = this._getNextAvailableVoice();
    const index = this._voices.indexOf(this._dummyVoice);
    this._voices.splice(index, 1);
    this._gcTimeout = this.context.setInterval(this._collectGarbage.bind(this), 1);
  }
  static getDefaults() {
    return Object.assign(Instrument.getDefaults(), {
      maxPolyphony: 32,
      options: {},
      voice: Synth
    });
  }
  /**
   * The number of active voices.
   */
  get activeVoices() {
    return this._activeVoices.length;
  }
  /**
   * Invoked when the source is done making sound, so that it can be
   * readded to the pool of available voices
   */
  _makeVoiceAvailable(voice) {
    this._availableVoices.push(voice);
    const activeVoiceIndex = this._activeVoices.findIndex((e) => e.voice === voice);
    this._activeVoices.splice(activeVoiceIndex, 1);
  }
  /**
   * Get an available voice from the pool of available voices.
   * If one is not available and the maxPolyphony limit is reached,
   * steal a voice, otherwise return null.
   */
  _getNextAvailableVoice() {
    if (this._availableVoices.length) {
      return this._availableVoices.shift();
    } else if (this._voices.length < this.maxPolyphony) {
      const voice = new this.voice(Object.assign(this.options, {
        context: this.context,
        onsilence: this._makeVoiceAvailable.bind(this)
      }));
      assert(voice instanceof Monophonic, "Voice must extend Monophonic class");
      voice.connect(this.output);
      this._voices.push(voice);
      return voice;
    } else {
      warn("Max polyphony exceeded. Note dropped.");
    }
  }
  /**
   * Occasionally check if there are any allocated voices which can be cleaned up.
   */
  _collectGarbage() {
    this._averageActiveVoices = Math.max(this._averageActiveVoices * 0.95, this.activeVoices);
    if (this._availableVoices.length && this._voices.length > Math.ceil(this._averageActiveVoices + 1)) {
      const firstAvail = this._availableVoices.shift();
      const index = this._voices.indexOf(firstAvail);
      this._voices.splice(index, 1);
      if (!this.context.isOffline) {
        firstAvail.dispose();
      }
    }
  }
  /**
   * Internal method which triggers the attack
   */
  _triggerAttack(notes, time2, velocity) {
    notes.forEach((note) => {
      const midiNote = new MidiClass(this.context, note).toMidi();
      const voice = this._getNextAvailableVoice();
      if (voice) {
        voice.triggerAttack(note, time2, velocity);
        this._activeVoices.push({
          midi: midiNote,
          voice,
          released: false
        });
        this.log("triggerAttack", note, time2);
      }
    });
  }
  /**
   * Internal method which triggers the release
   */
  _triggerRelease(notes, time2) {
    notes.forEach((note) => {
      const midiNote = new MidiClass(this.context, note).toMidi();
      const event = this._activeVoices.find(({ midi, released }) => midi === midiNote && !released);
      if (event) {
        event.voice.triggerRelease(time2);
        event.released = true;
        this.log("triggerRelease", note, time2);
      }
    });
  }
  /**
   * Schedule the attack/release events. If the time is in the future, then it should set a timeout
   * to wait for just-in-time scheduling
   */
  _scheduleEvent(type, notes, time2, velocity) {
    assert(!this.disposed, "Synth was already disposed");
    if (time2 <= this.now()) {
      if (type === "attack") {
        this._triggerAttack(notes, time2, velocity);
      } else {
        this._triggerRelease(notes, time2);
      }
    } else {
      this.context.setTimeout(() => {
        if (!this.disposed) {
          this._scheduleEvent(type, notes, time2, velocity);
        }
      }, time2 - this.now());
    }
  }
  /**
   * Trigger the attack portion of the note
   * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.
   * @param  time  The start time of the note.
   * @param velocity The velocity of the note.
   * @example
   * const synth = new Tone.PolySynth(Tone.FMSynth).toDestination();
   * // trigger a chord immediately with a velocity of 0.2
   * synth.triggerAttack(["Ab3", "C4", "F5"], Tone.now(), 0.2);
   */
  triggerAttack(notes, time2, velocity) {
    if (!Array.isArray(notes)) {
      notes = [notes];
    }
    const computedTime = this.toSeconds(time2);
    this._scheduleEvent("attack", notes, computedTime, velocity);
    return this;
  }
  /**
   * Trigger the release of the note. Unlike monophonic instruments,
   * a note (or array of notes) needs to be passed in as the first argument.
   * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.
   * @param  time  When the release will be triggered.
   * @example
   * const poly = new Tone.PolySynth(Tone.AMSynth).toDestination();
   * poly.triggerAttack(["Ab3", "C4", "F5"]);
   * // trigger the release of the given notes.
   * poly.triggerRelease(["Ab3", "C4"], "+1");
   * poly.triggerRelease("F5", "+3");
   */
  triggerRelease(notes, time2) {
    if (!Array.isArray(notes)) {
      notes = [notes];
    }
    const computedTime = this.toSeconds(time2);
    this._scheduleEvent("release", notes, computedTime);
    return this;
  }
  /**
   * Trigger the attack and release after the specified duration
   * @param  notes The notes to play. Accepts a single  Frequency or an array of frequencies.
   * @param  duration the duration of the note
   * @param  time  if no time is given, defaults to now
   * @param  velocity the velocity of the attack (0-1)
   * @example
   * const poly = new Tone.PolySynth(Tone.AMSynth).toDestination();
   * // can pass in an array of durations as well
   * poly.triggerAttackRelease(["Eb3", "G4", "Bb4", "D5"], [4, 3, 2, 1]);
   */
  triggerAttackRelease(notes, duration, time2, velocity) {
    const computedTime = this.toSeconds(time2);
    this.triggerAttack(notes, computedTime, velocity);
    if (isArray(duration)) {
      assert(isArray(notes), "If the duration is an array, the notes must also be an array");
      notes = notes;
      for (let i = 0; i < notes.length; i++) {
        const d = duration[Math.min(i, duration.length - 1)];
        const durationSeconds = this.toSeconds(d);
        assert(durationSeconds > 0, "The duration must be greater than 0");
        this.triggerRelease(notes[i], computedTime + durationSeconds);
      }
    } else {
      const durationSeconds = this.toSeconds(duration);
      assert(durationSeconds > 0, "The duration must be greater than 0");
      this.triggerRelease(notes, computedTime + durationSeconds);
    }
    return this;
  }
  sync() {
    if (this._syncState()) {
      this._syncMethod("triggerAttack", 1);
      this._syncMethod("triggerRelease", 1);
      this.context.transport.on("stop", this._syncedRelease);
      this.context.transport.on("pause", this._syncedRelease);
      this.context.transport.on("loopEnd", this._syncedRelease);
    }
    return this;
  }
  /**
   * Set a member/attribute of the voices
   * @example
   * const poly = new Tone.PolySynth().toDestination();
   * // set all of the voices using an options object for the synth type
   * poly.set({
   * 	envelope: {
   * 		attack: 0.25
   * 	}
   * });
   * poly.triggerAttackRelease("Bb3", 0.2);
   */
  set(options) {
    const sanitizedOptions = omitFromObject(options, ["onsilence", "context"]);
    this.options = deepMerge(this.options, sanitizedOptions);
    this._voices.forEach((voice) => voice.set(sanitizedOptions));
    this._dummyVoice.set(sanitizedOptions);
    return this;
  }
  get() {
    return this._dummyVoice.get();
  }
  /**
   * Trigger the release portion of all the currently active voices immediately.
   * Useful for silencing the synth.
   */
  releaseAll(time2) {
    const computedTime = this.toSeconds(time2);
    this._activeVoices.forEach(({ voice }) => {
      voice.triggerRelease(computedTime);
    });
    return this;
  }
  dispose() {
    super.dispose();
    this._dummyVoice.dispose();
    this._voices.forEach((v) => v.dispose());
    this._activeVoices = [];
    this._availableVoices = [];
    this.context.clearInterval(this._gcTimeout);
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/instrument/Sampler.js
var Sampler = class _Sampler extends Instrument {
  constructor() {
    super(optionsFromArguments(_Sampler.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls"));
    this.name = "Sampler";
    this._activeSources = /* @__PURE__ */ new Map();
    const options = optionsFromArguments(_Sampler.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls");
    const urlMap = {};
    Object.keys(options.urls).forEach((note) => {
      const noteNumber = parseInt(note, 10);
      assert(isNote(note) || isNumber(noteNumber) && isFinite(noteNumber), `url key is neither a note or midi pitch: ${note}`);
      if (isNote(note)) {
        const mid = new FrequencyClass(this.context, note).toMidi();
        urlMap[mid] = options.urls[note];
      } else if (isNumber(noteNumber) && isFinite(noteNumber)) {
        urlMap[noteNumber] = options.urls[noteNumber];
      }
    });
    this._buffers = new ToneAudioBuffers({
      urls: urlMap,
      onload: options.onload,
      baseUrl: options.baseUrl,
      onerror: options.onerror
    });
    this.attack = options.attack;
    this.release = options.release;
    this.curve = options.curve;
    if (this._buffers.loaded) {
      Promise.resolve().then(options.onload);
    }
  }
  static getDefaults() {
    return Object.assign(Instrument.getDefaults(), {
      attack: 0,
      baseUrl: "",
      curve: "exponential",
      onload: noOp,
      onerror: noOp,
      release: 0.1,
      urls: {}
    });
  }
  /**
   * Returns the difference in steps between the given midi note at the closets sample.
   */
  _findClosest(midi) {
    const MAX_INTERVAL = 96;
    let interval = 0;
    while (interval < MAX_INTERVAL) {
      if (this._buffers.has(midi + interval)) {
        return -interval;
      } else if (this._buffers.has(midi - interval)) {
        return interval;
      }
      interval++;
    }
    throw new Error(`No available buffers for note: ${midi}`);
  }
  /**
   * @param  notes	The note to play, or an array of notes.
   * @param  time     When to play the note
   * @param  velocity The velocity to play the sample back.
   */
  triggerAttack(notes, time2, velocity = 1) {
    this.log("triggerAttack", notes, time2, velocity);
    if (!Array.isArray(notes)) {
      notes = [notes];
    }
    notes.forEach((note) => {
      const midiFloat = ftomf(new FrequencyClass(this.context, note).toFrequency());
      const midi = Math.round(midiFloat);
      const remainder = midiFloat - midi;
      const difference = this._findClosest(midi);
      const closestNote = midi - difference;
      const buffer2 = this._buffers.get(closestNote);
      const playbackRate = intervalToFrequencyRatio(difference + remainder);
      const source = new ToneBufferSource({
        url: buffer2,
        context: this.context,
        curve: this.curve,
        fadeIn: this.attack,
        fadeOut: this.release,
        playbackRate
      }).connect(this.output);
      source.start(time2, 0, buffer2.duration / playbackRate, velocity);
      if (!isArray(this._activeSources.get(midi))) {
        this._activeSources.set(midi, []);
      }
      this._activeSources.get(midi).push(source);
      source.onended = () => {
        if (this._activeSources && this._activeSources.has(midi)) {
          const sources = this._activeSources.get(midi);
          const index = sources.indexOf(source);
          if (index !== -1) {
            sources.splice(index, 1);
          }
        }
      };
    });
    return this;
  }
  /**
   * @param  notes	The note to release, or an array of notes.
   * @param  time     	When to release the note.
   */
  triggerRelease(notes, time2) {
    this.log("triggerRelease", notes, time2);
    if (!Array.isArray(notes)) {
      notes = [notes];
    }
    notes.forEach((note) => {
      const midi = new FrequencyClass(this.context, note).toMidi();
      if (this._activeSources.has(midi) && this._activeSources.get(midi).length) {
        const sources = this._activeSources.get(midi);
        time2 = this.toSeconds(time2);
        sources.forEach((source) => {
          source.stop(time2);
        });
        this._activeSources.set(midi, []);
      }
    });
    return this;
  }
  /**
   * Release all currently active notes.
   * @param  time     	When to release the notes.
   */
  releaseAll(time2) {
    const computedTime = this.toSeconds(time2);
    this._activeSources.forEach((sources) => {
      while (sources.length) {
        const source = sources.shift();
        source.stop(computedTime);
      }
    });
    return this;
  }
  sync() {
    if (this._syncState()) {
      this._syncMethod("triggerAttack", 1);
      this._syncMethod("triggerRelease", 1);
    }
    return this;
  }
  /**
   * Invoke the attack phase, then after the duration, invoke the release.
   * @param  notes	The note to play and release, or an array of notes.
   * @param  duration The time the note should be held
   * @param  time     When to start the attack
   * @param  velocity The velocity of the attack
   */
  triggerAttackRelease(notes, duration, time2, velocity = 1) {
    const computedTime = this.toSeconds(time2);
    this.triggerAttack(notes, computedTime, velocity);
    if (isArray(duration)) {
      assert(isArray(notes), "notes must be an array when duration is array");
      notes.forEach((note, index) => {
        const d = duration[Math.min(index, duration.length - 1)];
        this.triggerRelease(note, computedTime + this.toSeconds(d));
      });
    } else {
      this.triggerRelease(notes, computedTime + this.toSeconds(duration));
    }
    return this;
  }
  /**
   * Add a note to the sampler.
   * @param  note      The buffer's pitch.
   * @param  url  Either the url of the buffer, or a buffer which will be added with the given name.
   * @param  callback  The callback to invoke when the url is loaded.
   */
  add(note, url, callback) {
    assert(isNote(note) || isFinite(note), `note must be a pitch or midi: ${note}`);
    if (isNote(note)) {
      const mid = new FrequencyClass(this.context, note).toMidi();
      this._buffers.add(mid, url, callback);
    } else {
      this._buffers.add(note, url, callback);
    }
    return this;
  }
  /**
   * If the buffers are loaded or not
   */
  get loaded() {
    return this._buffers.loaded;
  }
  /**
   * Clean up
   */
  dispose() {
    super.dispose();
    this._buffers.dispose();
    this._activeSources.forEach((sources) => {
      sources.forEach((source) => source.dispose());
    });
    this._activeSources.clear();
    return this;
  }
};
__decorate([
  timeRange(0)
], Sampler.prototype, "attack", void 0);
__decorate([
  timeRange(0)
], Sampler.prototype, "release", void 0);

// node_modules/@magenta/music/node_modules/tone/build/esm/event/ToneEvent.js
var ToneEvent = class _ToneEvent extends ToneWithContext {
  constructor() {
    super(optionsFromArguments(_ToneEvent.getDefaults(), arguments, ["callback", "value"]));
    this.name = "ToneEvent";
    this._state = new StateTimeline("stopped");
    this._startOffset = 0;
    const options = optionsFromArguments(_ToneEvent.getDefaults(), arguments, ["callback", "value"]);
    this._loop = options.loop;
    this.callback = options.callback;
    this.value = options.value;
    this._loopStart = this.toTicks(options.loopStart);
    this._loopEnd = this.toTicks(options.loopEnd);
    this._playbackRate = options.playbackRate;
    this._probability = options.probability;
    this._humanize = options.humanize;
    this.mute = options.mute;
    this._playbackRate = options.playbackRate;
    this._state.increasing = true;
    this._rescheduleEvents();
  }
  static getDefaults() {
    return Object.assign(ToneWithContext.getDefaults(), {
      callback: noOp,
      humanize: false,
      loop: false,
      loopEnd: "1m",
      loopStart: 0,
      mute: false,
      playbackRate: 1,
      probability: 1,
      value: null
    });
  }
  /**
   * Reschedule all of the events along the timeline
   * with the updated values.
   * @param after Only reschedules events after the given time.
   */
  _rescheduleEvents(after = -1) {
    this._state.forEachFrom(after, (event) => {
      let duration;
      if (event.state === "started") {
        if (event.id !== -1) {
          this.context.transport.clear(event.id);
        }
        const startTick = event.time + Math.round(this.startOffset / this._playbackRate);
        if (this._loop === true || isNumber(this._loop) && this._loop > 1) {
          duration = Infinity;
          if (isNumber(this._loop)) {
            duration = this._loop * this._getLoopDuration();
          }
          const nextEvent = this._state.getAfter(startTick);
          if (nextEvent !== null) {
            duration = Math.min(duration, nextEvent.time - startTick);
          }
          if (duration !== Infinity) {
            duration = new TicksClass(this.context, duration);
          }
          const interval = new TicksClass(this.context, this._getLoopDuration());
          event.id = this.context.transport.scheduleRepeat(this._tick.bind(this), interval, new TicksClass(this.context, startTick), duration);
        } else {
          event.id = this.context.transport.schedule(this._tick.bind(this), new TicksClass(this.context, startTick));
        }
      }
    });
  }
  /**
   * Returns the playback state of the note, either "started" or "stopped".
   */
  get state() {
    return this._state.getValueAtTime(this.context.transport.ticks);
  }
  /**
   * The start from the scheduled start time.
   */
  get startOffset() {
    return this._startOffset;
  }
  set startOffset(offset) {
    this._startOffset = offset;
  }
  /**
   * The probability of the notes being triggered.
   */
  get probability() {
    return this._probability;
  }
  set probability(prob) {
    this._probability = prob;
  }
  /**
   * If set to true, will apply small random variation
   * to the callback time. If the value is given as a time, it will randomize
   * by that amount.
   * @example
   * const event = new Tone.ToneEvent();
   * event.humanize = true;
   */
  get humanize() {
    return this._humanize;
  }
  set humanize(variation) {
    this._humanize = variation;
  }
  /**
   * Start the note at the given time.
   * @param  time  When the event should start.
   */
  start(time2) {
    const ticks = this.toTicks(time2);
    if (this._state.getValueAtTime(ticks) === "stopped") {
      this._state.add({
        id: -1,
        state: "started",
        time: ticks
      });
      this._rescheduleEvents(ticks);
    }
    return this;
  }
  /**
   * Stop the Event at the given time.
   * @param  time  When the event should stop.
   */
  stop(time2) {
    this.cancel(time2);
    const ticks = this.toTicks(time2);
    if (this._state.getValueAtTime(ticks) === "started") {
      this._state.setStateAtTime("stopped", ticks, { id: -1 });
      const previousEvent = this._state.getBefore(ticks);
      let rescheduleTime = ticks;
      if (previousEvent !== null) {
        rescheduleTime = previousEvent.time;
      }
      this._rescheduleEvents(rescheduleTime);
    }
    return this;
  }
  /**
   * Cancel all scheduled events greater than or equal to the given time
   * @param  time  The time after which events will be cancel.
   */
  cancel(time2) {
    time2 = defaultArg(time2, -Infinity);
    const ticks = this.toTicks(time2);
    this._state.forEachFrom(ticks, (event) => {
      this.context.transport.clear(event.id);
    });
    this._state.cancel(ticks);
    return this;
  }
  /**
   * The callback function invoker. Also
   * checks if the Event is done playing
   * @param  time  The time of the event in seconds
   */
  _tick(time2) {
    const ticks = this.context.transport.getTicksAtTime(time2);
    if (!this.mute && this._state.getValueAtTime(ticks) === "started") {
      if (this.probability < 1 && Math.random() > this.probability) {
        return;
      }
      if (this.humanize) {
        let variation = 0.02;
        if (!isBoolean(this.humanize)) {
          variation = this.toSeconds(this.humanize);
        }
        time2 += (Math.random() * 2 - 1) * variation;
      }
      this.callback(time2, this.value);
    }
  }
  /**
   * Get the duration of the loop.
   */
  _getLoopDuration() {
    return (this._loopEnd - this._loopStart) / this._playbackRate;
  }
  /**
   * If the note should loop or not
   * between ToneEvent.loopStart and
   * ToneEvent.loopEnd. If set to true,
   * the event will loop indefinitely,
   * if set to a number greater than 1
   * it will play a specific number of
   * times, if set to false, 0 or 1, the
   * part will only play once.
   */
  get loop() {
    return this._loop;
  }
  set loop(loop) {
    this._loop = loop;
    this._rescheduleEvents();
  }
  /**
   * The playback rate of the event. Defaults to 1.
   * @example
   * const note = new Tone.ToneEvent();
   * note.loop = true;
   * // repeat the note twice as fast
   * note.playbackRate = 2;
   */
  get playbackRate() {
    return this._playbackRate;
  }
  set playbackRate(rate) {
    this._playbackRate = rate;
    this._rescheduleEvents();
  }
  /**
   * The loopEnd point is the time the event will loop
   * if ToneEvent.loop is true.
   */
  get loopEnd() {
    return new TicksClass(this.context, this._loopEnd).toSeconds();
  }
  set loopEnd(loopEnd) {
    this._loopEnd = this.toTicks(loopEnd);
    if (this._loop) {
      this._rescheduleEvents();
    }
  }
  /**
   * The time when the loop should start.
   */
  get loopStart() {
    return new TicksClass(this.context, this._loopStart).toSeconds();
  }
  set loopStart(loopStart) {
    this._loopStart = this.toTicks(loopStart);
    if (this._loop) {
      this._rescheduleEvents();
    }
  }
  /**
   * The current progress of the loop interval.
   * Returns 0 if the event is not started yet or
   * it is not set to loop.
   */
  get progress() {
    if (this._loop) {
      const ticks = this.context.transport.ticks;
      const lastEvent = this._state.get(ticks);
      if (lastEvent !== null && lastEvent.state === "started") {
        const loopDuration = this._getLoopDuration();
        const progress = (ticks - lastEvent.time) % loopDuration;
        return progress / loopDuration;
      } else {
        return 0;
      }
    } else {
      return 0;
    }
  }
  dispose() {
    super.dispose();
    this.cancel();
    this._state.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/event/Loop.js
var Loop = class _Loop extends ToneWithContext {
  constructor() {
    super(optionsFromArguments(_Loop.getDefaults(), arguments, ["callback", "interval"]));
    this.name = "Loop";
    const options = optionsFromArguments(_Loop.getDefaults(), arguments, ["callback", "interval"]);
    this._event = new ToneEvent({
      context: this.context,
      callback: this._tick.bind(this),
      loop: true,
      loopEnd: options.interval,
      playbackRate: options.playbackRate,
      probability: options.probability,
      humanize: options.humanize
    });
    this.callback = options.callback;
    this.iterations = options.iterations;
  }
  static getDefaults() {
    return Object.assign(ToneWithContext.getDefaults(), {
      interval: "4n",
      callback: noOp,
      playbackRate: 1,
      iterations: Infinity,
      probability: 1,
      mute: false,
      humanize: false
    });
  }
  /**
   * Start the loop at the specified time along the Transport's timeline.
   * @param  time  When to start the Loop.
   */
  start(time2) {
    this._event.start(time2);
    return this;
  }
  /**
   * Stop the loop at the given time.
   * @param  time  When to stop the Loop.
   */
  stop(time2) {
    this._event.stop(time2);
    return this;
  }
  /**
   * Cancel all scheduled events greater than or equal to the given time
   * @param  time  The time after which events will be cancel.
   */
  cancel(time2) {
    this._event.cancel(time2);
    return this;
  }
  /**
   * Internal function called when the notes should be called
   * @param time  The time the event occurs
   */
  _tick(time2) {
    this.callback(time2);
  }
  /**
   * The state of the Loop, either started or stopped.
   */
  get state() {
    return this._event.state;
  }
  /**
   * The progress of the loop as a value between 0-1. 0, when the loop is stopped or done iterating.
   */
  get progress() {
    return this._event.progress;
  }
  /**
   * The time between successive callbacks.
   * @example
   * const loop = new Tone.Loop();
   * loop.interval = "8n"; // loop every 8n
   */
  get interval() {
    return this._event.loopEnd;
  }
  set interval(interval) {
    this._event.loopEnd = interval;
  }
  /**
   * The playback rate of the loop. The normal playback rate is 1 (no change).
   * A `playbackRate` of 2 would be twice as fast.
   */
  get playbackRate() {
    return this._event.playbackRate;
  }
  set playbackRate(rate) {
    this._event.playbackRate = rate;
  }
  /**
   * Random variation +/-0.01s to the scheduled time.
   * Or give it a time value which it will randomize by.
   */
  get humanize() {
    return this._event.humanize;
  }
  set humanize(variation) {
    this._event.humanize = variation;
  }
  /**
   * The probably of the callback being invoked.
   */
  get probability() {
    return this._event.probability;
  }
  set probability(prob) {
    this._event.probability = prob;
  }
  /**
   * Muting the Loop means that no callbacks are invoked.
   */
  get mute() {
    return this._event.mute;
  }
  set mute(mute) {
    this._event.mute = mute;
  }
  /**
   * The number of iterations of the loop. The default value is `Infinity` (loop forever).
   */
  get iterations() {
    if (this._event.loop === true) {
      return Infinity;
    } else {
      return this._event.loop;
    }
  }
  set iterations(iters) {
    if (iters === Infinity) {
      this._event.loop = true;
    } else {
      this._event.loop = iters;
    }
  }
  dispose() {
    super.dispose();
    this._event.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/event/Part.js
var Part = class _Part extends ToneEvent {
  constructor() {
    super(optionsFromArguments(_Part.getDefaults(), arguments, ["callback", "events"]));
    this.name = "Part";
    this._state = new StateTimeline("stopped");
    this._events = /* @__PURE__ */ new Set();
    const options = optionsFromArguments(_Part.getDefaults(), arguments, ["callback", "events"]);
    this._state.increasing = true;
    options.events.forEach((event) => {
      if (isArray(event)) {
        this.add(event[0], event[1]);
      } else {
        this.add(event);
      }
    });
  }
  static getDefaults() {
    return Object.assign(ToneEvent.getDefaults(), {
      events: []
    });
  }
  /**
   * Start the part at the given time.
   * @param  time    When to start the part.
   * @param  offset  The offset from the start of the part to begin playing at.
   */
  start(time2, offset) {
    const ticks = this.toTicks(time2);
    if (this._state.getValueAtTime(ticks) !== "started") {
      offset = defaultArg(offset, this._loop ? this._loopStart : 0);
      if (this._loop) {
        offset = defaultArg(offset, this._loopStart);
      } else {
        offset = defaultArg(offset, 0);
      }
      const computedOffset = this.toTicks(offset);
      this._state.add({
        id: -1,
        offset: computedOffset,
        state: "started",
        time: ticks
      });
      this._forEach((event) => {
        this._startNote(event, ticks, computedOffset);
      });
    }
    return this;
  }
  /**
   * Start the event in the given event at the correct time given
   * the ticks and offset and looping.
   * @param  event
   * @param  ticks
   * @param  offset
   */
  _startNote(event, ticks, offset) {
    ticks -= offset;
    if (this._loop) {
      if (event.startOffset >= this._loopStart && event.startOffset < this._loopEnd) {
        if (event.startOffset < offset) {
          ticks += this._getLoopDuration();
        }
        event.start(new TicksClass(this.context, ticks));
      } else if (event.startOffset < this._loopStart && event.startOffset >= offset) {
        event.loop = false;
        event.start(new TicksClass(this.context, ticks));
      }
    } else if (event.startOffset >= offset) {
      event.start(new TicksClass(this.context, ticks));
    }
  }
  get startOffset() {
    return this._startOffset;
  }
  set startOffset(offset) {
    this._startOffset = offset;
    this._forEach((event) => {
      event.startOffset += this._startOffset;
    });
  }
  /**
   * Stop the part at the given time.
   * @param  time  When to stop the part.
   */
  stop(time2) {
    const ticks = this.toTicks(time2);
    this._state.cancel(ticks);
    this._state.setStateAtTime("stopped", ticks);
    this._forEach((event) => {
      event.stop(time2);
    });
    return this;
  }
  /**
   * Get/Set an Event's value at the given time.
   * If a value is passed in and no event exists at
   * the given time, one will be created with that value.
   * If two events are at the same time, the first one will
   * be returned.
   * @example
   * const part = new Tone.Part();
   * part.at("1m"); // returns the part at the first measure
   * part.at("2m", "C2"); // set the value at "2m" to C2.
   * // if an event didn't exist at that time, it will be created.
   * @param time The time of the event to get or set.
   * @param value If a value is passed in, the value of the event at the given time will be set to it.
   */
  at(time2, value) {
    const timeInTicks = new TransportTimeClass(this.context, time2).toTicks();
    const tickTime = new TicksClass(this.context, 1).toSeconds();
    const iterator = this._events.values();
    let result = iterator.next();
    while (!result.done) {
      const event = result.value;
      if (Math.abs(timeInTicks - event.startOffset) < tickTime) {
        if (isDefined(value)) {
          event.value = value;
        }
        return event;
      }
      result = iterator.next();
    }
    if (isDefined(value)) {
      this.add(time2, value);
      return this.at(time2);
    } else {
      return null;
    }
  }
  add(time2, value) {
    if (time2 instanceof Object && Reflect.has(time2, "time")) {
      value = time2;
      time2 = value.time;
    }
    const ticks = this.toTicks(time2);
    let event;
    if (value instanceof ToneEvent) {
      event = value;
      event.callback = this._tick.bind(this);
    } else {
      event = new ToneEvent({
        callback: this._tick.bind(this),
        context: this.context,
        value
      });
    }
    event.startOffset = ticks;
    event.set({
      humanize: this.humanize,
      loop: this.loop,
      loopEnd: this.loopEnd,
      loopStart: this.loopStart,
      playbackRate: this.playbackRate,
      probability: this.probability
    });
    this._events.add(event);
    this._restartEvent(event);
    return this;
  }
  /**
   * Restart the given event
   */
  _restartEvent(event) {
    this._state.forEach((stateEvent) => {
      if (stateEvent.state === "started") {
        this._startNote(event, stateEvent.time, stateEvent.offset);
      } else {
        event.stop(new TicksClass(this.context, stateEvent.time));
      }
    });
  }
  remove(time2, value) {
    if (isObject(time2) && time2.hasOwnProperty("time")) {
      value = time2;
      time2 = value.time;
    }
    time2 = this.toTicks(time2);
    this._events.forEach((event) => {
      if (event.startOffset === time2) {
        if (isUndef(value) || isDefined(value) && event.value === value) {
          this._events.delete(event);
          event.dispose();
        }
      }
    });
    return this;
  }
  /**
   * Remove all of the notes from the group.
   */
  clear() {
    this._forEach((event) => event.dispose());
    this._events.clear();
    return this;
  }
  /**
   * Cancel scheduled state change events: i.e. "start" and "stop".
   * @param after The time after which to cancel the scheduled events.
   */
  cancel(after) {
    this._forEach((event) => event.cancel(after));
    this._state.cancel(this.toTicks(after));
    return this;
  }
  /**
   * Iterate over all of the events
   */
  _forEach(callback) {
    if (this._events) {
      this._events.forEach((event) => {
        if (event instanceof _Part) {
          event._forEach(callback);
        } else {
          callback(event);
        }
      });
    }
    return this;
  }
  /**
   * Set the attribute of all of the events
   * @param  attr  the attribute to set
   * @param  value      The value to set it to
   */
  _setAll(attr, value) {
    this._forEach((event) => {
      event[attr] = value;
    });
  }
  /**
   * Internal tick method
   * @param  time  The time of the event in seconds
   */
  _tick(time2, value) {
    if (!this.mute) {
      this.callback(time2, value);
    }
  }
  /**
   * Determine if the event should be currently looping
   * given the loop boundries of this Part.
   * @param  event  The event to test
   */
  _testLoopBoundries(event) {
    if (this._loop && (event.startOffset < this._loopStart || event.startOffset >= this._loopEnd)) {
      event.cancel(0);
    } else if (event.state === "stopped") {
      this._restartEvent(event);
    }
  }
  get probability() {
    return this._probability;
  }
  set probability(prob) {
    this._probability = prob;
    this._setAll("probability", prob);
  }
  get humanize() {
    return this._humanize;
  }
  set humanize(variation) {
    this._humanize = variation;
    this._setAll("humanize", variation);
  }
  /**
   * If the part should loop or not
   * between Part.loopStart and
   * Part.loopEnd. If set to true,
   * the part will loop indefinitely,
   * if set to a number greater than 1
   * it will play a specific number of
   * times, if set to false, 0 or 1, the
   * part will only play once.
   * @example
   * const part = new Tone.Part();
   * // loop the part 8 times
   * part.loop = 8;
   */
  get loop() {
    return this._loop;
  }
  set loop(loop) {
    this._loop = loop;
    this._forEach((event) => {
      event.loopStart = this.loopStart;
      event.loopEnd = this.loopEnd;
      event.loop = loop;
      this._testLoopBoundries(event);
    });
  }
  /**
   * The loopEnd point determines when it will
   * loop if Part.loop is true.
   */
  get loopEnd() {
    return new TicksClass(this.context, this._loopEnd).toSeconds();
  }
  set loopEnd(loopEnd) {
    this._loopEnd = this.toTicks(loopEnd);
    if (this._loop) {
      this._forEach((event) => {
        event.loopEnd = loopEnd;
        this._testLoopBoundries(event);
      });
    }
  }
  /**
   * The loopStart point determines when it will
   * loop if Part.loop is true.
   */
  get loopStart() {
    return new TicksClass(this.context, this._loopStart).toSeconds();
  }
  set loopStart(loopStart) {
    this._loopStart = this.toTicks(loopStart);
    if (this._loop) {
      this._forEach((event) => {
        event.loopStart = this.loopStart;
        this._testLoopBoundries(event);
      });
    }
  }
  /**
   * The playback rate of the part
   */
  get playbackRate() {
    return this._playbackRate;
  }
  set playbackRate(rate) {
    this._playbackRate = rate;
    this._setAll("playbackRate", rate);
  }
  /**
   * The number of scheduled notes in the part.
   */
  get length() {
    return this._events.size;
  }
  dispose() {
    super.dispose();
    this.clear();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/event/PatternGenerator.js
function* upPatternGen(numValues) {
  let index = 0;
  while (index < numValues) {
    index = clamp(index, 0, numValues - 1);
    yield index;
    index++;
  }
}
function* downPatternGen(numValues) {
  let index = numValues - 1;
  while (index >= 0) {
    index = clamp(index, 0, numValues - 1);
    yield index;
    index--;
  }
}
function* infiniteGen(numValues, gen) {
  while (true) {
    yield* gen(numValues);
  }
}
function* alternatingGenerator(numValues, directionUp) {
  let index = directionUp ? 0 : numValues - 1;
  while (true) {
    index = clamp(index, 0, numValues - 1);
    yield index;
    if (directionUp) {
      index++;
      if (index >= numValues - 1) {
        directionUp = false;
      }
    } else {
      index--;
      if (index <= 0) {
        directionUp = true;
      }
    }
  }
}
function* jumpUp(numValues) {
  let index = 0;
  let stepIndex = 0;
  while (index < numValues) {
    index = clamp(index, 0, numValues - 1);
    yield index;
    stepIndex++;
    index += stepIndex % 2 ? 2 : -1;
  }
}
function* jumpDown(numValues) {
  let index = numValues - 1;
  let stepIndex = 0;
  while (index >= 0) {
    index = clamp(index, 0, numValues - 1);
    yield index;
    stepIndex++;
    index += stepIndex % 2 ? -2 : 1;
  }
}
function* randomGen(numValues) {
  while (true) {
    const randomIndex = Math.floor(Math.random() * numValues);
    yield randomIndex;
  }
}
function* randomOnce(numValues) {
  const copy = [];
  for (let i = 0; i < numValues; i++) {
    copy.push(i);
  }
  while (copy.length > 0) {
    const randVal = copy.splice(Math.floor(copy.length * Math.random()), 1);
    const index = clamp(randVal[0], 0, numValues - 1);
    yield index;
  }
}
function* randomWalk(numValues) {
  let index = Math.floor(Math.random() * numValues);
  while (true) {
    if (index === 0) {
      index++;
    } else if (index === numValues - 1) {
      index--;
    } else if (Math.random() < 0.5) {
      index--;
    } else {
      index++;
    }
    yield index;
  }
}
function* PatternGenerator(numValues, pattern = "up", index = 0) {
  assert(numValues >= 1, "The number of values must be at least one");
  switch (pattern) {
    case "up":
      yield* infiniteGen(numValues, upPatternGen);
    case "down":
      yield* infiniteGen(numValues, downPatternGen);
    case "upDown":
      yield* alternatingGenerator(numValues, true);
    case "downUp":
      yield* alternatingGenerator(numValues, false);
    case "alternateUp":
      yield* infiniteGen(numValues, jumpUp);
    case "alternateDown":
      yield* infiniteGen(numValues, jumpDown);
    case "random":
      yield* randomGen(numValues);
    case "randomOnce":
      yield* infiniteGen(numValues, randomOnce);
    case "randomWalk":
      yield* randomWalk(numValues);
  }
}

// node_modules/@magenta/music/node_modules/tone/build/esm/event/Pattern.js
var Pattern = class _Pattern extends Loop {
  constructor() {
    super(optionsFromArguments(_Pattern.getDefaults(), arguments, ["callback", "values", "pattern"]));
    this.name = "Pattern";
    const options = optionsFromArguments(_Pattern.getDefaults(), arguments, ["callback", "values", "pattern"]);
    this.callback = options.callback;
    this._values = options.values;
    this._pattern = PatternGenerator(options.values.length, options.pattern);
    this._type = options.pattern;
  }
  static getDefaults() {
    return Object.assign(Loop.getDefaults(), {
      pattern: "up",
      values: [],
      callback: noOp
    });
  }
  /**
   * Internal function called when the notes should be called
   */
  _tick(time2) {
    const index = this._pattern.next();
    this._index = index.value;
    this._value = this._values[index.value];
    this.callback(time2, this._value);
  }
  /**
   * The array of events.
   */
  get values() {
    return this._values;
  }
  set values(val) {
    this._values = val;
    this.pattern = this._type;
  }
  /**
   * The current value of the pattern.
   */
  get value() {
    return this._value;
  }
  /**
   * The current index of the pattern.
   */
  get index() {
    return this._index;
  }
  /**
   * The pattern type.
   */
  get pattern() {
    return this._type;
  }
  set pattern(pattern) {
    this._type = pattern;
    this._pattern = PatternGenerator(this._values.length, this._type);
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/event/Sequence.js
var Sequence = class _Sequence extends ToneEvent {
  constructor() {
    super(optionsFromArguments(_Sequence.getDefaults(), arguments, ["callback", "events", "subdivision"]));
    this.name = "Sequence";
    this._part = new Part({
      callback: this._seqCallback.bind(this),
      context: this.context
    });
    this._events = [];
    this._eventsArray = [];
    const options = optionsFromArguments(_Sequence.getDefaults(), arguments, ["callback", "events", "subdivision"]);
    this._subdivision = this.toTicks(options.subdivision);
    this.events = options.events;
    this.loop = options.loop;
    this.loopStart = options.loopStart;
    this.loopEnd = options.loopEnd;
    this.playbackRate = options.playbackRate;
    this.probability = options.probability;
    this.humanize = options.humanize;
    this.mute = options.mute;
    this.playbackRate = options.playbackRate;
  }
  static getDefaults() {
    return Object.assign(omitFromObject(ToneEvent.getDefaults(), ["value"]), {
      events: [],
      loop: true,
      loopEnd: 0,
      loopStart: 0,
      subdivision: "8n"
    });
  }
  /**
   * The internal callback for when an event is invoked
   */
  _seqCallback(time2, value) {
    if (value !== null && !this.mute) {
      this.callback(time2, value);
    }
  }
  /**
   * The sequence
   */
  get events() {
    return this._events;
  }
  set events(s) {
    this.clear();
    this._eventsArray = s;
    this._events = this._createSequence(this._eventsArray);
    this._eventsUpdated();
  }
  /**
   * Start the part at the given time.
   * @param  time    When to start the part.
   * @param  offset  The offset index to start at
   */
  start(time2, offset) {
    this._part.start(time2, offset ? this._indexTime(offset) : offset);
    return this;
  }
  /**
   * Stop the part at the given time.
   * @param  time  When to stop the part.
   */
  stop(time2) {
    this._part.stop(time2);
    return this;
  }
  /**
   * The subdivision of the sequence. This can only be
   * set in the constructor. The subdivision is the
   * interval between successive steps.
   */
  get subdivision() {
    return new TicksClass(this.context, this._subdivision).toSeconds();
  }
  /**
   * Create a sequence proxy which can be monitored to create subsequences
   */
  _createSequence(array) {
    return new Proxy(array, {
      get: (target, property) => {
        return target[property];
      },
      set: (target, property, value) => {
        if (isString(property) && isFinite(parseInt(property, 10))) {
          if (isArray(value)) {
            target[property] = this._createSequence(value);
          } else {
            target[property] = value;
          }
        } else {
          target[property] = value;
        }
        this._eventsUpdated();
        return true;
      }
    });
  }
  /**
   * When the sequence has changed, all of the events need to be recreated
   */
  _eventsUpdated() {
    this._part.clear();
    this._rescheduleSequence(this._eventsArray, this._subdivision, this.startOffset);
    this.loopEnd = this.loopEnd;
  }
  /**
   * reschedule all of the events that need to be rescheduled
   */
  _rescheduleSequence(sequence, subdivision, startOffset) {
    sequence.forEach((value, index) => {
      const eventOffset = index * subdivision + startOffset;
      if (isArray(value)) {
        this._rescheduleSequence(value, subdivision / value.length, eventOffset);
      } else {
        const startTime = new TicksClass(this.context, eventOffset, "i").toSeconds();
        this._part.add(startTime, value);
      }
    });
  }
  /**
   * Get the time of the index given the Sequence's subdivision
   * @param  index
   * @return The time of that index
   */
  _indexTime(index) {
    return new TicksClass(this.context, index * this._subdivision + this.startOffset).toSeconds();
  }
  /**
   * Clear all of the events
   */
  clear() {
    this._part.clear();
    return this;
  }
  dispose() {
    super.dispose();
    this._part.dispose();
    return this;
  }
  //-------------------------------------
  // PROXY CALLS
  //-------------------------------------
  get loop() {
    return this._part.loop;
  }
  set loop(l) {
    this._part.loop = l;
  }
  /**
   * The index at which the sequence should start looping
   */
  get loopStart() {
    return this._loopStart;
  }
  set loopStart(index) {
    this._loopStart = index;
    this._part.loopStart = this._indexTime(index);
  }
  /**
   * The index at which the sequence should end looping
   */
  get loopEnd() {
    return this._loopEnd;
  }
  set loopEnd(index) {
    this._loopEnd = index;
    if (index === 0) {
      this._part.loopEnd = this._indexTime(this._eventsArray.length);
    } else {
      this._part.loopEnd = this._indexTime(index);
    }
  }
  get startOffset() {
    return this._part.startOffset;
  }
  set startOffset(start2) {
    this._part.startOffset = start2;
  }
  get playbackRate() {
    return this._part.playbackRate;
  }
  set playbackRate(rate) {
    this._part.playbackRate = rate;
  }
  get probability() {
    return this._part.probability;
  }
  set probability(prob) {
    this._part.probability = prob;
  }
  get progress() {
    return this._part.progress;
  }
  get humanize() {
    return this._part.humanize;
  }
  set humanize(variation) {
    this._part.humanize = variation;
  }
  /**
   * The number of scheduled events
   */
  get length() {
    return this._part.length;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/component/channel/CrossFade.js
var CrossFade = class _CrossFade extends ToneAudioNode {
  constructor() {
    super(Object.assign(optionsFromArguments(_CrossFade.getDefaults(), arguments, ["fade"])));
    this.name = "CrossFade";
    this._panner = this.context.createStereoPanner();
    this._split = this.context.createChannelSplitter(2);
    this._g2a = new GainToAudio({ context: this.context });
    this.a = new Gain({
      context: this.context,
      gain: 0
    });
    this.b = new Gain({
      context: this.context,
      gain: 0
    });
    this.output = new Gain({ context: this.context });
    this._internalChannels = [this.a, this.b];
    const options = optionsFromArguments(_CrossFade.getDefaults(), arguments, ["fade"]);
    this.fade = new Signal({
      context: this.context,
      units: "normalRange",
      value: options.fade
    });
    readOnly(this, "fade");
    this.context.getConstant(1).connect(this._panner);
    this._panner.connect(this._split);
    this._panner.channelCount = 1;
    this._panner.channelCountMode = "explicit";
    connect(this._split, this.a.gain, 0);
    connect(this._split, this.b.gain, 1);
    this.fade.chain(this._g2a, this._panner.pan);
    this.a.connect(this.output);
    this.b.connect(this.output);
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      fade: 0.5
    });
  }
  dispose() {
    super.dispose();
    this.a.dispose();
    this.b.dispose();
    this.output.dispose();
    this.fade.dispose();
    this._g2a.dispose();
    this._panner.disconnect();
    this._split.disconnect();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/effect/Effect.js
var Effect = class extends ToneAudioNode {
  constructor(options) {
    super(options);
    this.name = "Effect";
    this._dryWet = new CrossFade({ context: this.context });
    this.wet = this._dryWet.fade;
    this.effectSend = new Gain({ context: this.context });
    this.effectReturn = new Gain({ context: this.context });
    this.input = new Gain({ context: this.context });
    this.output = this._dryWet;
    this.input.fan(this._dryWet.a, this.effectSend);
    this.effectReturn.connect(this._dryWet.b);
    this.wet.setValueAtTime(options.wet, 0);
    this._internalChannels = [this.effectReturn, this.effectSend];
    readOnly(this, "wet");
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      wet: 1
    });
  }
  /**
   * chains the effect in between the effectSend and effectReturn
   */
  connectEffect(effect) {
    this._internalChannels.push(effect);
    this.effectSend.chain(effect, this.effectReturn);
    return this;
  }
  dispose() {
    super.dispose();
    this._dryWet.dispose();
    this.effectSend.dispose();
    this.effectReturn.dispose();
    this.wet.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/effect/LFOEffect.js
var LFOEffect = class extends Effect {
  constructor(options) {
    super(options);
    this.name = "LFOEffect";
    this._lfo = new LFO({
      context: this.context,
      frequency: options.frequency,
      amplitude: options.depth
    });
    this.depth = this._lfo.amplitude;
    this.frequency = this._lfo.frequency;
    this.type = options.type;
    readOnly(this, ["frequency", "depth"]);
  }
  static getDefaults() {
    return Object.assign(Effect.getDefaults(), {
      frequency: 1,
      type: "sine",
      depth: 1
    });
  }
  /**
   * Start the effect.
   */
  start(time2) {
    this._lfo.start(time2);
    return this;
  }
  /**
   * Stop the lfo
   */
  stop(time2) {
    this._lfo.stop(time2);
    return this;
  }
  /**
   * Sync the filter to the transport.
   * @see {@link LFO.sync}
   */
  sync() {
    this._lfo.sync();
    return this;
  }
  /**
   * Unsync the filter from the transport.
   */
  unsync() {
    this._lfo.unsync();
    return this;
  }
  /**
   * The type of the LFO's oscillator.
   * @see {@link Oscillator.type}
   * @example
   * const autoFilter = new Tone.AutoFilter().start().toDestination();
   * const noise = new Tone.Noise().start().connect(autoFilter);
   * autoFilter.type = "square";
   */
  get type() {
    return this._lfo.type;
  }
  set type(type) {
    this._lfo.type = type;
  }
  dispose() {
    super.dispose();
    this._lfo.dispose();
    this.frequency.dispose();
    this.depth.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/effect/AutoFilter.js
var AutoFilter = class _AutoFilter extends LFOEffect {
  constructor() {
    super(optionsFromArguments(_AutoFilter.getDefaults(), arguments, ["frequency", "baseFrequency", "octaves"]));
    this.name = "AutoFilter";
    const options = optionsFromArguments(_AutoFilter.getDefaults(), arguments, ["frequency", "baseFrequency", "octaves"]);
    this.filter = new Filter(Object.assign(options.filter, {
      context: this.context
    }));
    this.connectEffect(this.filter);
    this._lfo.connect(this.filter.frequency);
    this.octaves = options.octaves;
    this.baseFrequency = options.baseFrequency;
  }
  static getDefaults() {
    return Object.assign(LFOEffect.getDefaults(), {
      baseFrequency: 200,
      octaves: 2.6,
      filter: {
        type: "lowpass",
        rolloff: -12,
        Q: 1
      }
    });
  }
  /**
   * The minimum value of the filter's cutoff frequency.
   */
  get baseFrequency() {
    return this._lfo.min;
  }
  set baseFrequency(freq) {
    this._lfo.min = this.toFrequency(freq);
    this.octaves = this._octaves;
  }
  /**
   * The maximum value of the filter's cutoff frequency.
   */
  get octaves() {
    return this._octaves;
  }
  set octaves(oct) {
    this._octaves = oct;
    this._lfo.max = this._lfo.min * Math.pow(2, oct);
  }
  dispose() {
    super.dispose();
    this.filter.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/component/channel/Panner.js
var Panner = class _Panner extends ToneAudioNode {
  constructor() {
    super(Object.assign(optionsFromArguments(_Panner.getDefaults(), arguments, ["pan"])));
    this.name = "Panner";
    this._panner = this.context.createStereoPanner();
    this.input = this._panner;
    this.output = this._panner;
    const options = optionsFromArguments(_Panner.getDefaults(), arguments, ["pan"]);
    this.pan = new Param({
      context: this.context,
      param: this._panner.pan,
      value: options.pan,
      minValue: -1,
      maxValue: 1
    });
    this._panner.channelCount = options.channelCount;
    this._panner.channelCountMode = "explicit";
    readOnly(this, "pan");
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      pan: 0,
      channelCount: 1
    });
  }
  dispose() {
    super.dispose();
    this._panner.disconnect();
    this.pan.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/effect/AutoPanner.js
var AutoPanner = class _AutoPanner extends LFOEffect {
  constructor() {
    super(optionsFromArguments(_AutoPanner.getDefaults(), arguments, ["frequency"]));
    this.name = "AutoPanner";
    const options = optionsFromArguments(_AutoPanner.getDefaults(), arguments, ["frequency"]);
    this._panner = new Panner({
      context: this.context,
      channelCount: options.channelCount
    });
    this.connectEffect(this._panner);
    this._lfo.connect(this._panner.pan);
    this._lfo.min = -1;
    this._lfo.max = 1;
  }
  static getDefaults() {
    return Object.assign(LFOEffect.getDefaults(), {
      channelCount: 1
    });
  }
  dispose() {
    super.dispose();
    this._panner.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/component/analysis/Follower.js
var Follower = class _Follower extends ToneAudioNode {
  constructor() {
    super(optionsFromArguments(_Follower.getDefaults(), arguments, ["smoothing"]));
    this.name = "Follower";
    const options = optionsFromArguments(_Follower.getDefaults(), arguments, ["smoothing"]);
    this._abs = this.input = new Abs({ context: this.context });
    this._lowpass = this.output = new OnePoleFilter({
      context: this.context,
      frequency: 1 / this.toSeconds(options.smoothing),
      type: "lowpass"
    });
    this._abs.connect(this._lowpass);
    this._smoothing = options.smoothing;
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      smoothing: 0.05
    });
  }
  /**
   * The amount of time it takes a value change to arrive at the updated value.
   */
  get smoothing() {
    return this._smoothing;
  }
  set smoothing(smoothing) {
    this._smoothing = smoothing;
    this._lowpass.frequency = 1 / this.toSeconds(this.smoothing);
  }
  dispose() {
    super.dispose();
    this._abs.dispose();
    this._lowpass.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/effect/AutoWah.js
var AutoWah = class _AutoWah extends Effect {
  constructor() {
    super(optionsFromArguments(_AutoWah.getDefaults(), arguments, ["baseFrequency", "octaves", "sensitivity"]));
    this.name = "AutoWah";
    const options = optionsFromArguments(_AutoWah.getDefaults(), arguments, ["baseFrequency", "octaves", "sensitivity"]);
    this._follower = new Follower({
      context: this.context,
      smoothing: options.follower
    });
    this._sweepRange = new ScaleExp({
      context: this.context,
      min: 0,
      max: 1,
      exponent: 0.5
    });
    this._baseFrequency = this.toFrequency(options.baseFrequency);
    this._octaves = options.octaves;
    this._inputBoost = new Gain({ context: this.context });
    this._bandpass = new Filter({
      context: this.context,
      rolloff: -48,
      frequency: 0,
      Q: options.Q
    });
    this._peaking = new Filter({
      context: this.context,
      type: "peaking"
    });
    this._peaking.gain.value = options.gain;
    this.gain = this._peaking.gain;
    this.Q = this._bandpass.Q;
    this.effectSend.chain(this._inputBoost, this._follower, this._sweepRange);
    this._sweepRange.connect(this._bandpass.frequency);
    this._sweepRange.connect(this._peaking.frequency);
    this.effectSend.chain(this._bandpass, this._peaking, this.effectReturn);
    this._setSweepRange();
    this.sensitivity = options.sensitivity;
    readOnly(this, ["gain", "Q"]);
  }
  static getDefaults() {
    return Object.assign(Effect.getDefaults(), {
      baseFrequency: 100,
      octaves: 6,
      sensitivity: 0,
      Q: 2,
      gain: 2,
      follower: 0.2
    });
  }
  /**
   * The number of octaves that the filter will sweep above the baseFrequency.
   */
  get octaves() {
    return this._octaves;
  }
  set octaves(octaves) {
    this._octaves = octaves;
    this._setSweepRange();
  }
  /**
   * The follower's smoothing time
   */
  get follower() {
    return this._follower.smoothing;
  }
  set follower(follower) {
    this._follower.smoothing = follower;
  }
  /**
   * The base frequency from which the sweep will start from.
   */
  get baseFrequency() {
    return this._baseFrequency;
  }
  set baseFrequency(baseFreq) {
    this._baseFrequency = this.toFrequency(baseFreq);
    this._setSweepRange();
  }
  /**
   * The sensitivity to control how responsive to the input signal the filter is.
   */
  get sensitivity() {
    return gainToDb(1 / this._inputBoost.gain.value);
  }
  set sensitivity(sensitivity) {
    this._inputBoost.gain.value = 1 / dbToGain(sensitivity);
  }
  /**
   * sets the sweep range of the scaler
   */
  _setSweepRange() {
    this._sweepRange.min = this._baseFrequency;
    this._sweepRange.max = Math.min(this._baseFrequency * Math.pow(2, this._octaves), this.context.sampleRate / 2);
  }
  dispose() {
    super.dispose();
    this._follower.dispose();
    this._sweepRange.dispose();
    this._bandpass.dispose();
    this._peaking.dispose();
    this._inputBoost.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/effect/BitCrusher.worklet.js
var workletName2 = "bit-crusher";
var bitCrusherWorklet = (
  /* javascript */
  `
	class BitCrusherWorklet extends SingleIOProcessor {

		static get parameterDescriptors() {
			return [{
				name: "bits",
				defaultValue: 12,
				minValue: 1,
				maxValue: 16,
				automationRate: 'k-rate'
			}];
		}

		generate(input, _channel, parameters) {
			const step = Math.pow(0.5, parameters.bits - 1);
			const val = step * Math.floor(input / step + 0.5);
			return val;
		}
	}
`
);
registerProcessor(workletName2, bitCrusherWorklet);

// node_modules/@magenta/music/node_modules/tone/build/esm/effect/BitCrusher.js
var BitCrusher = class _BitCrusher extends Effect {
  constructor() {
    super(optionsFromArguments(_BitCrusher.getDefaults(), arguments, ["bits"]));
    this.name = "BitCrusher";
    const options = optionsFromArguments(_BitCrusher.getDefaults(), arguments, ["bits"]);
    this._bitCrusherWorklet = new BitCrusherWorklet({
      context: this.context,
      bits: options.bits
    });
    this.connectEffect(this._bitCrusherWorklet);
    this.bits = this._bitCrusherWorklet.bits;
  }
  static getDefaults() {
    return Object.assign(Effect.getDefaults(), {
      bits: 4
    });
  }
  dispose() {
    super.dispose();
    this._bitCrusherWorklet.dispose();
    return this;
  }
};
var BitCrusherWorklet = class _BitCrusherWorklet extends ToneAudioWorklet {
  constructor() {
    super(optionsFromArguments(_BitCrusherWorklet.getDefaults(), arguments));
    this.name = "BitCrusherWorklet";
    const options = optionsFromArguments(_BitCrusherWorklet.getDefaults(), arguments);
    this.input = new Gain({ context: this.context });
    this.output = new Gain({ context: this.context });
    this.bits = new Param({
      context: this.context,
      value: options.bits,
      units: "positive",
      minValue: 1,
      maxValue: 16,
      param: this._dummyParam,
      swappable: true
    });
  }
  static getDefaults() {
    return Object.assign(ToneAudioWorklet.getDefaults(), {
      bits: 12
    });
  }
  _audioWorkletName() {
    return workletName2;
  }
  onReady(node) {
    connectSeries(this.input, node, this.output);
    const bits = node.parameters.get("bits");
    this.bits.setParam(bits);
  }
  dispose() {
    super.dispose();
    this.input.dispose();
    this.output.dispose();
    this.bits.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/effect/Chebyshev.js
var Chebyshev = class _Chebyshev extends Effect {
  constructor() {
    super(optionsFromArguments(_Chebyshev.getDefaults(), arguments, ["order"]));
    this.name = "Chebyshev";
    const options = optionsFromArguments(_Chebyshev.getDefaults(), arguments, ["order"]);
    this._shaper = new WaveShaper({
      context: this.context,
      length: 4096
    });
    this._order = options.order;
    this.connectEffect(this._shaper);
    this.order = options.order;
    this.oversample = options.oversample;
  }
  static getDefaults() {
    return Object.assign(Effect.getDefaults(), {
      order: 1,
      oversample: "none"
    });
  }
  /**
   * get the coefficient for that degree
   * @param  x the x value
   * @param  degree
   * @param  memo memoize the computed value. this speeds up computation greatly.
   */
  _getCoefficient(x, degree, memo) {
    if (memo.has(degree)) {
      return memo.get(degree);
    } else if (degree === 0) {
      memo.set(degree, 0);
    } else if (degree === 1) {
      memo.set(degree, x);
    } else {
      memo.set(degree, 2 * x * this._getCoefficient(x, degree - 1, memo) - this._getCoefficient(x, degree - 2, memo));
    }
    return memo.get(degree);
  }
  /**
   * The order of the Chebyshev polynomial which creates the equation which is applied to the incoming
   * signal through a Tone.WaveShaper. Must be an integer. The equations are in the form:
   * ```
   * order 2: 2x^2 + 1
   * order 3: 4x^3 + 3x
   * ```
   * @min 1
   * @max 100
   */
  get order() {
    return this._order;
  }
  set order(order) {
    assert(Number.isInteger(order), "'order' must be an integer");
    this._order = order;
    this._shaper.setMap(((x) => {
      return this._getCoefficient(x, order, /* @__PURE__ */ new Map());
    }));
  }
  /**
   * The oversampling of the effect. Can either be "none", "2x" or "4x".
   */
  get oversample() {
    return this._shaper.oversample;
  }
  set oversample(oversampling) {
    this._shaper.oversample = oversampling;
  }
  dispose() {
    super.dispose();
    this._shaper.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/component/channel/Split.js
var Split = class _Split extends ToneAudioNode {
  constructor() {
    super(optionsFromArguments(_Split.getDefaults(), arguments, ["channels"]));
    this.name = "Split";
    const options = optionsFromArguments(_Split.getDefaults(), arguments, ["channels"]);
    this._splitter = this.input = this.output = this.context.createChannelSplitter(options.channels);
    this._internalChannels = [this._splitter];
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      channels: 2
    });
  }
  dispose() {
    super.dispose();
    this._splitter.disconnect();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/component/channel/Merge.js
var Merge = class _Merge extends ToneAudioNode {
  constructor() {
    super(optionsFromArguments(_Merge.getDefaults(), arguments, ["channels"]));
    this.name = "Merge";
    const options = optionsFromArguments(_Merge.getDefaults(), arguments, ["channels"]);
    this._merger = this.output = this.input = this.context.createChannelMerger(options.channels);
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      channels: 2
    });
  }
  dispose() {
    super.dispose();
    this._merger.disconnect();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/effect/StereoEffect.js
var StereoEffect = class extends ToneAudioNode {
  constructor(options) {
    super(options);
    this.name = "StereoEffect";
    this.input = new Gain({ context: this.context });
    this.input.channelCount = 2;
    this.input.channelCountMode = "explicit";
    this._dryWet = this.output = new CrossFade({
      context: this.context,
      fade: options.wet
    });
    this.wet = this._dryWet.fade;
    this._split = new Split({ context: this.context, channels: 2 });
    this._merge = new Merge({ context: this.context, channels: 2 });
    this.input.connect(this._split);
    this.input.connect(this._dryWet.a);
    this._merge.connect(this._dryWet.b);
    readOnly(this, ["wet"]);
  }
  /**
   * Connect the left part of the effect
   */
  connectEffectLeft(...nodes) {
    this._split.connect(nodes[0], 0, 0);
    connectSeries(...nodes);
    connect(nodes[nodes.length - 1], this._merge, 0, 0);
  }
  /**
   * Connect the right part of the effect
   */
  connectEffectRight(...nodes) {
    this._split.connect(nodes[0], 1, 0);
    connectSeries(...nodes);
    connect(nodes[nodes.length - 1], this._merge, 0, 1);
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      wet: 1
    });
  }
  dispose() {
    super.dispose();
    this._dryWet.dispose();
    this._split.dispose();
    this._merge.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/effect/StereoFeedbackEffect.js
var StereoFeedbackEffect = class extends StereoEffect {
  constructor(options) {
    super(options);
    this.feedback = new Signal({
      context: this.context,
      value: options.feedback,
      units: "normalRange"
    });
    this._feedbackL = new Gain({ context: this.context });
    this._feedbackR = new Gain({ context: this.context });
    this._feedbackSplit = new Split({ context: this.context, channels: 2 });
    this._feedbackMerge = new Merge({ context: this.context, channels: 2 });
    this._merge.connect(this._feedbackSplit);
    this._feedbackMerge.connect(this._split);
    this._feedbackSplit.connect(this._feedbackL, 0, 0);
    this._feedbackL.connect(this._feedbackMerge, 0, 0);
    this._feedbackSplit.connect(this._feedbackR, 1, 0);
    this._feedbackR.connect(this._feedbackMerge, 0, 1);
    this.feedback.fan(this._feedbackL.gain, this._feedbackR.gain);
    readOnly(this, ["feedback"]);
  }
  static getDefaults() {
    return Object.assign(StereoEffect.getDefaults(), {
      feedback: 0.5
    });
  }
  dispose() {
    super.dispose();
    this.feedback.dispose();
    this._feedbackL.dispose();
    this._feedbackR.dispose();
    this._feedbackSplit.dispose();
    this._feedbackMerge.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/effect/Chorus.js
var Chorus = class _Chorus extends StereoFeedbackEffect {
  constructor() {
    super(optionsFromArguments(_Chorus.getDefaults(), arguments, ["frequency", "delayTime", "depth"]));
    this.name = "Chorus";
    const options = optionsFromArguments(_Chorus.getDefaults(), arguments, ["frequency", "delayTime", "depth"]);
    this._depth = options.depth;
    this._delayTime = options.delayTime / 1e3;
    this._lfoL = new LFO({
      context: this.context,
      frequency: options.frequency,
      min: 0,
      max: 1
    });
    this._lfoR = new LFO({
      context: this.context,
      frequency: options.frequency,
      min: 0,
      max: 1,
      phase: 180
    });
    this._delayNodeL = new Delay({ context: this.context });
    this._delayNodeR = new Delay({ context: this.context });
    this.frequency = this._lfoL.frequency;
    readOnly(this, ["frequency"]);
    this._lfoL.frequency.connect(this._lfoR.frequency);
    this.connectEffectLeft(this._delayNodeL);
    this.connectEffectRight(this._delayNodeR);
    this._lfoL.connect(this._delayNodeL.delayTime);
    this._lfoR.connect(this._delayNodeR.delayTime);
    this.depth = this._depth;
    this.type = options.type;
    this.spread = options.spread;
  }
  static getDefaults() {
    return Object.assign(StereoFeedbackEffect.getDefaults(), {
      frequency: 1.5,
      delayTime: 3.5,
      depth: 0.7,
      type: "sine",
      spread: 180,
      feedback: 0,
      wet: 0.5
    });
  }
  /**
   * The depth of the effect. A depth of 1 makes the delayTime
   * modulate between 0 and 2*delayTime (centered around the delayTime).
   */
  get depth() {
    return this._depth;
  }
  set depth(depth) {
    this._depth = depth;
    const deviation = this._delayTime * depth;
    this._lfoL.min = Math.max(this._delayTime - deviation, 0);
    this._lfoL.max = this._delayTime + deviation;
    this._lfoR.min = Math.max(this._delayTime - deviation, 0);
    this._lfoR.max = this._delayTime + deviation;
  }
  /**
   * The delayTime in milliseconds of the chorus. A larger delayTime
   * will give a more pronounced effect. Nominal range a delayTime
   * is between 2 and 20ms.
   */
  get delayTime() {
    return this._delayTime * 1e3;
  }
  set delayTime(delayTime) {
    this._delayTime = delayTime / 1e3;
    this.depth = this._depth;
  }
  /**
   * The oscillator type of the LFO.
   */
  get type() {
    return this._lfoL.type;
  }
  set type(type) {
    this._lfoL.type = type;
    this._lfoR.type = type;
  }
  /**
   * Amount of stereo spread. When set to 0, both LFO's will be panned centrally.
   * When set to 180, LFO's will be panned hard left and right respectively.
   */
  get spread() {
    return this._lfoR.phase - this._lfoL.phase;
  }
  set spread(spread) {
    this._lfoL.phase = 90 - spread / 2;
    this._lfoR.phase = spread / 2 + 90;
  }
  /**
   * Start the effect.
   */
  start(time2) {
    this._lfoL.start(time2);
    this._lfoR.start(time2);
    return this;
  }
  /**
   * Stop the lfo
   */
  stop(time2) {
    this._lfoL.stop(time2);
    this._lfoR.stop(time2);
    return this;
  }
  /**
   * Sync the filter to the transport.
   * @see {@link LFO.sync}
   */
  sync() {
    this._lfoL.sync();
    this._lfoR.sync();
    return this;
  }
  /**
   * Unsync the filter from the transport.
   */
  unsync() {
    this._lfoL.unsync();
    this._lfoR.unsync();
    return this;
  }
  dispose() {
    super.dispose();
    this._lfoL.dispose();
    this._lfoR.dispose();
    this._delayNodeL.dispose();
    this._delayNodeR.dispose();
    this.frequency.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/effect/Distortion.js
var Distortion = class _Distortion extends Effect {
  constructor() {
    super(optionsFromArguments(_Distortion.getDefaults(), arguments, ["distortion"]));
    this.name = "Distortion";
    const options = optionsFromArguments(_Distortion.getDefaults(), arguments, ["distortion"]);
    this._shaper = new WaveShaper({
      context: this.context,
      length: 4096
    });
    this._distortion = options.distortion;
    this.connectEffect(this._shaper);
    this.distortion = options.distortion;
    this.oversample = options.oversample;
  }
  static getDefaults() {
    return Object.assign(Effect.getDefaults(), {
      distortion: 0.4,
      oversample: "none"
    });
  }
  /**
   * The amount of distortion. Nominal range is between 0 and 1.
   */
  get distortion() {
    return this._distortion;
  }
  set distortion(amount) {
    this._distortion = amount;
    const k = amount * 100;
    const deg = Math.PI / 180;
    this._shaper.setMap((x) => {
      if (Math.abs(x) < 1e-3) {
        return 0;
      } else {
        return (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
      }
    });
  }
  /**
   * The oversampling of the effect. Can either be "none", "2x" or "4x".
   */
  get oversample() {
    return this._shaper.oversample;
  }
  set oversample(oversampling) {
    this._shaper.oversample = oversampling;
  }
  dispose() {
    super.dispose();
    this._shaper.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/effect/FeedbackEffect.js
var FeedbackEffect = class extends Effect {
  constructor(options) {
    super(options);
    this.name = "FeedbackEffect";
    this._feedbackGain = new Gain({
      context: this.context,
      gain: options.feedback,
      units: "normalRange"
    });
    this.feedback = this._feedbackGain.gain;
    readOnly(this, "feedback");
    this.effectReturn.chain(this._feedbackGain, this.effectSend);
  }
  static getDefaults() {
    return Object.assign(Effect.getDefaults(), {
      feedback: 0.125
    });
  }
  dispose() {
    super.dispose();
    this._feedbackGain.dispose();
    this.feedback.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/effect/FeedbackDelay.js
var FeedbackDelay = class _FeedbackDelay extends FeedbackEffect {
  constructor() {
    super(optionsFromArguments(_FeedbackDelay.getDefaults(), arguments, ["delayTime", "feedback"]));
    this.name = "FeedbackDelay";
    const options = optionsFromArguments(_FeedbackDelay.getDefaults(), arguments, ["delayTime", "feedback"]);
    this._delayNode = new Delay({
      context: this.context,
      delayTime: options.delayTime,
      maxDelay: options.maxDelay
    });
    this.delayTime = this._delayNode.delayTime;
    this.connectEffect(this._delayNode);
    readOnly(this, "delayTime");
  }
  static getDefaults() {
    return Object.assign(FeedbackEffect.getDefaults(), {
      delayTime: 0.25,
      maxDelay: 1
    });
  }
  dispose() {
    super.dispose();
    this._delayNode.dispose();
    this.delayTime.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/component/filter/PhaseShiftAllpass.js
var PhaseShiftAllpass = class extends ToneAudioNode {
  constructor(options) {
    super(options);
    this.name = "PhaseShiftAllpass";
    this.input = new Gain({ context: this.context });
    this.output = new Gain({ context: this.context });
    this.offset90 = new Gain({ context: this.context });
    const allpassBank1Values = [0.6923878, 0.9360654322959, 0.988229522686, 0.9987488452737];
    const allpassBank2Values = [0.4021921162426, 0.856171088242, 0.9722909545651, 0.9952884791278];
    this._bank0 = this._createAllPassFilterBank(allpassBank1Values);
    this._bank1 = this._createAllPassFilterBank(allpassBank2Values);
    this._oneSampleDelay = this.context.createIIRFilter([0, 1], [1, 0]);
    connectSeries(this.input, ...this._bank0, this._oneSampleDelay, this.output);
    connectSeries(this.input, ...this._bank1, this.offset90);
  }
  /**
   * Create all of the IIR filters from an array of values using the coefficient calculation.
   */
  _createAllPassFilterBank(bankValues) {
    const nodes = bankValues.map((value) => {
      const coefficients = [[value * value, 0, -1], [1, 0, -(value * value)]];
      return this.context.createIIRFilter(coefficients[0], coefficients[1]);
    });
    return nodes;
  }
  dispose() {
    super.dispose();
    this.input.dispose();
    this.output.dispose();
    this.offset90.dispose();
    this._bank0.forEach((f) => f.disconnect());
    this._bank1.forEach((f) => f.disconnect());
    this._oneSampleDelay.disconnect();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/effect/FrequencyShifter.js
var FrequencyShifter = class _FrequencyShifter extends Effect {
  constructor() {
    super(optionsFromArguments(_FrequencyShifter.getDefaults(), arguments, ["frequency"]));
    this.name = "FrequencyShifter";
    const options = optionsFromArguments(_FrequencyShifter.getDefaults(), arguments, ["frequency"]);
    this.frequency = new Signal({
      context: this.context,
      units: "frequency",
      value: options.frequency,
      minValue: -this.context.sampleRate / 2,
      maxValue: this.context.sampleRate / 2
    });
    this._sine = new ToneOscillatorNode({
      context: this.context,
      type: "sine"
    });
    this._cosine = new Oscillator({
      context: this.context,
      phase: -90,
      type: "sine"
    });
    this._sineMultiply = new Multiply({ context: this.context });
    this._cosineMultiply = new Multiply({ context: this.context });
    this._negate = new Negate({ context: this.context });
    this._add = new Add({ context: this.context });
    this._phaseShifter = new PhaseShiftAllpass({ context: this.context });
    this.effectSend.connect(this._phaseShifter);
    this.frequency.fan(this._sine.frequency, this._cosine.frequency);
    this._phaseShifter.offset90.connect(this._cosineMultiply);
    this._cosine.connect(this._cosineMultiply.factor);
    this._phaseShifter.connect(this._sineMultiply);
    this._sine.connect(this._sineMultiply.factor);
    this._sineMultiply.connect(this._negate);
    this._cosineMultiply.connect(this._add);
    this._negate.connect(this._add.addend);
    this._add.connect(this.effectReturn);
    const now3 = this.immediate();
    this._sine.start(now3);
    this._cosine.start(now3);
  }
  static getDefaults() {
    return Object.assign(Effect.getDefaults(), {
      frequency: 0
    });
  }
  dispose() {
    super.dispose();
    this.frequency.dispose();
    this._add.dispose();
    this._cosine.dispose();
    this._cosineMultiply.dispose();
    this._negate.dispose();
    this._phaseShifter.dispose();
    this._sine.dispose();
    this._sineMultiply.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/effect/Freeverb.js
var combFilterTunings = [1557 / 44100, 1617 / 44100, 1491 / 44100, 1422 / 44100, 1277 / 44100, 1356 / 44100, 1188 / 44100, 1116 / 44100];
var allpassFilterFrequencies = [225, 556, 441, 341];
var Freeverb = class _Freeverb extends StereoEffect {
  constructor() {
    super(optionsFromArguments(_Freeverb.getDefaults(), arguments, ["roomSize", "dampening"]));
    this.name = "Freeverb";
    this._combFilters = [];
    this._allpassFiltersL = [];
    this._allpassFiltersR = [];
    const options = optionsFromArguments(_Freeverb.getDefaults(), arguments, ["roomSize", "dampening"]);
    this.roomSize = new Signal({
      context: this.context,
      value: options.roomSize,
      units: "normalRange"
    });
    this._allpassFiltersL = allpassFilterFrequencies.map((freq) => {
      const allpassL = this.context.createBiquadFilter();
      allpassL.type = "allpass";
      allpassL.frequency.value = freq;
      return allpassL;
    });
    this._allpassFiltersR = allpassFilterFrequencies.map((freq) => {
      const allpassR = this.context.createBiquadFilter();
      allpassR.type = "allpass";
      allpassR.frequency.value = freq;
      return allpassR;
    });
    this._combFilters = combFilterTunings.map((delayTime, index) => {
      const lfpf = new LowpassCombFilter({
        context: this.context,
        dampening: options.dampening,
        delayTime
      });
      if (index < combFilterTunings.length / 2) {
        this.connectEffectLeft(lfpf, ...this._allpassFiltersL);
      } else {
        this.connectEffectRight(lfpf, ...this._allpassFiltersR);
      }
      this.roomSize.connect(lfpf.resonance);
      return lfpf;
    });
    readOnly(this, ["roomSize"]);
  }
  static getDefaults() {
    return Object.assign(StereoEffect.getDefaults(), {
      roomSize: 0.7,
      dampening: 3e3
    });
  }
  /**
   * The amount of dampening of the reverberant signal.
   */
  get dampening() {
    return this._combFilters[0].dampening;
  }
  set dampening(d) {
    this._combFilters.forEach((c) => c.dampening = d);
  }
  dispose() {
    super.dispose();
    this._allpassFiltersL.forEach((al) => al.disconnect());
    this._allpassFiltersR.forEach((ar) => ar.disconnect());
    this._combFilters.forEach((cf) => cf.dispose());
    this.roomSize.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/effect/JCReverb.js
var combFilterDelayTimes = [1687 / 25e3, 1601 / 25e3, 2053 / 25e3, 2251 / 25e3];
var combFilterResonances = [0.773, 0.802, 0.753, 0.733];
var allpassFilterFreqs = [347, 113, 37];
var JCReverb = class _JCReverb extends StereoEffect {
  constructor() {
    super(optionsFromArguments(_JCReverb.getDefaults(), arguments, ["roomSize"]));
    this.name = "JCReverb";
    this._allpassFilters = [];
    this._feedbackCombFilters = [];
    const options = optionsFromArguments(_JCReverb.getDefaults(), arguments, ["roomSize"]);
    this.roomSize = new Signal({
      context: this.context,
      value: options.roomSize,
      units: "normalRange"
    });
    this._scaleRoomSize = new Scale({
      context: this.context,
      min: -0.733,
      max: 0.197
    });
    this._allpassFilters = allpassFilterFreqs.map((freq) => {
      const allpass = this.context.createBiquadFilter();
      allpass.type = "allpass";
      allpass.frequency.value = freq;
      return allpass;
    });
    this._feedbackCombFilters = combFilterDelayTimes.map((delayTime, index) => {
      const fbcf = new FeedbackCombFilter({
        context: this.context,
        delayTime
      });
      this._scaleRoomSize.connect(fbcf.resonance);
      fbcf.resonance.value = combFilterResonances[index];
      if (index < combFilterDelayTimes.length / 2) {
        this.connectEffectLeft(...this._allpassFilters, fbcf);
      } else {
        this.connectEffectRight(...this._allpassFilters, fbcf);
      }
      return fbcf;
    });
    this.roomSize.connect(this._scaleRoomSize);
    readOnly(this, ["roomSize"]);
  }
  static getDefaults() {
    return Object.assign(StereoEffect.getDefaults(), {
      roomSize: 0.5
    });
  }
  dispose() {
    super.dispose();
    this._allpassFilters.forEach((apf) => apf.disconnect());
    this._feedbackCombFilters.forEach((fbcf) => fbcf.dispose());
    this.roomSize.dispose();
    this._scaleRoomSize.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/effect/StereoXFeedbackEffect.js
var StereoXFeedbackEffect = class extends StereoFeedbackEffect {
  constructor(options) {
    super(options);
    this._feedbackL.disconnect();
    this._feedbackL.connect(this._feedbackMerge, 0, 1);
    this._feedbackR.disconnect();
    this._feedbackR.connect(this._feedbackMerge, 0, 0);
    readOnly(this, ["feedback"]);
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/effect/PingPongDelay.js
var PingPongDelay = class _PingPongDelay extends StereoXFeedbackEffect {
  constructor() {
    super(optionsFromArguments(_PingPongDelay.getDefaults(), arguments, ["delayTime", "feedback"]));
    this.name = "PingPongDelay";
    const options = optionsFromArguments(_PingPongDelay.getDefaults(), arguments, ["delayTime", "feedback"]);
    this._leftDelay = new Delay({
      context: this.context,
      maxDelay: options.maxDelay
    });
    this._rightDelay = new Delay({
      context: this.context,
      maxDelay: options.maxDelay
    });
    this._rightPreDelay = new Delay({
      context: this.context,
      maxDelay: options.maxDelay
    });
    this.delayTime = new Signal({
      context: this.context,
      units: "time",
      value: options.delayTime
    });
    this.connectEffectLeft(this._leftDelay);
    this.connectEffectRight(this._rightPreDelay, this._rightDelay);
    this.delayTime.fan(this._leftDelay.delayTime, this._rightDelay.delayTime, this._rightPreDelay.delayTime);
    this._feedbackL.disconnect();
    this._feedbackL.connect(this._rightDelay);
    readOnly(this, ["delayTime"]);
  }
  static getDefaults() {
    return Object.assign(StereoXFeedbackEffect.getDefaults(), {
      delayTime: 0.25,
      maxDelay: 1
    });
  }
  dispose() {
    super.dispose();
    this._leftDelay.dispose();
    this._rightDelay.dispose();
    this._rightPreDelay.dispose();
    this.delayTime.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/effect/PitchShift.js
var PitchShift = class _PitchShift extends FeedbackEffect {
  constructor() {
    super(optionsFromArguments(_PitchShift.getDefaults(), arguments, ["pitch"]));
    this.name = "PitchShift";
    const options = optionsFromArguments(_PitchShift.getDefaults(), arguments, ["pitch"]);
    this._frequency = new Signal({ context: this.context });
    this._delayA = new Delay({
      maxDelay: 1,
      context: this.context
    });
    this._lfoA = new LFO({
      context: this.context,
      min: 0,
      max: 0.1,
      type: "sawtooth"
    }).connect(this._delayA.delayTime);
    this._delayB = new Delay({
      maxDelay: 1,
      context: this.context
    });
    this._lfoB = new LFO({
      context: this.context,
      min: 0,
      max: 0.1,
      type: "sawtooth",
      phase: 180
    }).connect(this._delayB.delayTime);
    this._crossFade = new CrossFade({ context: this.context });
    this._crossFadeLFO = new LFO({
      context: this.context,
      min: 0,
      max: 1,
      type: "triangle",
      phase: 90
    }).connect(this._crossFade.fade);
    this._feedbackDelay = new Delay({
      delayTime: options.delayTime,
      context: this.context
    });
    this.delayTime = this._feedbackDelay.delayTime;
    readOnly(this, "delayTime");
    this._pitch = options.pitch;
    this._windowSize = options.windowSize;
    this._delayA.connect(this._crossFade.a);
    this._delayB.connect(this._crossFade.b);
    this._frequency.fan(this._lfoA.frequency, this._lfoB.frequency, this._crossFadeLFO.frequency);
    this.effectSend.fan(this._delayA, this._delayB);
    this._crossFade.chain(this._feedbackDelay, this.effectReturn);
    const now3 = this.now();
    this._lfoA.start(now3);
    this._lfoB.start(now3);
    this._crossFadeLFO.start(now3);
    this.windowSize = this._windowSize;
  }
  static getDefaults() {
    return Object.assign(FeedbackEffect.getDefaults(), {
      pitch: 0,
      windowSize: 0.1,
      delayTime: 0,
      feedback: 0
    });
  }
  /**
   * Repitch the incoming signal by some interval (measured in semi-tones).
   * @example
   * const pitchShift = new Tone.PitchShift().toDestination();
   * const osc = new Tone.Oscillator().connect(pitchShift).start().toDestination();
   * pitchShift.pitch = -12; // down one octave
   * pitchShift.pitch = 7; // up a fifth
   */
  get pitch() {
    return this._pitch;
  }
  set pitch(interval) {
    this._pitch = interval;
    let factor = 0;
    if (interval < 0) {
      this._lfoA.min = 0;
      this._lfoA.max = this._windowSize;
      this._lfoB.min = 0;
      this._lfoB.max = this._windowSize;
      factor = intervalToFrequencyRatio(interval - 1) + 1;
    } else {
      this._lfoA.min = this._windowSize;
      this._lfoA.max = 0;
      this._lfoB.min = this._windowSize;
      this._lfoB.max = 0;
      factor = intervalToFrequencyRatio(interval) - 1;
    }
    this._frequency.value = factor * (1.2 / this._windowSize);
  }
  /**
   * The window size corresponds roughly to the sample length in a looping sampler.
   * Smaller values are desirable for a less noticeable delay time of the pitch shifted
   * signal, but larger values will result in smoother pitch shifting for larger intervals.
   * A nominal range of 0.03 to 0.1 is recommended.
   */
  get windowSize() {
    return this._windowSize;
  }
  set windowSize(size) {
    this._windowSize = this.toSeconds(size);
    this.pitch = this._pitch;
  }
  dispose() {
    super.dispose();
    this._frequency.dispose();
    this._delayA.dispose();
    this._delayB.dispose();
    this._lfoA.dispose();
    this._lfoB.dispose();
    this._crossFade.dispose();
    this._crossFadeLFO.dispose();
    this._feedbackDelay.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/effect/Phaser.js
var Phaser = class _Phaser extends StereoEffect {
  constructor() {
    super(optionsFromArguments(_Phaser.getDefaults(), arguments, ["frequency", "octaves", "baseFrequency"]));
    this.name = "Phaser";
    const options = optionsFromArguments(_Phaser.getDefaults(), arguments, ["frequency", "octaves", "baseFrequency"]);
    this._lfoL = new LFO({
      context: this.context,
      frequency: options.frequency,
      min: 0,
      max: 1
    });
    this._lfoR = new LFO({
      context: this.context,
      frequency: options.frequency,
      min: 0,
      max: 1,
      phase: 180
    });
    this._baseFrequency = this.toFrequency(options.baseFrequency);
    this._octaves = options.octaves;
    this.Q = new Signal({
      context: this.context,
      value: options.Q,
      units: "positive"
    });
    this._filtersL = this._makeFilters(options.stages, this._lfoL);
    this._filtersR = this._makeFilters(options.stages, this._lfoR);
    this.frequency = this._lfoL.frequency;
    this.frequency.value = options.frequency;
    this.connectEffectLeft(...this._filtersL);
    this.connectEffectRight(...this._filtersR);
    this._lfoL.frequency.connect(this._lfoR.frequency);
    this.baseFrequency = options.baseFrequency;
    this.octaves = options.octaves;
    this._lfoL.start();
    this._lfoR.start();
    readOnly(this, ["frequency", "Q"]);
  }
  static getDefaults() {
    return Object.assign(StereoEffect.getDefaults(), {
      frequency: 0.5,
      octaves: 3,
      stages: 10,
      Q: 10,
      baseFrequency: 350
    });
  }
  _makeFilters(stages, connectToFreq) {
    const filters = [];
    for (let i = 0; i < stages; i++) {
      const filter = this.context.createBiquadFilter();
      filter.type = "allpass";
      this.Q.connect(filter.Q);
      connectToFreq.connect(filter.frequency);
      filters.push(filter);
    }
    return filters;
  }
  /**
   * The number of octaves the phase goes above the baseFrequency
   */
  get octaves() {
    return this._octaves;
  }
  set octaves(octaves) {
    this._octaves = octaves;
    const max2 = this._baseFrequency * Math.pow(2, octaves);
    this._lfoL.max = max2;
    this._lfoR.max = max2;
  }
  /**
   * The the base frequency of the filters.
   */
  get baseFrequency() {
    return this._baseFrequency;
  }
  set baseFrequency(freq) {
    this._baseFrequency = this.toFrequency(freq);
    this._lfoL.min = this._baseFrequency;
    this._lfoR.min = this._baseFrequency;
    this.octaves = this._octaves;
  }
  dispose() {
    super.dispose();
    this.Q.dispose();
    this._lfoL.dispose();
    this._lfoR.dispose();
    this._filtersL.forEach((f) => f.disconnect());
    this._filtersR.forEach((f) => f.disconnect());
    this.frequency.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/effect/Reverb.js
var Reverb = class _Reverb extends Effect {
  constructor() {
    super(optionsFromArguments(_Reverb.getDefaults(), arguments, ["decay"]));
    this.name = "Reverb";
    this._convolver = this.context.createConvolver();
    this.ready = Promise.resolve();
    const options = optionsFromArguments(_Reverb.getDefaults(), arguments, ["decay"]);
    this._decay = options.decay;
    this._preDelay = options.preDelay;
    this.generate();
    this.connectEffect(this._convolver);
  }
  static getDefaults() {
    return Object.assign(Effect.getDefaults(), {
      decay: 1.5,
      preDelay: 0.01
    });
  }
  /**
   * The duration of the reverb.
   */
  get decay() {
    return this._decay;
  }
  set decay(time2) {
    time2 = this.toSeconds(time2);
    assertRange(time2, 1e-3);
    this._decay = time2;
    this.generate();
  }
  /**
   * The amount of time before the reverb is fully ramped in.
   */
  get preDelay() {
    return this._preDelay;
  }
  set preDelay(time2) {
    time2 = this.toSeconds(time2);
    assertRange(time2, 0);
    this._preDelay = time2;
    this.generate();
  }
  /**
   * Generate the Impulse Response. Returns a promise while the IR is being generated.
   * @return Promise which returns this object.
   */
  generate() {
    return __awaiter(this, void 0, void 0, function* () {
      const previousReady = this.ready;
      const context2 = new OfflineContext(2, this._decay + this._preDelay, this.context.sampleRate);
      const noiseL = new Noise({ context: context2 });
      const noiseR = new Noise({ context: context2 });
      const merge = new Merge({ context: context2 });
      noiseL.connect(merge, 0, 0);
      noiseR.connect(merge, 0, 1);
      const gainNode = new Gain({ context: context2 }).toDestination();
      merge.connect(gainNode);
      noiseL.start(0);
      noiseR.start(0);
      gainNode.gain.setValueAtTime(0, 0);
      gainNode.gain.setValueAtTime(1, this._preDelay);
      gainNode.gain.exponentialApproachValueAtTime(0, this._preDelay, this.decay);
      const renderPromise = context2.render();
      this.ready = renderPromise.then(noOp);
      yield previousReady;
      this._convolver.buffer = (yield renderPromise).get();
      return this;
    });
  }
  dispose() {
    super.dispose();
    this._convolver.disconnect();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/component/channel/MidSideSplit.js
var MidSideSplit = class _MidSideSplit extends ToneAudioNode {
  constructor() {
    super(optionsFromArguments(_MidSideSplit.getDefaults(), arguments));
    this.name = "MidSideSplit";
    this._split = this.input = new Split({
      channels: 2,
      context: this.context
    });
    this._midAdd = new Add({ context: this.context });
    this.mid = new Multiply({
      context: this.context,
      value: Math.SQRT1_2
    });
    this._sideSubtract = new Subtract({ context: this.context });
    this.side = new Multiply({
      context: this.context,
      value: Math.SQRT1_2
    });
    this._split.connect(this._midAdd, 0);
    this._split.connect(this._midAdd.addend, 1);
    this._split.connect(this._sideSubtract, 0);
    this._split.connect(this._sideSubtract.subtrahend, 1);
    this._midAdd.connect(this.mid);
    this._sideSubtract.connect(this.side);
  }
  dispose() {
    super.dispose();
    this.mid.dispose();
    this.side.dispose();
    this._midAdd.dispose();
    this._sideSubtract.dispose();
    this._split.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/component/channel/MidSideMerge.js
var MidSideMerge = class _MidSideMerge extends ToneAudioNode {
  constructor() {
    super(optionsFromArguments(_MidSideMerge.getDefaults(), arguments));
    this.name = "MidSideMerge";
    this.mid = new Gain({ context: this.context });
    this.side = new Gain({ context: this.context });
    this._left = new Add({ context: this.context });
    this._leftMult = new Multiply({
      context: this.context,
      value: Math.SQRT1_2
    });
    this._right = new Subtract({ context: this.context });
    this._rightMult = new Multiply({
      context: this.context,
      value: Math.SQRT1_2
    });
    this._merge = this.output = new Merge({ context: this.context });
    this.mid.fan(this._left);
    this.side.connect(this._left.addend);
    this.mid.connect(this._right);
    this.side.connect(this._right.subtrahend);
    this._left.connect(this._leftMult);
    this._right.connect(this._rightMult);
    this._leftMult.connect(this._merge, 0, 0);
    this._rightMult.connect(this._merge, 0, 1);
  }
  dispose() {
    super.dispose();
    this.mid.dispose();
    this.side.dispose();
    this._leftMult.dispose();
    this._rightMult.dispose();
    this._left.dispose();
    this._right.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/effect/MidSideEffect.js
var MidSideEffect = class extends Effect {
  constructor(options) {
    super(options);
    this.name = "MidSideEffect";
    this._midSideMerge = new MidSideMerge({ context: this.context });
    this._midSideSplit = new MidSideSplit({ context: this.context });
    this._midSend = this._midSideSplit.mid;
    this._sideSend = this._midSideSplit.side;
    this._midReturn = this._midSideMerge.mid;
    this._sideReturn = this._midSideMerge.side;
    this.effectSend.connect(this._midSideSplit);
    this._midSideMerge.connect(this.effectReturn);
  }
  /**
   * Connect the mid chain of the effect
   */
  connectEffectMid(...nodes) {
    this._midSend.chain(...nodes, this._midReturn);
  }
  /**
   * Connect the side chain of the effect
   */
  connectEffectSide(...nodes) {
    this._sideSend.chain(...nodes, this._sideReturn);
  }
  dispose() {
    super.dispose();
    this._midSideSplit.dispose();
    this._midSideMerge.dispose();
    this._midSend.dispose();
    this._sideSend.dispose();
    this._midReturn.dispose();
    this._sideReturn.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/effect/StereoWidener.js
var StereoWidener = class _StereoWidener extends MidSideEffect {
  constructor() {
    super(optionsFromArguments(_StereoWidener.getDefaults(), arguments, ["width"]));
    this.name = "StereoWidener";
    const options = optionsFromArguments(_StereoWidener.getDefaults(), arguments, ["width"]);
    this.width = new Signal({
      context: this.context,
      value: options.width,
      units: "normalRange"
    });
    readOnly(this, ["width"]);
    this._twoTimesWidthMid = new Multiply({
      context: this.context,
      value: 2
    });
    this._twoTimesWidthSide = new Multiply({
      context: this.context,
      value: 2
    });
    this._midMult = new Multiply({ context: this.context });
    this._twoTimesWidthMid.connect(this._midMult.factor);
    this.connectEffectMid(this._midMult);
    this._oneMinusWidth = new Subtract({ context: this.context });
    this._oneMinusWidth.connect(this._twoTimesWidthMid);
    connect(this.context.getConstant(1), this._oneMinusWidth);
    this.width.connect(this._oneMinusWidth.subtrahend);
    this._sideMult = new Multiply({ context: this.context });
    this.width.connect(this._twoTimesWidthSide);
    this._twoTimesWidthSide.connect(this._sideMult.factor);
    this.connectEffectSide(this._sideMult);
  }
  static getDefaults() {
    return Object.assign(MidSideEffect.getDefaults(), {
      width: 0.5
    });
  }
  dispose() {
    super.dispose();
    this.width.dispose();
    this._midMult.dispose();
    this._sideMult.dispose();
    this._twoTimesWidthMid.dispose();
    this._twoTimesWidthSide.dispose();
    this._oneMinusWidth.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/effect/Tremolo.js
var Tremolo = class _Tremolo extends StereoEffect {
  constructor() {
    super(optionsFromArguments(_Tremolo.getDefaults(), arguments, ["frequency", "depth"]));
    this.name = "Tremolo";
    const options = optionsFromArguments(_Tremolo.getDefaults(), arguments, ["frequency", "depth"]);
    this._lfoL = new LFO({
      context: this.context,
      type: options.type,
      min: 1,
      max: 0
    });
    this._lfoR = new LFO({
      context: this.context,
      type: options.type,
      min: 1,
      max: 0
    });
    this._amplitudeL = new Gain({ context: this.context });
    this._amplitudeR = new Gain({ context: this.context });
    this.frequency = new Signal({
      context: this.context,
      value: options.frequency,
      units: "frequency"
    });
    this.depth = new Signal({
      context: this.context,
      value: options.depth,
      units: "normalRange"
    });
    readOnly(this, ["frequency", "depth"]);
    this.connectEffectLeft(this._amplitudeL);
    this.connectEffectRight(this._amplitudeR);
    this._lfoL.connect(this._amplitudeL.gain);
    this._lfoR.connect(this._amplitudeR.gain);
    this.frequency.fan(this._lfoL.frequency, this._lfoR.frequency);
    this.depth.fan(this._lfoR.amplitude, this._lfoL.amplitude);
    this.spread = options.spread;
  }
  static getDefaults() {
    return Object.assign(StereoEffect.getDefaults(), {
      frequency: 10,
      type: "sine",
      depth: 0.5,
      spread: 180
    });
  }
  /**
   * Start the tremolo.
   */
  start(time2) {
    this._lfoL.start(time2);
    this._lfoR.start(time2);
    return this;
  }
  /**
   * Stop the tremolo.
   */
  stop(time2) {
    this._lfoL.stop(time2);
    this._lfoR.stop(time2);
    return this;
  }
  /**
   * Sync the effect to the transport.
   */
  sync() {
    this._lfoL.sync();
    this._lfoR.sync();
    this.context.transport.syncSignal(this.frequency);
    return this;
  }
  /**
   * Unsync the filter from the transport
   */
  unsync() {
    this._lfoL.unsync();
    this._lfoR.unsync();
    this.context.transport.unsyncSignal(this.frequency);
    return this;
  }
  /**
   * The oscillator type.
   */
  get type() {
    return this._lfoL.type;
  }
  set type(type) {
    this._lfoL.type = type;
    this._lfoR.type = type;
  }
  /**
   * Amount of stereo spread. When set to 0, both LFO's will be panned centrally.
   * When set to 180, LFO's will be panned hard left and right respectively.
   */
  get spread() {
    return this._lfoR.phase - this._lfoL.phase;
  }
  set spread(spread) {
    this._lfoL.phase = 90 - spread / 2;
    this._lfoR.phase = spread / 2 + 90;
  }
  dispose() {
    super.dispose();
    this._lfoL.dispose();
    this._lfoR.dispose();
    this._amplitudeL.dispose();
    this._amplitudeR.dispose();
    this.frequency.dispose();
    this.depth.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/effect/Vibrato.js
var Vibrato = class _Vibrato extends Effect {
  constructor() {
    super(optionsFromArguments(_Vibrato.getDefaults(), arguments, ["frequency", "depth"]));
    this.name = "Vibrato";
    const options = optionsFromArguments(_Vibrato.getDefaults(), arguments, ["frequency", "depth"]);
    this._delayNode = new Delay({
      context: this.context,
      delayTime: 0,
      maxDelay: options.maxDelay
    });
    this._lfo = new LFO({
      context: this.context,
      type: options.type,
      min: 0,
      max: options.maxDelay,
      frequency: options.frequency,
      phase: -90
      // offse the phase so the resting position is in the center
    }).start().connect(this._delayNode.delayTime);
    this.frequency = this._lfo.frequency;
    this.depth = this._lfo.amplitude;
    this.depth.value = options.depth;
    readOnly(this, ["frequency", "depth"]);
    this.effectSend.chain(this._delayNode, this.effectReturn);
  }
  static getDefaults() {
    return Object.assign(Effect.getDefaults(), {
      maxDelay: 5e-3,
      frequency: 5,
      depth: 0.1,
      type: "sine"
    });
  }
  /**
   * Type of oscillator attached to the Vibrato.
   */
  get type() {
    return this._lfo.type;
  }
  set type(type) {
    this._lfo.type = type;
  }
  dispose() {
    super.dispose();
    this._delayNode.dispose();
    this._lfo.dispose();
    this.frequency.dispose();
    this.depth.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/component/analysis/Analyser.js
var Analyser = class _Analyser extends ToneAudioNode {
  constructor() {
    super(optionsFromArguments(_Analyser.getDefaults(), arguments, ["type", "size"]));
    this.name = "Analyser";
    this._analysers = [];
    this._buffers = [];
    const options = optionsFromArguments(_Analyser.getDefaults(), arguments, ["type", "size"]);
    this.input = this.output = this._gain = new Gain({ context: this.context });
    this._split = new Split({
      context: this.context,
      channels: options.channels
    });
    this.input.connect(this._split);
    assertRange(options.channels, 1);
    for (let channel = 0; channel < options.channels; channel++) {
      this._analysers[channel] = this.context.createAnalyser();
      this._split.connect(this._analysers[channel], channel, 0);
    }
    this.size = options.size;
    this.type = options.type;
    this.smoothing = options.smoothing;
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      size: 1024,
      smoothing: 0.8,
      type: "fft",
      channels: 1
    });
  }
  /**
   * Run the analysis given the current settings. If {@link channels} = 1,
   * it will return a Float32Array. If {@link channels} > 1, it will
   * return an array of Float32Arrays where each index in the array
   * represents the analysis done on a channel.
   */
  getValue() {
    this._analysers.forEach((analyser, index) => {
      const buffer2 = this._buffers[index];
      if (this._type === "fft") {
        analyser.getFloatFrequencyData(buffer2);
      } else if (this._type === "waveform") {
        analyser.getFloatTimeDomainData(buffer2);
      }
    });
    if (this.channels === 1) {
      return this._buffers[0];
    } else {
      return this._buffers;
    }
  }
  /**
   * The size of analysis. This must be a power of two in the range 16 to 16384.
   */
  get size() {
    return this._analysers[0].frequencyBinCount;
  }
  set size(size) {
    this._analysers.forEach((analyser, index) => {
      analyser.fftSize = size * 2;
      this._buffers[index] = new Float32Array(size);
    });
  }
  /**
   * The number of channels the analyser does the analysis on. Channel
   * separation is done using {@link Split}
   */
  get channels() {
    return this._analysers.length;
  }
  /**
   * The analysis function returned by analyser.getValue(), either "fft" or "waveform".
   */
  get type() {
    return this._type;
  }
  set type(type) {
    assert(type === "waveform" || type === "fft", `Analyser: invalid type: ${type}`);
    this._type = type;
  }
  /**
   * 0 represents no time averaging with the last analysis frame.
   */
  get smoothing() {
    return this._analysers[0].smoothingTimeConstant;
  }
  set smoothing(val) {
    this._analysers.forEach((a) => a.smoothingTimeConstant = val);
  }
  /**
   * Clean up.
   */
  dispose() {
    super.dispose();
    this._analysers.forEach((a) => a.disconnect());
    this._split.dispose();
    this._gain.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/component/analysis/MeterBase.js
var MeterBase = class _MeterBase extends ToneAudioNode {
  constructor() {
    super(optionsFromArguments(_MeterBase.getDefaults(), arguments));
    this.name = "MeterBase";
    this.input = this.output = this._analyser = new Analyser({
      context: this.context,
      size: 256,
      type: "waveform"
    });
  }
  dispose() {
    super.dispose();
    this._analyser.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/component/analysis/Meter.js
var Meter = class _Meter extends MeterBase {
  constructor() {
    super(optionsFromArguments(_Meter.getDefaults(), arguments, ["smoothing"]));
    this.name = "Meter";
    const options = optionsFromArguments(_Meter.getDefaults(), arguments, ["smoothing"]);
    this.input = this.output = this._analyser = new Analyser({
      context: this.context,
      size: 256,
      type: "waveform",
      channels: options.channelCount
    });
    this.smoothing = options.smoothing, this.normalRange = options.normalRange;
    this._rms = new Array(options.channelCount);
    this._rms.fill(0);
  }
  static getDefaults() {
    return Object.assign(MeterBase.getDefaults(), {
      smoothing: 0.8,
      normalRange: false,
      channelCount: 1
    });
  }
  /**
   * Use {@link getValue} instead. For the previous getValue behavior, use DCMeter.
   * @deprecated
   */
  getLevel() {
    warn("'getLevel' has been changed to 'getValue'");
    return this.getValue();
  }
  /**
   * Get the current value of the incoming signal.
   * Output is in decibels when {@link normalRange} is `false`.
   * If {@link channels} = 1, then the output is a single number
   * representing the value of the input signal. When {@link channels} > 1,
   * then each channel is returned as a value in a number array.
   */
  getValue() {
    const aValues = this._analyser.getValue();
    const channelValues = this.channels === 1 ? [aValues] : aValues;
    const vals = channelValues.map((values, index) => {
      const totalSquared = values.reduce((total, current) => total + current * current, 0);
      const rms = Math.sqrt(totalSquared / values.length);
      this._rms[index] = Math.max(rms, this._rms[index] * this.smoothing);
      return this.normalRange ? this._rms[index] : gainToDb(this._rms[index]);
    });
    if (this.channels === 1) {
      return vals[0];
    } else {
      return vals;
    }
  }
  /**
   * The number of channels of analysis.
   */
  get channels() {
    return this._analyser.channels;
  }
  dispose() {
    super.dispose();
    this._analyser.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/component/analysis/FFT.js
var FFT = class _FFT extends MeterBase {
  constructor() {
    super(optionsFromArguments(_FFT.getDefaults(), arguments, ["size"]));
    this.name = "FFT";
    const options = optionsFromArguments(_FFT.getDefaults(), arguments, ["size"]);
    this.normalRange = options.normalRange;
    this._analyser.type = "fft";
    this.size = options.size;
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      normalRange: false,
      size: 1024,
      smoothing: 0.8
    });
  }
  /**
   * Gets the current frequency data from the connected audio source.
   * Returns the frequency data of length {@link size} as a Float32Array of decibel values.
   */
  getValue() {
    const values = this._analyser.getValue();
    return values.map((v) => this.normalRange ? dbToGain(v) : v);
  }
  /**
   * The size of analysis. This must be a power of two in the range 16 to 16384.
   * Determines the size of the array returned by {@link getValue} (i.e. the number of
   * frequency bins). Large FFT sizes may be costly to compute.
   */
  get size() {
    return this._analyser.size;
  }
  set size(size) {
    this._analyser.size = size;
  }
  /**
   * 0 represents no time averaging with the last analysis frame.
   */
  get smoothing() {
    return this._analyser.smoothing;
  }
  set smoothing(val) {
    this._analyser.smoothing = val;
  }
  /**
   * Returns the frequency value in hertz of each of the indices of the FFT's {@link getValue} response.
   * @example
   * const fft = new Tone.FFT(32);
   * console.log([0, 1, 2, 3, 4].map(index => fft.getFrequencyOfIndex(index)));
   */
  getFrequencyOfIndex(index) {
    assert(0 <= index && index < this.size, `index must be greater than or equal to 0 and less than ${this.size}`);
    return index * this.context.sampleRate / (this.size * 2);
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/component/analysis/DCMeter.js
var DCMeter = class _DCMeter extends MeterBase {
  constructor() {
    super(optionsFromArguments(_DCMeter.getDefaults(), arguments));
    this.name = "DCMeter";
    this._analyser.type = "waveform";
    this._analyser.size = 256;
  }
  /**
   * Get the signal value of the incoming signal
   */
  getValue() {
    const value = this._analyser.getValue();
    return value[0];
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/component/analysis/Waveform.js
var Waveform = class _Waveform extends MeterBase {
  constructor() {
    super(optionsFromArguments(_Waveform.getDefaults(), arguments, ["size"]));
    this.name = "Waveform";
    const options = optionsFromArguments(_Waveform.getDefaults(), arguments, ["size"]);
    this._analyser.type = "waveform";
    this.size = options.size;
  }
  static getDefaults() {
    return Object.assign(MeterBase.getDefaults(), {
      size: 1024
    });
  }
  /**
   * Return the waveform for the current time as a Float32Array where each value in the array
   * represents a sample in the waveform.
   */
  getValue() {
    return this._analyser.getValue();
  }
  /**
   * The size of analysis. This must be a power of two in the range 16 to 16384.
   * Determines the size of the array returned by {@link getValue}.
   */
  get size() {
    return this._analyser.size;
  }
  set size(size) {
    this._analyser.size = size;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/component/channel/Solo.js
var Solo = class _Solo extends ToneAudioNode {
  constructor() {
    super(optionsFromArguments(_Solo.getDefaults(), arguments, ["solo"]));
    this.name = "Solo";
    const options = optionsFromArguments(_Solo.getDefaults(), arguments, ["solo"]);
    this.input = this.output = new Gain({
      context: this.context
    });
    if (!_Solo._allSolos.has(this.context)) {
      _Solo._allSolos.set(this.context, /* @__PURE__ */ new Set());
    }
    _Solo._allSolos.get(this.context).add(this);
    this.solo = options.solo;
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      solo: false
    });
  }
  /**
   * Isolates this instance and mutes all other instances of Solo.
   * Only one instance can be soloed at a time. A soloed
   * instance will report `solo=false` when another instance is soloed.
   */
  get solo() {
    return this._isSoloed();
  }
  set solo(solo) {
    if (solo) {
      this._addSolo();
    } else {
      this._removeSolo();
    }
    _Solo._allSolos.get(this.context).forEach((instance) => instance._updateSolo());
  }
  /**
   * If the current instance is muted, i.e. another instance is soloed
   */
  get muted() {
    return this.input.gain.value === 0;
  }
  /**
   * Add this to the soloed array
   */
  _addSolo() {
    if (!_Solo._soloed.has(this.context)) {
      _Solo._soloed.set(this.context, /* @__PURE__ */ new Set());
    }
    _Solo._soloed.get(this.context).add(this);
  }
  /**
   * Remove this from the soloed array
   */
  _removeSolo() {
    if (_Solo._soloed.has(this.context)) {
      _Solo._soloed.get(this.context).delete(this);
    }
  }
  /**
   * Is this on the soloed array
   */
  _isSoloed() {
    return _Solo._soloed.has(this.context) && _Solo._soloed.get(this.context).has(this);
  }
  /**
   * Returns true if no one is soloed
   */
  _noSolos() {
    return !_Solo._soloed.has(this.context) || // or has a solo set but doesn't include any items
    _Solo._soloed.has(this.context) && _Solo._soloed.get(this.context).size === 0;
  }
  /**
   * Solo the current instance and unsolo all other instances.
   */
  _updateSolo() {
    if (this._isSoloed()) {
      this.input.gain.value = 1;
    } else if (this._noSolos()) {
      this.input.gain.value = 1;
    } else {
      this.input.gain.value = 0;
    }
  }
  dispose() {
    super.dispose();
    _Solo._allSolos.get(this.context).delete(this);
    this._removeSolo();
    return this;
  }
};
Solo._allSolos = /* @__PURE__ */ new Map();
Solo._soloed = /* @__PURE__ */ new Map();

// node_modules/@magenta/music/node_modules/tone/build/esm/component/channel/PanVol.js
var PanVol = class _PanVol extends ToneAudioNode {
  constructor() {
    super(optionsFromArguments(_PanVol.getDefaults(), arguments, ["pan", "volume"]));
    this.name = "PanVol";
    const options = optionsFromArguments(_PanVol.getDefaults(), arguments, ["pan", "volume"]);
    this._panner = this.input = new Panner({
      context: this.context,
      pan: options.pan,
      channelCount: options.channelCount
    });
    this.pan = this._panner.pan;
    this._volume = this.output = new Volume({
      context: this.context,
      volume: options.volume
    });
    this.volume = this._volume.volume;
    this._panner.connect(this._volume);
    this.mute = options.mute;
    readOnly(this, ["pan", "volume"]);
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      mute: false,
      pan: 0,
      volume: 0,
      channelCount: 1
    });
  }
  /**
   * Mute/unmute the volume
   */
  get mute() {
    return this._volume.mute;
  }
  set mute(mute) {
    this._volume.mute = mute;
  }
  dispose() {
    super.dispose();
    this._panner.dispose();
    this.pan.dispose();
    this._volume.dispose();
    this.volume.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/component/channel/Channel.js
var Channel = class _Channel extends ToneAudioNode {
  constructor() {
    super(optionsFromArguments(_Channel.getDefaults(), arguments, ["volume", "pan"]));
    this.name = "Channel";
    const options = optionsFromArguments(_Channel.getDefaults(), arguments, ["volume", "pan"]);
    this._solo = this.input = new Solo({
      solo: options.solo,
      context: this.context
    });
    this._panVol = this.output = new PanVol({
      context: this.context,
      pan: options.pan,
      volume: options.volume,
      mute: options.mute,
      channelCount: options.channelCount
    });
    this.pan = this._panVol.pan;
    this.volume = this._panVol.volume;
    this._solo.connect(this._panVol);
    readOnly(this, ["pan", "volume"]);
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      pan: 0,
      volume: 0,
      mute: false,
      solo: false,
      channelCount: 1
    });
  }
  /**
   * Solo/unsolo the channel. Soloing is only relative to other {@link Channel}s and {@link Solo} instances
   */
  get solo() {
    return this._solo.solo;
  }
  set solo(solo) {
    this._solo.solo = solo;
  }
  /**
   * If the current instance is muted, i.e. another instance is soloed,
   * or the channel is muted
   */
  get muted() {
    return this._solo.muted || this.mute;
  }
  /**
   * Mute/unmute the volume
   */
  get mute() {
    return this._panVol.mute;
  }
  set mute(mute) {
    this._panVol.mute = mute;
  }
  /**
   * Get the gain node belonging to the bus name. Create it if
   * it doesn't exist
   * @param name The bus name
   */
  _getBus(name) {
    if (!_Channel.buses.has(name)) {
      _Channel.buses.set(name, new Gain({ context: this.context }));
    }
    return _Channel.buses.get(name);
  }
  /**
   * Send audio to another channel using a string. `send` is a lot like
   * {@link connect}, except it uses a string instead of an object. This can
   * be useful in large applications to decouple sections since {@link send}
   * and {@link receive} can be invoked separately in order to connect an object
   * @param name The channel name to send the audio
   * @param volume The amount of the signal to send.
   * 	Defaults to 0db, i.e. send the entire signal
   * @returns Returns the gain node of this connection.
   */
  send(name, volume = 0) {
    const bus = this._getBus(name);
    const sendKnob = new Gain({
      context: this.context,
      units: "decibels",
      gain: volume
    });
    this.connect(sendKnob);
    sendKnob.connect(bus);
    return sendKnob;
  }
  /**
   * Receive audio from a channel which was connected with {@link send}.
   * @param name The channel name to receive audio from.
   */
  receive(name) {
    const bus = this._getBus(name);
    bus.connect(this);
    return this;
  }
  dispose() {
    super.dispose();
    this._panVol.dispose();
    this.pan.dispose();
    this.volume.dispose();
    this._solo.dispose();
    return this;
  }
};
Channel.buses = /* @__PURE__ */ new Map();

// node_modules/@magenta/music/node_modules/tone/build/esm/component/channel/Mono.js
var Mono = class _Mono extends ToneAudioNode {
  constructor() {
    super(optionsFromArguments(_Mono.getDefaults(), arguments));
    this.name = "Mono";
    this.input = new Gain({ context: this.context });
    this._merge = this.output = new Merge({
      channels: 2,
      context: this.context
    });
    this.input.connect(this._merge, 0, 0);
    this.input.connect(this._merge, 0, 1);
  }
  dispose() {
    super.dispose();
    this._merge.dispose();
    this.input.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/component/channel/MultibandSplit.js
var MultibandSplit = class _MultibandSplit extends ToneAudioNode {
  constructor() {
    super(optionsFromArguments(_MultibandSplit.getDefaults(), arguments, ["lowFrequency", "highFrequency"]));
    this.name = "MultibandSplit";
    this.input = new Gain({ context: this.context });
    this.output = void 0;
    this.low = new Filter({
      context: this.context,
      frequency: 0,
      type: "lowpass"
    });
    this._lowMidFilter = new Filter({
      context: this.context,
      frequency: 0,
      type: "highpass"
    });
    this.mid = new Filter({
      context: this.context,
      frequency: 0,
      type: "lowpass"
    });
    this.high = new Filter({
      context: this.context,
      frequency: 0,
      type: "highpass"
    });
    this._internalChannels = [this.low, this.mid, this.high];
    const options = optionsFromArguments(_MultibandSplit.getDefaults(), arguments, ["lowFrequency", "highFrequency"]);
    this.lowFrequency = new Signal({
      context: this.context,
      units: "frequency",
      value: options.lowFrequency
    });
    this.highFrequency = new Signal({
      context: this.context,
      units: "frequency",
      value: options.highFrequency
    });
    this.Q = new Signal({
      context: this.context,
      units: "positive",
      value: options.Q
    });
    this.input.fan(this.low, this.high);
    this.input.chain(this._lowMidFilter, this.mid);
    this.lowFrequency.fan(this.low.frequency, this._lowMidFilter.frequency);
    this.highFrequency.fan(this.mid.frequency, this.high.frequency);
    this.Q.connect(this.low.Q);
    this.Q.connect(this._lowMidFilter.Q);
    this.Q.connect(this.mid.Q);
    this.Q.connect(this.high.Q);
    readOnly(this, ["high", "mid", "low", "highFrequency", "lowFrequency"]);
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      Q: 1,
      highFrequency: 2500,
      lowFrequency: 400
    });
  }
  /**
   * Clean up.
   */
  dispose() {
    super.dispose();
    writable(this, ["high", "mid", "low", "highFrequency", "lowFrequency"]);
    this.low.dispose();
    this._lowMidFilter.dispose();
    this.mid.dispose();
    this.high.dispose();
    this.lowFrequency.dispose();
    this.highFrequency.dispose();
    this.Q.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/core/context/Listener.js
var ListenerClass = class extends ToneAudioNode {
  constructor() {
    super(...arguments);
    this.name = "Listener";
    this.positionX = new Param({
      context: this.context,
      param: this.context.rawContext.listener.positionX
    });
    this.positionY = new Param({
      context: this.context,
      param: this.context.rawContext.listener.positionY
    });
    this.positionZ = new Param({
      context: this.context,
      param: this.context.rawContext.listener.positionZ
    });
    this.forwardX = new Param({
      context: this.context,
      param: this.context.rawContext.listener.forwardX
    });
    this.forwardY = new Param({
      context: this.context,
      param: this.context.rawContext.listener.forwardY
    });
    this.forwardZ = new Param({
      context: this.context,
      param: this.context.rawContext.listener.forwardZ
    });
    this.upX = new Param({
      context: this.context,
      param: this.context.rawContext.listener.upX
    });
    this.upY = new Param({
      context: this.context,
      param: this.context.rawContext.listener.upY
    });
    this.upZ = new Param({
      context: this.context,
      param: this.context.rawContext.listener.upZ
    });
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      positionX: 0,
      positionY: 0,
      positionZ: 0,
      forwardX: 0,
      forwardY: 0,
      forwardZ: -1,
      upX: 0,
      upY: 1,
      upZ: 0
    });
  }
  dispose() {
    super.dispose();
    this.positionX.dispose();
    this.positionY.dispose();
    this.positionZ.dispose();
    this.forwardX.dispose();
    this.forwardY.dispose();
    this.forwardZ.dispose();
    this.upX.dispose();
    this.upY.dispose();
    this.upZ.dispose();
    return this;
  }
};
onContextInit((context2) => {
  context2.listener = new ListenerClass({ context: context2 });
});
onContextClose((context2) => {
  context2.listener.dispose();
});

// node_modules/@magenta/music/node_modules/tone/build/esm/component/channel/Panner3D.js
var Panner3D = class _Panner3D extends ToneAudioNode {
  constructor() {
    super(optionsFromArguments(_Panner3D.getDefaults(), arguments, ["positionX", "positionY", "positionZ"]));
    this.name = "Panner3D";
    const options = optionsFromArguments(_Panner3D.getDefaults(), arguments, ["positionX", "positionY", "positionZ"]);
    this._panner = this.input = this.output = this.context.createPanner();
    this.panningModel = options.panningModel;
    this.maxDistance = options.maxDistance;
    this.distanceModel = options.distanceModel;
    this.coneOuterGain = options.coneOuterGain;
    this.coneOuterAngle = options.coneOuterAngle;
    this.coneInnerAngle = options.coneInnerAngle;
    this.refDistance = options.refDistance;
    this.rolloffFactor = options.rolloffFactor;
    this.positionX = new Param({
      context: this.context,
      param: this._panner.positionX,
      value: options.positionX
    });
    this.positionY = new Param({
      context: this.context,
      param: this._panner.positionY,
      value: options.positionY
    });
    this.positionZ = new Param({
      context: this.context,
      param: this._panner.positionZ,
      value: options.positionZ
    });
    this.orientationX = new Param({
      context: this.context,
      param: this._panner.orientationX,
      value: options.orientationX
    });
    this.orientationY = new Param({
      context: this.context,
      param: this._panner.orientationY,
      value: options.orientationY
    });
    this.orientationZ = new Param({
      context: this.context,
      param: this._panner.orientationZ,
      value: options.orientationZ
    });
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      coneInnerAngle: 360,
      coneOuterAngle: 360,
      coneOuterGain: 0,
      distanceModel: "inverse",
      maxDistance: 1e4,
      orientationX: 0,
      orientationY: 0,
      orientationZ: 0,
      panningModel: "equalpower",
      positionX: 0,
      positionY: 0,
      positionZ: 0,
      refDistance: 1,
      rolloffFactor: 1
    });
  }
  /**
   * Sets the position of the source in 3d space.
   */
  setPosition(x, y, z) {
    this.positionX.value = x;
    this.positionY.value = y;
    this.positionZ.value = z;
    return this;
  }
  /**
   * Sets the orientation of the source in 3d space.
   */
  setOrientation(x, y, z) {
    this.orientationX.value = x;
    this.orientationY.value = y;
    this.orientationZ.value = z;
    return this;
  }
  /**
   * The panning model. Either "equalpower" or "HRTF".
   */
  get panningModel() {
    return this._panner.panningModel;
  }
  set panningModel(val) {
    this._panner.panningModel = val;
  }
  /**
   * A reference distance for reducing volume as source move further from the listener
   */
  get refDistance() {
    return this._panner.refDistance;
  }
  set refDistance(val) {
    this._panner.refDistance = val;
  }
  /**
   * Describes how quickly the volume is reduced as source moves away from listener.
   */
  get rolloffFactor() {
    return this._panner.rolloffFactor;
  }
  set rolloffFactor(val) {
    this._panner.rolloffFactor = val;
  }
  /**
   * The distance model used by,  "linear", "inverse", or "exponential".
   */
  get distanceModel() {
    return this._panner.distanceModel;
  }
  set distanceModel(val) {
    this._panner.distanceModel = val;
  }
  /**
   * The angle, in degrees, inside of which there will be no volume reduction
   */
  get coneInnerAngle() {
    return this._panner.coneInnerAngle;
  }
  set coneInnerAngle(val) {
    this._panner.coneInnerAngle = val;
  }
  /**
   * The angle, in degrees, outside of which the volume will be reduced
   * to a constant value of coneOuterGain
   */
  get coneOuterAngle() {
    return this._panner.coneOuterAngle;
  }
  set coneOuterAngle(val) {
    this._panner.coneOuterAngle = val;
  }
  /**
   * The gain outside of the coneOuterAngle
   */
  get coneOuterGain() {
    return this._panner.coneOuterGain;
  }
  set coneOuterGain(val) {
    this._panner.coneOuterGain = val;
  }
  /**
   * The maximum distance between source and listener,
   * after which the volume will not be reduced any further.
   */
  get maxDistance() {
    return this._panner.maxDistance;
  }
  set maxDistance(val) {
    this._panner.maxDistance = val;
  }
  dispose() {
    super.dispose();
    this._panner.disconnect();
    this.orientationX.dispose();
    this.orientationY.dispose();
    this.orientationZ.dispose();
    this.positionX.dispose();
    this.positionY.dispose();
    this.positionZ.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/component/channel/Recorder.js
var Recorder = class _Recorder extends ToneAudioNode {
  constructor() {
    super(optionsFromArguments(_Recorder.getDefaults(), arguments));
    this.name = "Recorder";
    const options = optionsFromArguments(_Recorder.getDefaults(), arguments);
    this.input = new Gain({
      context: this.context
    });
    assert(_Recorder.supported, "Media Recorder API is not available");
    this._stream = this.context.createMediaStreamDestination();
    this.input.connect(this._stream);
    this._recorder = new MediaRecorder(this._stream.stream, {
      mimeType: options.mimeType
    });
  }
  static getDefaults() {
    return ToneAudioNode.getDefaults();
  }
  /**
   * The mime type is the format that the audio is encoded in. For Chrome
   * that is typically webm encoded as "vorbis".
   */
  get mimeType() {
    return this._recorder.mimeType;
  }
  /**
   * Test if your platform supports the Media Recorder API. If it's not available,
   * try installing this (polyfill)[https://www.npmjs.com/package/audio-recorder-polyfill].
   */
  static get supported() {
    return theWindow !== null && Reflect.has(theWindow, "MediaRecorder");
  }
  /**
   * Get the playback state of the Recorder, either "started", "stopped" or "paused"
   */
  get state() {
    if (this._recorder.state === "inactive") {
      return "stopped";
    } else if (this._recorder.state === "paused") {
      return "paused";
    } else {
      return "started";
    }
  }
  /**
   * Start the Recorder. Returns a promise which resolves
   * when the recorder has started.
   */
  start() {
    return __awaiter(this, void 0, void 0, function* () {
      assert(this.state !== "started", "Recorder is already started");
      const startPromise = new Promise((done) => {
        const handleStart = () => {
          this._recorder.removeEventListener("start", handleStart, false);
          done();
        };
        this._recorder.addEventListener("start", handleStart, false);
      });
      this._recorder.start();
      return yield startPromise;
    });
  }
  /**
   * Stop the recorder. Returns a promise with the recorded content until this point
   * encoded as {@link mimeType}
   */
  stop() {
    return __awaiter(this, void 0, void 0, function* () {
      assert(this.state !== "stopped", "Recorder is not started");
      const dataPromise = new Promise((done) => {
        const handleData = (e) => {
          this._recorder.removeEventListener("dataavailable", handleData, false);
          done(e.data);
        };
        this._recorder.addEventListener("dataavailable", handleData, false);
      });
      this._recorder.stop();
      return yield dataPromise;
    });
  }
  /**
   * Pause the recorder
   */
  pause() {
    assert(this.state === "started", "Recorder must be started");
    this._recorder.pause();
    return this;
  }
  dispose() {
    super.dispose();
    this.input.dispose();
    this._stream.disconnect();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/component/dynamics/Compressor.js
var Compressor = class _Compressor extends ToneAudioNode {
  constructor() {
    super(optionsFromArguments(_Compressor.getDefaults(), arguments, ["threshold", "ratio"]));
    this.name = "Compressor";
    this._compressor = this.context.createDynamicsCompressor();
    this.input = this._compressor;
    this.output = this._compressor;
    const options = optionsFromArguments(_Compressor.getDefaults(), arguments, ["threshold", "ratio"]);
    this.threshold = new Param({
      minValue: this._compressor.threshold.minValue,
      maxValue: this._compressor.threshold.maxValue,
      context: this.context,
      convert: false,
      param: this._compressor.threshold,
      units: "decibels",
      value: options.threshold
    });
    this.attack = new Param({
      minValue: this._compressor.attack.minValue,
      maxValue: this._compressor.attack.maxValue,
      context: this.context,
      param: this._compressor.attack,
      units: "time",
      value: options.attack
    });
    this.release = new Param({
      minValue: this._compressor.release.minValue,
      maxValue: this._compressor.release.maxValue,
      context: this.context,
      param: this._compressor.release,
      units: "time",
      value: options.release
    });
    this.knee = new Param({
      minValue: this._compressor.knee.minValue,
      maxValue: this._compressor.knee.maxValue,
      context: this.context,
      convert: false,
      param: this._compressor.knee,
      units: "decibels",
      value: options.knee
    });
    this.ratio = new Param({
      minValue: this._compressor.ratio.minValue,
      maxValue: this._compressor.ratio.maxValue,
      context: this.context,
      convert: false,
      param: this._compressor.ratio,
      units: "positive",
      value: options.ratio
    });
    readOnly(this, ["knee", "release", "attack", "ratio", "threshold"]);
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      attack: 3e-3,
      knee: 30,
      ratio: 12,
      release: 0.25,
      threshold: -24
    });
  }
  /**
   * A read-only decibel value for metering purposes, representing the current amount of gain
   * reduction that the compressor is applying to the signal. If fed no signal the value will be 0 (no gain reduction).
   */
  get reduction() {
    return this._compressor.reduction;
  }
  dispose() {
    super.dispose();
    this._compressor.disconnect();
    this.attack.dispose();
    this.release.dispose();
    this.threshold.dispose();
    this.ratio.dispose();
    this.knee.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/component/dynamics/Gate.js
var Gate = class _Gate extends ToneAudioNode {
  constructor() {
    super(Object.assign(optionsFromArguments(_Gate.getDefaults(), arguments, ["threshold", "smoothing"])));
    this.name = "Gate";
    const options = optionsFromArguments(_Gate.getDefaults(), arguments, ["threshold", "smoothing"]);
    this._follower = new Follower({
      context: this.context,
      smoothing: options.smoothing
    });
    this._gt = new GreaterThan({
      context: this.context,
      value: dbToGain(options.threshold)
    });
    this.input = new Gain({ context: this.context });
    this._gate = this.output = new Gain({ context: this.context });
    this.input.connect(this._gate);
    this.input.chain(this._follower, this._gt, this._gate.gain);
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      smoothing: 0.1,
      threshold: -40
    });
  }
  /**
   * The threshold of the gate in decibels
   */
  get threshold() {
    return gainToDb(this._gt.value);
  }
  set threshold(thresh) {
    this._gt.value = dbToGain(thresh);
  }
  /**
   * The attack/decay speed of the gate.
   * @see {@link Follower.smoothing}
   */
  get smoothing() {
    return this._follower.smoothing;
  }
  set smoothing(smoothingTime) {
    this._follower.smoothing = smoothingTime;
  }
  dispose() {
    super.dispose();
    this.input.dispose();
    this._follower.dispose();
    this._gt.dispose();
    this._gate.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/component/dynamics/Limiter.js
var Limiter = class _Limiter extends ToneAudioNode {
  constructor() {
    super(Object.assign(optionsFromArguments(_Limiter.getDefaults(), arguments, ["threshold"])));
    this.name = "Limiter";
    const options = optionsFromArguments(_Limiter.getDefaults(), arguments, ["threshold"]);
    this._compressor = this.input = this.output = new Compressor({
      context: this.context,
      ratio: 20,
      attack: 3e-3,
      release: 0.01,
      threshold: options.threshold
    });
    this.threshold = this._compressor.threshold;
    readOnly(this, "threshold");
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      threshold: -12
    });
  }
  /**
   * A read-only decibel value for metering purposes, representing the current amount of gain
   * reduction that the compressor is applying to the signal.
   */
  get reduction() {
    return this._compressor.reduction;
  }
  dispose() {
    super.dispose();
    this._compressor.dispose();
    this.threshold.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/component/dynamics/MidSideCompressor.js
var MidSideCompressor = class _MidSideCompressor extends ToneAudioNode {
  constructor() {
    super(Object.assign(optionsFromArguments(_MidSideCompressor.getDefaults(), arguments)));
    this.name = "MidSideCompressor";
    const options = optionsFromArguments(_MidSideCompressor.getDefaults(), arguments);
    this._midSideSplit = this.input = new MidSideSplit({ context: this.context });
    this._midSideMerge = this.output = new MidSideMerge({ context: this.context });
    this.mid = new Compressor(Object.assign(options.mid, { context: this.context }));
    this.side = new Compressor(Object.assign(options.side, { context: this.context }));
    this._midSideSplit.mid.chain(this.mid, this._midSideMerge.mid);
    this._midSideSplit.side.chain(this.side, this._midSideMerge.side);
    readOnly(this, ["mid", "side"]);
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      mid: {
        ratio: 3,
        threshold: -24,
        release: 0.03,
        attack: 0.02,
        knee: 16
      },
      side: {
        ratio: 6,
        threshold: -30,
        release: 0.25,
        attack: 0.03,
        knee: 10
      }
    });
  }
  dispose() {
    super.dispose();
    this.mid.dispose();
    this.side.dispose();
    this._midSideSplit.dispose();
    this._midSideMerge.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/component/dynamics/MultibandCompressor.js
var MultibandCompressor = class _MultibandCompressor extends ToneAudioNode {
  constructor() {
    super(Object.assign(optionsFromArguments(_MultibandCompressor.getDefaults(), arguments)));
    this.name = "MultibandCompressor";
    const options = optionsFromArguments(_MultibandCompressor.getDefaults(), arguments);
    this._splitter = this.input = new MultibandSplit({
      context: this.context,
      lowFrequency: options.lowFrequency,
      highFrequency: options.highFrequency
    });
    this.lowFrequency = this._splitter.lowFrequency;
    this.highFrequency = this._splitter.highFrequency;
    this.output = new Gain({ context: this.context });
    this.low = new Compressor(Object.assign(options.low, { context: this.context }));
    this.mid = new Compressor(Object.assign(options.mid, { context: this.context }));
    this.high = new Compressor(Object.assign(options.high, { context: this.context }));
    this._splitter.low.chain(this.low, this.output);
    this._splitter.mid.chain(this.mid, this.output);
    this._splitter.high.chain(this.high, this.output);
    readOnly(this, ["high", "mid", "low", "highFrequency", "lowFrequency"]);
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      lowFrequency: 250,
      highFrequency: 2e3,
      low: {
        ratio: 6,
        threshold: -30,
        release: 0.25,
        attack: 0.03,
        knee: 10
      },
      mid: {
        ratio: 3,
        threshold: -24,
        release: 0.03,
        attack: 0.02,
        knee: 16
      },
      high: {
        ratio: 3,
        threshold: -24,
        release: 0.03,
        attack: 0.02,
        knee: 16
      }
    });
  }
  dispose() {
    super.dispose();
    this._splitter.dispose();
    this.low.dispose();
    this.mid.dispose();
    this.high.dispose();
    this.output.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/component/filter/EQ3.js
var EQ3 = class _EQ3 extends ToneAudioNode {
  constructor() {
    super(optionsFromArguments(_EQ3.getDefaults(), arguments, ["low", "mid", "high"]));
    this.name = "EQ3";
    this.output = new Gain({ context: this.context });
    this._internalChannels = [];
    const options = optionsFromArguments(_EQ3.getDefaults(), arguments, ["low", "mid", "high"]);
    this.input = this._multibandSplit = new MultibandSplit({
      context: this.context,
      highFrequency: options.highFrequency,
      lowFrequency: options.lowFrequency
    });
    this._lowGain = new Gain({
      context: this.context,
      gain: options.low,
      units: "decibels"
    });
    this._midGain = new Gain({
      context: this.context,
      gain: options.mid,
      units: "decibels"
    });
    this._highGain = new Gain({
      context: this.context,
      gain: options.high,
      units: "decibels"
    });
    this.low = this._lowGain.gain;
    this.mid = this._midGain.gain;
    this.high = this._highGain.gain;
    this.Q = this._multibandSplit.Q;
    this.lowFrequency = this._multibandSplit.lowFrequency;
    this.highFrequency = this._multibandSplit.highFrequency;
    this._multibandSplit.low.chain(this._lowGain, this.output);
    this._multibandSplit.mid.chain(this._midGain, this.output);
    this._multibandSplit.high.chain(this._highGain, this.output);
    readOnly(this, ["low", "mid", "high", "lowFrequency", "highFrequency"]);
    this._internalChannels = [this._multibandSplit];
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      high: 0,
      highFrequency: 2500,
      low: 0,
      lowFrequency: 400,
      mid: 0
    });
  }
  /**
   * Clean up.
   */
  dispose() {
    super.dispose();
    writable(this, ["low", "mid", "high", "lowFrequency", "highFrequency"]);
    this._multibandSplit.dispose();
    this.lowFrequency.dispose();
    this.highFrequency.dispose();
    this._lowGain.dispose();
    this._midGain.dispose();
    this._highGain.dispose();
    this.low.dispose();
    this.mid.dispose();
    this.high.dispose();
    this.Q.dispose();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/component/filter/Convolver.js
var Convolver = class _Convolver extends ToneAudioNode {
  constructor() {
    super(optionsFromArguments(_Convolver.getDefaults(), arguments, ["url", "onload"]));
    this.name = "Convolver";
    this._convolver = this.context.createConvolver();
    const options = optionsFromArguments(_Convolver.getDefaults(), arguments, ["url", "onload"]);
    this._buffer = new ToneAudioBuffer(options.url, (buffer2) => {
      this.buffer = buffer2;
      options.onload();
    });
    this.input = new Gain({ context: this.context });
    this.output = new Gain({ context: this.context });
    if (this._buffer.loaded) {
      this.buffer = this._buffer;
    }
    this.normalize = options.normalize;
    this.input.chain(this._convolver, this.output);
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      normalize: true,
      onload: noOp
    });
  }
  /**
   * Load an impulse response url as an audio buffer.
   * Decodes the audio asynchronously and invokes
   * the callback once the audio buffer loads.
   * @param url The url of the buffer to load. filetype support depends on the browser.
   */
  load(url) {
    return __awaiter(this, void 0, void 0, function* () {
      this.buffer = yield this._buffer.load(url);
    });
  }
  /**
   * The convolver's buffer
   */
  get buffer() {
    if (this._buffer.length) {
      return this._buffer;
    } else {
      return null;
    }
  }
  set buffer(buffer2) {
    if (buffer2) {
      this._buffer.set(buffer2);
    }
    if (this._convolver.buffer) {
      this.input.disconnect();
      this._convolver.disconnect();
      this._convolver = this.context.createConvolver();
      this.input.chain(this._convolver, this.output);
    }
    const buff = this._buffer.get();
    this._convolver.buffer = buff ? buff : null;
  }
  /**
   * The normalize property of the ConvolverNode interface is a boolean that
   * controls whether the impulse response from the buffer will be scaled by
   * an equal-power normalization when the buffer attribute is set, or not.
   */
  get normalize() {
    return this._convolver.normalize;
  }
  set normalize(norm) {
    this._convolver.normalize = norm;
  }
  dispose() {
    super.dispose();
    this._buffer.dispose();
    this._convolver.disconnect();
    return this;
  }
};

// node_modules/@magenta/music/node_modules/tone/build/esm/index.js
function now2() {
  return getContext().now();
}
function immediate() {
  return getContext().immediate();
}
var Transport = getContext().transport;
function getTransport() {
  return getContext().transport;
}
var Destination = getContext().destination;
var Master = getContext().destination;
function getDestination() {
  return getContext().destination;
}
var Listener = getContext().listener;
function getListener() {
  return getContext().listener;
}
var Draw = getContext().draw;
function getDraw() {
  return getContext().draw;
}
var context = getContext();
function loaded() {
  return ToneAudioBuffer.loaded();
}
var Buffer = ToneAudioBuffer;
var Buffers = ToneAudioBuffers;
var BufferSource = ToneBufferSource;

// node_modules/@magenta/music/esm/core/metronome.js
var QUARTERS_PER_BAR = 4;
var MetronomeCallbackObject = class {
};
var Metronome = class {
  constructor(callbackObject, clicksPerQuarter = 1) {
    this.clicksPerQuarter = 1;
    this.muted = false;
    this.loClick = new MembraneSynth({
      pitchDecay: 8e-3,
      envelope: { attack: 1e-3, decay: 0.3, sustain: 0 }
    }).toDestination();
    this.hiClick = new MembraneSynth({
      pitchDecay: 8e-3,
      envelope: { attack: 1e-3, decay: 0.3, sustain: 0 }
    }).toDestination();
    this.loClickNote = "c5";
    this.hiClickNote = "g5";
    this.ticking = false;
    this.startedAt = null;
    this.step = -1;
    this.reset();
    this.callbackObject = callbackObject;
    this.clicksPerQuarter = clicksPerQuarter;
  }
  isTicking() {
    return this.ticking;
  }
  getStartedAt() {
    return this.startedAt;
  }
  getOffsetTime() {
    return immediate() - this.startedAt;
  }
  start(bpm = 120) {
    this.reset();
    this.ticking = true;
    if (!this.callbackObject.click) {
      this.callbackObject.click = () => {
      };
    }
    if (!this.callbackObject.quarter) {
      this.callbackObject.quarter = () => {
      };
    }
    if (!this.callbackObject.bar) {
      this.callbackObject.bar = () => {
      };
    }
    let bar = 0;
    const clicksInBar = QUARTERS_PER_BAR * this.clicksPerQuarter;
    Transport.scheduleRepeat((time2) => {
      if (!this.startedAt) {
        this.startedAt = time2;
      }
      const offsetTime = time2 - this.startedAt;
      this.step++;
      const clickInBar = this.step % clicksInBar;
      const clickInQuarter = Math.floor(clickInBar / this.clicksPerQuarter);
      const quarter = clickInBar % this.clicksPerQuarter;
      this.callbackObject.click(offsetTime, clickInBar);
      if (quarter === 0) {
        this.callbackObject.quarter(offsetTime, clickInQuarter);
      }
      if (!this.muted) {
        if (clickInBar === 0) {
          this.hiClick.triggerAttack(this.hiClickNote, time2, 0.1);
        } else {
          this.loClick.triggerAttack(this.loClickNote, time2, 0.1);
        }
      }
      if (clickInBar === 0) {
        this.callbackObject.bar(offsetTime, bar);
        bar++;
      }
    }, `${clicksInBar}n`);
    Transport.bpm.value = bpm;
    Transport.start();
  }
  stop() {
    this.ticking = false;
    Transport.cancel();
    Transport.stop();
  }
  reset() {
    this.muted = false;
    this.ticking = false;
    this.step = -1;
    this.startedAt = null;
  }
};

// node_modules/@magenta/music/esm/core/midi_io.js
var import_midi = __toESM(require_Midi());
var MidiConversionError = class extends Error {
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, new.target.prototype);
  }
};
function midiToSequenceProto(midi) {
  const parsedMidi = new import_midi.Midi(midi);
  const ns = NoteSequence.create();
  ns.ticksPerQuarter = parsedMidi.header.ppq;
  ns.sourceInfo = NoteSequence.SourceInfo.create({
    parser: NoteSequence.SourceInfo.Parser.TONEJS_MIDI_CONVERT,
    encodingType: NoteSequence.SourceInfo.EncodingType.MIDI
  });
  for (const ts of parsedMidi.header.timeSignatures) {
    ns.timeSignatures.push(NoteSequence.TimeSignature.create({
      time: parsedMidi.header.ticksToSeconds(ts.ticks),
      numerator: ts.timeSignature[0],
      denominator: ts.timeSignature[1]
    }));
  }
  if (!ns.timeSignatures.length) {
    ns.timeSignatures.push(NoteSequence.TimeSignature.create({
      time: 0,
      numerator: 4,
      denominator: 4
    }));
  }
  for (const tempo of parsedMidi.header.tempos) {
    ns.tempos.push(NoteSequence.Tempo.create({
      time: tempo.time,
      qpm: tempo.bpm
    }));
  }
  let instrumentNumber = -1;
  for (const track of parsedMidi.tracks) {
    if (track.notes.length > 0) {
      instrumentNumber += 1;
    }
    for (const note of track.notes) {
      const startTime = note.time;
      const duration = note.duration;
      const endTime = startTime + duration;
      ns.notes.push(NoteSequence.Note.create({
        instrument: instrumentNumber,
        program: track.instrument.number,
        startTime,
        endTime,
        pitch: note.midi,
        velocity: Math.floor(note.velocity * MIDI_VELOCITIES),
        isDrum: track.instrument.percussion
      }));
      if (endTime > ns.totalTime) {
        ns.totalTime = endTime;
      }
    }
    const controlChangeValues = Object.values(track.controlChanges);
    const flattenedControlChangeValues = [].concat.apply([], controlChangeValues);
    for (const controlChange of flattenedControlChangeValues) {
      ns.controlChanges.push(NoteSequence.ControlChange.create({
        time: controlChange.time,
        controlNumber: controlChange.number,
        controlValue: Math.floor(controlChange.value * (MIDI_VELOCITIES - 1)),
        instrument: instrumentNumber,
        program: track.instrument.number,
        isDrum: track.instrument.percussion
      }));
    }
  }
  return ns;
}
function sequenceProtoToMidi(ns) {
  if (isQuantizedSequence(ns)) {
    ns = unquantizeSequence(ns);
  }
  const midi = new import_midi.Midi();
  midi.fromJSON({
    header: {
      name: "",
      ppq: ns.ticksPerQuarter || DEFAULT_TICKS_PER_QUARTER,
      tempos: [],
      timeSignatures: [],
      keySignatures: [],
      meta: []
    },
    tracks: []
  });
  const tempos = Array.from(ns.tempos || []);
  if (tempos.length === 0) {
    tempos.push({ time: 0, qpm: DEFAULT_QUARTERS_PER_MINUTE });
  }
  tempos.sort((a, b) => a.time - b.time);
  for (const tempo of tempos) {
    midi.header.tempos.push({
      ticks: midi.header.secondsToTicks(tempo.time),
      bpm: tempo.qpm
    });
    midi.header.update();
  }
  if (!ns.timeSignatures || ns.timeSignatures.length === 0) {
    midi.header.timeSignatures.push({ ticks: 0, timeSignature: [4, 4] });
  } else {
    for (const ts of ns.timeSignatures) {
      midi.header.timeSignatures.push({
        ticks: midi.header.secondsToTicks(ts.time),
        timeSignature: [ts.numerator, ts.denominator]
      });
    }
  }
  midi.header.update();
  const tracks = /* @__PURE__ */ new Map();
  for (const note of ns.notes) {
    const instrument = note.instrument ? note.instrument : 0;
    const program = note.program === void 0 ? DEFAULT_PROGRAM : note.program;
    const isDrum = !!note.isDrum;
    const key = JSON.stringify([instrument, program, isDrum]);
    if (!tracks.has(key)) {
      tracks.set(key, { notes: [], controlChanges: [] });
    }
    tracks.get(key).notes.push(note);
  }
  for (const controlChange of ns.controlChanges) {
    const instrument = controlChange.instrument ? controlChange.instrument : 0;
    const program = controlChange.program === void 0 ? DEFAULT_PROGRAM : controlChange.program;
    const isDrum = !!controlChange.isDrum;
    const key = JSON.stringify([instrument, program, isDrum]);
    if (!tracks.has(key)) {
      tracks.set(key, { notes: [], controlChanges: [] });
    }
    tracks.get(key).controlChanges.push(controlChange);
  }
  tracks.forEach((trackData, key) => {
    const [program, isDrum] = JSON.parse(key).slice(1);
    const track = midi.addTrack();
    if (isDrum) {
      track.channel = DRUM_CHANNEL;
    } else {
      track.channel = NON_DRUM_CHANNELS[(midi.tracks.length - 1) % NON_DRUM_CHANNELS.length];
    }
    track.instrument.number = program;
    for (const note of trackData.notes) {
      const velocity = note.velocity === void 0 ? DEFAULT_VELOCITY : note.velocity;
      track.addNote({
        midi: note.pitch,
        time: note.startTime,
        duration: note.endTime - note.startTime,
        velocity: (velocity + 1) / MIDI_VELOCITIES
      });
    }
    for (const controlChange of trackData.controlChanges) {
      track.addCC({
        number: controlChange.controlNumber,
        value: controlChange.controlValue,
        time: controlChange.time
      });
    }
  });
  return midi.toArray();
}
function urlToBlob(url) {
  return new Promise((resolve, reject) => {
    fetch3(url).then((response) => {
      return response.blob();
    }).then((blob) => {
      resolve(blob);
    }).catch((error) => reject(error));
  });
}
function blobToNoteSequence(blob) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const ns = midiToSequenceProto(reader.result);
        resolve(ns);
      } catch (error) {
        reject(error);
      }
    };
    reader.onerror = (e) => reject(e);
    reader.readAsArrayBuffer(blob);
  });
}
function urlToNoteSequence(url) {
  return urlToBlob(url).then(blobToNoteSequence);
}

// node_modules/@magenta/music/esm/core/soundfont.js
var Instrument2 = class {
  constructor(baseURL) {
    this.FADE_SECONDS = 0.1;
    this.baseURL = baseURL;
    this.buffers = new ToneAudioBuffers();
    this.sourceMap = /* @__PURE__ */ new Map();
    this.initialized = false;
  }
  async initialize() {
    await fetch3(`${this.baseURL}/instrument.json`).then((response) => response.json()).then((spec) => {
      this.name = spec.name;
      this.minPitch = spec.minPitch;
      this.maxPitch = spec.maxPitch;
      this.durationSeconds = spec.durationSeconds;
      this.releaseSeconds = spec.releaseSeconds;
      this.percussive = spec.percussive;
      this.velocities = spec.velocities;
      this.initialized = true;
    });
  }
  sampleInfoToName(sampleInfo) {
    if (this.velocities) {
      return `p${sampleInfo.pitch}_v${sampleInfo.velocity}`;
    } else {
      return `p${sampleInfo.pitch}`;
    }
  }
  sampleNameToURL(name) {
    return `${this.baseURL}/${name}.mp3`;
  }
  nearestVelocity(velocity) {
    if (!this.velocities) {
      return velocity;
    }
    if (!velocity) {
      velocity = DEFAULT_VELOCITY;
    }
    let bestVelocity = void 0;
    let bestDistance = MIDI_VELOCITIES;
    this.velocities.forEach((v) => {
      const d = Math.abs(v - velocity);
      if (d < bestDistance) {
        bestVelocity = v;
        bestDistance = d;
      }
    });
    return bestVelocity;
  }
  async loadSamples(samples) {
    if (!this.initialized) {
      await this.initialize();
    }
    const nearestSampleNames = samples.filter((info) => {
      if (info.pitch < this.minPitch || info.pitch > this.maxPitch) {
        log2(`Pitch ${info.pitch} is outside the valid range for ${this.name}, ignoring.`, "SoundFont");
        return false;
      } else {
        return true;
      }
    }).map((info) => this.sampleInfoToName({
      pitch: info.pitch,
      velocity: this.nearestVelocity(info.velocity)
    }));
    const uniqueSampleNames = Array.from(new Set(nearestSampleNames)).filter((name) => !this.buffers.has(name));
    const sampleNamesAndURLs = uniqueSampleNames.map((name) => ({ name, url: this.sampleNameToURL(name) }));
    if (sampleNamesAndURLs.length > 0) {
      sampleNamesAndURLs.forEach((nameAndURL) => this.buffers.add(nameAndURL.name, nameAndURL.url));
      await loaded();
      log2(`Loaded samples for ${this.name}.`, "SoundFont");
    }
  }
  playNote(pitch, velocity, startTime, duration, output) {
    const buffer2 = this.getBuffer(pitch, velocity);
    if (!buffer2) {
      return;
    }
    if (duration > this.durationSeconds) {
      log2(`Requested note duration longer than sample duration: ${duration} > ${this.durationSeconds}`, "SoundFont");
    }
    const source = new ToneBufferSource({
      url: buffer2,
      fadeOut: this.FADE_SECONDS
    }).connect(output);
    source.start(startTime, 0, void 0, 1);
    if (!this.percussive && duration < this.durationSeconds) {
      const releaseSource = new ToneBufferSource({
        url: buffer2,
        fadeOut: this.FADE_SECONDS
      }).connect(output);
      source.stop(startTime + duration + this.FADE_SECONDS);
      releaseSource.start(startTime + duration, this.durationSeconds, void 0, 1);
    }
  }
  playNoteDown(pitch, velocity, output) {
    const buffer2 = this.getBuffer(pitch, velocity);
    if (!buffer2) {
      return;
    }
    const source = new ToneBufferSource(buffer2).connect(output);
    source.start(0, 0, void 0, 1);
    if (this.sourceMap.has(pitch)) {
      this.sourceMap.get(pitch).stop(now2() + this.FADE_SECONDS, this.FADE_SECONDS);
    }
    this.sourceMap.set(pitch, source);
  }
  playNoteUp(pitch, velocity, output) {
    if (!this.sourceMap.has(pitch)) {
      return;
    }
    const buffer2 = this.getBuffer(pitch, velocity);
    if (!buffer2) {
      return;
    }
    const releaseSource = new ToneBufferSource({
      url: buffer2,
      fadeOut: this.FADE_SECONDS
    }).connect(output);
    releaseSource.start(0, this.durationSeconds, void 0, 1);
    this.sourceMap.get(pitch).stop(now2() + this.FADE_SECONDS, this.FADE_SECONDS);
    this.sourceMap.delete(pitch);
  }
  getBuffer(pitch, velocity) {
    if (!this.initialized) {
      throw new Error("Instrument is not initialized.");
    }
    if (pitch < this.minPitch || pitch > this.maxPitch) {
      log2(`Pitch ${pitch} is outside the valid range for ${this.name} (${this.minPitch}-${this.maxPitch})`, "SoundFont");
      return;
    }
    const name = this.sampleInfoToName({ pitch, velocity: this.nearestVelocity(velocity) });
    if (!this.buffers.has(name)) {
      throw new Error(`Buffer not found for ${this.name}: ${name}`);
    }
    const buffer2 = this.buffers.get(name);
    if (!buffer2.loaded) {
      throw new Error(`Buffer not loaded for ${this.name}: ${name}`);
    }
    return buffer2;
  }
};
var SoundFont = class {
  constructor(baseURL) {
    this.baseURL = baseURL;
    this.instruments = /* @__PURE__ */ new Map();
    this.initialized = false;
  }
  async initialize() {
    await fetch3(`${this.baseURL}/soundfont.json`).then((response) => response.json()).then((spec) => {
      this.name = spec.name;
      for (const program in spec.instruments) {
        const url = `${this.baseURL}/${spec.instruments[program]}`;
        this.instruments.set(program === "drums" ? "drums" : +program, new Instrument2(url));
      }
      this.initialized = true;
    });
  }
  async loadSamples(samples) {
    if (!this.initialized) {
      await this.initialize();
    }
    const instrumentSamples = /* @__PURE__ */ new Map();
    samples.forEach((info) => {
      info.isDrum = info.isDrum || false;
      info.program = info.program || 0;
      const instrument = info.isDrum ? "drums" : info.program;
      const sampleInfo = { pitch: info.pitch, velocity: info.velocity };
      if (!instrumentSamples.has(instrument)) {
        if (!this.instruments.has(instrument)) {
          log2(`No instrument in ${this.name} for: program=${info.program}, isDrum=${info.isDrum}`, "SoundFont");
        } else {
          instrumentSamples.set(instrument, [sampleInfo]);
        }
      } else {
        instrumentSamples.get(instrument).push(sampleInfo);
      }
    });
    await Promise.all(Array.from(instrumentSamples.keys()).map((info) => this.instruments.get(info).loadSamples(instrumentSamples.get(info))));
  }
  playNote(pitch, velocity, startTime, duration, program = 0, isDrum = false, output) {
    const instrument = isDrum ? "drums" : program;
    if (!this.initialized) {
      throw new Error("SoundFont is not initialized.");
    }
    if (!this.instruments.has(instrument)) {
      log2(`No instrument in ${this.name} for: program=${program}, isDrum=${isDrum}`, "SoundFont");
      return;
    }
    this.instruments.get(instrument).playNote(pitch, velocity, startTime, duration, output);
  }
  playNoteDown(pitch, velocity, program = 0, isDrum = false, output) {
    const instrument = isDrum ? "drums" : program;
    if (!this.initialized) {
      throw new Error("SoundFont is not initialized.");
    }
    if (!this.instruments.has(instrument)) {
      log2(`No instrument in ${this.name} for: program=${program}, isDrum=${isDrum}`, "SoundFont");
      return;
    }
    this.instruments.get(instrument).playNoteDown(pitch, velocity, output);
  }
  playNoteUp(pitch, velocity, program = 0, isDrum = false, output) {
    const instrument = isDrum ? "drums" : program;
    if (!this.initialized) {
      throw new Error("SoundFont is not initialized.");
    }
    if (!this.instruments.has(instrument)) {
      log2(`No instrument in ${this.name} for: program=${program}, isDrum=${isDrum}`, "SoundFont");
      return;
    }
    this.instruments.get(instrument).playNoteUp(pitch, velocity, output);
  }
};

// node_modules/@magenta/music/esm/core/player.js
function compareQuantizedNotes(a, b) {
  if (a.quantizedStartStep < b.quantizedStartStep) {
    return -1;
  }
  if (a.quantizedStartStep > b.quantizedStartStep) {
    return 1;
  }
  if (a.pitch < b.pitch) {
    return -1;
  }
  return 1;
}
var BasePlayerCallback = class {
};
var BasePlayer = class {
  constructor(playClick = false, callbackObject) {
    this.playClick = playClick;
    this.callbackObject = callbackObject;
    this.desiredQPM = void 0;
  }
  setTempo(qpm) {
    this.desiredQPM = qpm;
    if (Transport.state === "started") {
      Transport.bpm.value = qpm;
    }
  }
  makeClickSequence(seq) {
    const clickSeq = clone(seq);
    const sixteenthEnds = clickSeq.notes.map((n) => n.quantizedEndStep);
    const lastSixteenth = Math.max(...sixteenthEnds);
    for (let i = 0; i < lastSixteenth; i += 4) {
      const click = {
        pitch: i % 16 === 0 ? LO_CLICK_PITCH : HI_CLICK_PITCH,
        quantizedStartStep: i,
        isDrum: true,
        quantizedEndStep: i + 1
      };
      clickSeq.notes.push(click);
    }
    clickSeq.notes.sort(compareQuantizedNotes);
    return clickSeq;
  }
  resumeContext() {
    context.resume();
  }
  start(seq, qpm, offset = 0) {
    if (this.getPlayState() === "started") {
      throw new Error("Cannot start playback; player is already playing.");
    } else if (this.getPlayState() === "paused") {
      throw new Error("Cannot `start()` a paused player; use `resume()`.");
    }
    if (Transport.state !== "stopped") {
      throw new Error("Cannot start playback while `Tone.Transport` is in use.");
    }
    this.resumeContext();
    const isQuantized = isQuantizedSequence(seq);
    if (this.playClick && isQuantized) {
      seq = this.makeClickSequence(seq);
    }
    if (qpm) {
      Transport.bpm.value = qpm;
    } else if (seq.tempos && seq.tempos.length > 0 && seq.tempos[0].qpm > 0) {
      Transport.bpm.value = seq.tempos[0].qpm;
    } else {
      Transport.bpm.value = DEFAULT_QUARTERS_PER_MINUTE;
    }
    if (isQuantized) {
      seq = unquantizeSequence(seq, qpm);
    } else if (qpm) {
      throw new Error("Cannot specify a `qpm` for a non-quantized sequence.");
    }
    const thisPart = new Part((t, n) => {
      if (this.currentPart !== thisPart) {
        return;
      }
      this.playNote(t, n);
      if (this.callbackObject) {
        Draw.schedule(() => {
          this.callbackObject.run(n, t);
        }, t);
      }
    }, seq.notes.map((n) => [n.startTime, n]));
    this.currentPart = thisPart;
    if (this.desiredQPM) {
      Transport.bpm.value = this.desiredQPM;
    }
    this.currentPart.start(void 0, offset);
    if (Transport.state !== "started") {
      Transport.start();
    }
    return new Promise((resolve) => {
      this.scheduledStop = Transport.schedule(() => {
        this.stop();
        resolve();
        if (this.callbackObject) {
          this.callbackObject.stop();
        }
      }, `+${seq.totalTime}`);
    });
  }
  stop() {
    if (this.isPlaying()) {
      this.currentPart.stop();
      Transport.stop();
      this.currentPart = null;
    }
    Transport.clear(this.scheduledStop);
    this.scheduledStop = void 0;
    this.desiredQPM = void 0;
  }
  pause() {
    if (!this.isPlaying()) {
      throw new Error("Cannot pause playback while the player is stopped.");
    }
    Transport.pause();
  }
  resume() {
    if (this.getPlayState() !== "paused") {
      throw new Error(`Cannot resume playback while "${this.getPlayState()}".`);
    }
    Transport.start();
  }
  seekTo(seconds) {
    if (!this.isPlaying()) {
      throw new Error("Cannot seek while the player is stopped.");
    }
    Transport.seconds = seconds;
  }
  isPlaying() {
    return !!this.currentPart;
  }
  getPlayState() {
    return this.isPlaying() ? Transport.state : "stopped";
  }
};
var DrumKit = class _DrumKit {
  constructor() {
    this.DRUM_PITCH_TO_CLASS = /* @__PURE__ */ new Map();
    this.kick = new MembraneSynth().toDestination();
    this.tomLow = new MembraneSynth({
      pitchDecay: 8e-3,
      envelope: { attack: 0.01, decay: 0.5, sustain: 0 }
    }).toDestination();
    this.tomMid = new MembraneSynth({
      pitchDecay: 8e-3,
      envelope: { attack: 0.01, decay: 0.5, sustain: 0 }
    }).toDestination();
    this.tomHigh = new MembraneSynth({
      pitchDecay: 8e-3,
      envelope: { attack: 0.01, decay: 0.5, sustain: 0 }
    }).toDestination();
    this.closedHihat = new MetalSynth({
      frequency: 400,
      envelope: { attack: 1e-3, decay: 0.1, release: 0.8 },
      harmonicity: 5.1,
      modulationIndex: 32,
      resonance: 4e3,
      octaves: 1
    }).toDestination();
    this.openHihat = new MetalSynth({
      frequency: 400,
      envelope: { attack: 1e-3, decay: 0.5, release: 0.8, sustain: 1 },
      harmonicity: 5.1,
      modulationIndex: 32,
      resonance: 4e3,
      octaves: 1
    }).toDestination();
    this.ride = new MetalSynth().toDestination();
    this.crash = new MetalSynth({
      frequency: 300,
      envelope: { attack: 1e-3, decay: 1, release: 3 },
      harmonicity: 5.1,
      modulationIndex: 64,
      resonance: 4e3,
      octaves: 1.5
    }).toDestination();
    this.snare = new NoiseSynth({
      noise: { type: "white" },
      envelope: { attack: 5e-3, decay: 0.05, sustain: 0.1, release: 0.4 }
    }).toDestination();
    this.loClick = new MembraneSynth({
      pitchDecay: 8e-3,
      envelope: { attack: 1e-3, decay: 0.3, sustain: 0 }
    }).toDestination();
    this.hiClick = new MembraneSynth({
      pitchDecay: 8e-3,
      envelope: { attack: 1e-3, decay: 0.3, sustain: 0 }
    }).toDestination();
    this.pitchPlayers = [
      (time2, velocity = 1) => this.kick.triggerAttackRelease("C2", "8n", time2, velocity),
      (time2, velocity = 1) => this.snare.triggerAttackRelease("16n", time2, velocity),
      (time2, velocity = 1) => this.closedHihat.triggerAttack(time2, 0.3, velocity),
      (time2, velocity = 1) => this.openHihat.triggerAttack(time2, 0.3, velocity),
      (time2, velocity = 0.5) => this.tomLow.triggerAttack("G3", time2, velocity),
      (time2, velocity = 0.5) => this.tomMid.triggerAttack("C4", time2, velocity),
      (time2, velocity = 0.5) => this.tomHigh.triggerAttack("F4", time2, velocity),
      (time2, velocity = 1) => this.crash.triggerAttack(time2, 1, velocity),
      (time2, velocity = 1) => this.ride.triggerAttack(time2, 0.5, velocity),
      (time2, velocity = 0.5) => this.loClick.triggerAttack("G5", time2, velocity),
      (time2, velocity = 0.5) => this.hiClick.triggerAttack("C6", time2, velocity)
    ];
    for (let c = 0; c < DEFAULT_DRUM_PITCH_CLASSES.length; ++c) {
      DEFAULT_DRUM_PITCH_CLASSES[c].forEach((p) => {
        this.DRUM_PITCH_TO_CLASS.set(p, c);
      });
    }
    this.DRUM_PITCH_TO_CLASS.set(LO_CLICK_PITCH, LO_CLICK_CLASS);
    this.DRUM_PITCH_TO_CLASS.set(HI_CLICK_PITCH, HI_CLICK_CLASS);
  }
  static getInstance() {
    if (!_DrumKit.instance) {
      _DrumKit.instance = new _DrumKit();
    }
    return _DrumKit.instance;
  }
  playNote(pitch, time2, velocity) {
    this.pitchPlayers[this.DRUM_PITCH_TO_CLASS.get(pitch)](time2, velocity);
  }
};
var Player2 = class extends BasePlayer {
  constructor() {
    super(...arguments);
    this.drumKit = DrumKit.getInstance();
    this.bassSynth = new Synth({
      volume: 5,
      oscillator: { type: "triangle" }
    }).toDestination();
    this.polySynth = new PolySynth().toDestination();
  }
  playNote(time2, note) {
    const velocity = note.hasOwnProperty("velocity") ? note.velocity / MAX_MIDI_VELOCITY : void 0;
    if (note.isDrum) {
      this.drumKit.playNote(note.pitch, time2, velocity);
    } else {
      const freq = Frequency(note.pitch, "midi").toFrequency();
      const dur = note.endTime - note.startTime;
      this.getSynth(note.instrument, note.program).triggerAttackRelease(freq, dur, time2, velocity);
    }
  }
  getSynth(instrument, program) {
    if (program !== void 0 && program >= 32 && program <= 39) {
      return this.bassSynth;
    } else {
      return this.polySynth;
    }
  }
};
Player2.tone = esm_exports;
var SoundFontPlayer = class extends BasePlayer {
  constructor(soundFontURL, output = Master, programOutputs, drumOutputs, callbackObject) {
    super(false, callbackObject);
    this.soundFont = new SoundFont(soundFontURL);
    this.output = output;
    this.programOutputs = programOutputs;
    this.drumOutputs = drumOutputs;
  }
  async loadSamples(seq) {
    await this.soundFont.loadSamples(seq.notes.map((note) => ({
      pitch: note.pitch,
      velocity: note.velocity,
      program: note.program || 0,
      isDrum: note.isDrum || false
    })));
  }
  async loadAllSamples(program = 0, isDrum = false) {
    const ns = NoteSequence.create();
    const min2 = isDrum ? MIN_DRUM_PITCH : MIN_PIANO_PITCH;
    const max2 = isDrum ? MAX_DRUM_PITCH : MAX_PIANO_PITCH;
    for (let i = min2; i <= max2; i++) {
      for (let j = MIN_MIDI_VELOCITY; j < MAX_MIDI_VELOCITY; j++) {
        ns.notes.push({ pitch: i, velocity: j, program, isDrum });
      }
    }
    return this.loadSamples(ns);
  }
  resumeContext() {
    context.resume();
  }
  start(seq, qpm, offset = 0) {
    this.resumeContext();
    return this.loadSamples(seq).then(() => super.start(seq, qpm, offset));
  }
  playNote(time2, note) {
    this.soundFont.playNote(note.pitch, note.velocity, time2, note.endTime - note.startTime, note.program, note.isDrum, this.getAudioNodeOutput(note));
  }
  playNoteDown(note) {
    this.soundFont.playNoteDown(note.pitch, note.velocity, note.program, note.isDrum, this.getAudioNodeOutput(note));
  }
  playNoteUp(note) {
    this.soundFont.playNoteUp(note.pitch, note.velocity, note.program, note.isDrum, this.getAudioNodeOutput(note));
  }
  getAudioNodeOutput(note) {
    let output = this.output;
    if (this.programOutputs && !note.isDrum) {
      if (this.programOutputs.has(note.program)) {
        output = this.programOutputs.get(note.program);
      }
    } else if (this.drumOutputs && note.isDrum) {
      if (this.drumOutputs.has(note.pitch)) {
        output = this.drumOutputs.get(note.pitch);
      }
    }
    return output;
  }
};
var PlayerWithClick = class extends Player2 {
  constructor(callbackObject) {
    super(true, callbackObject);
  }
};
var MIDIPlayer = class extends BasePlayer {
  constructor(callbackObject) {
    super(false, callbackObject);
    this.outputs = [];
    this.outputChannel = 0;
    this.availableOutputs = [];
    this.NOTE_ON = 144;
    this.NOTE_OFF = 128;
  }
  async requestMIDIAccess() {
    if (navigator.requestMIDIAccess) {
      return new Promise((resolve, reject) => {
        navigator.requestMIDIAccess().then((midi) => {
          midi.addEventListener("statechange", (event) => this.initOutputs(midi));
          resolve(this.initOutputs(midi));
        }, (err) => console.log("Something went wrong", reject(err)));
      });
    } else {
      return null;
    }
  }
  initOutputs(midi) {
    const outputs = midi.outputs.values();
    for (let output = outputs.next(); output && !output.done; output = outputs.next()) {
      this.availableOutputs.push(output.value);
    }
    return this.availableOutputs;
  }
  playNote(time2, note) {
    const velocity = note.velocity || 100;
    const length = (note.endTime - note.startTime) * 1e3;
    const msgOn = [this.NOTE_ON + this.outputChannel, note.pitch, velocity];
    const msgOff = [this.NOTE_OFF + this.outputChannel, note.pitch, velocity];
    const outputs = this.outputs ? this.outputs : this.availableOutputs;
    for (let i = 0; i < outputs.length; i++) {
      this.sendMessageToOutput(outputs[i], msgOn);
      this.sendMessageToOutput(outputs[i], msgOff, performance2.now() + length);
    }
  }
  sendMessageToOutput(output, message, time2) {
    if (output) {
      output.send(message, time2);
    }
  }
  playNoteDown(note) {
    const msgOn = [this.NOTE_ON, note.pitch, note.velocity];
    const outputs = this.outputs ? this.outputs : this.availableOutputs;
    for (let i = 0; i < outputs.length; i++) {
      this.sendMessageToOutput(outputs[i], msgOn);
    }
  }
  playNoteUp(note) {
    const msgOff = [this.NOTE_OFF, note.pitch, note.velocity];
    const outputs = this.outputs ? this.outputs : this.availableOutputs;
    for (let i = 0; i < outputs.length; i++) {
      this.sendMessageToOutput(outputs[i], msgOff, note.endTime - note.startTime);
    }
  }
};

// node_modules/@magenta/music/esm/core/recorder.js
var BaseRecorderCallback = class {
};
var Recorder2 = class {
  constructor(config = {}, callbackObject) {
    this.notes = [];
    this.midiInputs = [];
    this.loClick = new MembraneSynth({
      pitchDecay: 8e-3,
      envelope: { attack: 1e-3, decay: 0.3, sustain: 0 }
    }).toDestination();
    this.hiClick = new MembraneSynth({
      pitchDecay: 8e-3,
      envelope: { attack: 1e-3, decay: 0.3, sustain: 0 }
    }).toDestination();
    this.config = {
      playClick: config.playClick,
      qpm: config.qpm || DEFAULT_QUARTERS_PER_MINUTE,
      playCountIn: config.playCountIn,
      startRecordingAtFirstNote: config.startRecordingAtFirstNote || false
    };
    this.callbackObject = callbackObject;
    this.recording = false;
    this.onNotes = /* @__PURE__ */ new Map();
  }
  async initialize() {
    await navigator.requestMIDIAccess().then((midi) => this.midiReady(midi), (err) => console.log("Something went wrong", err));
  }
  midiReady(midi) {
    log2("Initialized Recorder", "Recorder");
    const inputs = midi.inputs.values();
    for (let input2 = inputs.next(); input2 && !input2.done; input2 = inputs.next()) {
      this.midiInputs.push(input2.value);
    }
  }
  isRecording() {
    return this.recording;
  }
  setTempo(qpm) {
    this.config.qpm = qpm;
    if (Transport.state === "started") {
      Transport.bpm.value = qpm;
    }
  }
  enablePlayClick(playClick) {
    this.config.playClick = playClick;
  }
  enablePlayCountIn(countIn) {
    this.config.playCountIn = countIn;
  }
  initClickLoop() {
    let clickStep = 0;
    this.clickLoop = new Loop((time2) => {
      if (clickStep % 4 === 0) {
        this.loClick.triggerAttack("G5", time2);
      } else {
        this.hiClick.triggerAttack("C6", time2);
      }
      clickStep++;
      if (this.config.playCountIn && clickStep === 4) {
        Transport.stop();
        this.clickLoop.stop();
      }
    }, "4n");
  }
  getMIDIInputs() {
    return this.midiInputs;
  }
  start(midiInputs) {
    const list = midiInputs ? midiInputs : this.midiInputs;
    for (const input2 of list) {
      input2.onmidimessage = (event) => {
        this.midiMessageReceived(event);
      };
    }
    if (this.config.playClick || this.config.playCountIn) {
      this.initClickLoop();
      Transport.bpm.value = this.config.qpm;
      Transport.start();
      this.clickLoop.start();
    } else {
      this.clickLoop = null;
    }
    this.recording = true;
    this.firstNoteTimestamp = void 0;
    this.notes = [];
    this.onNotes = /* @__PURE__ */ new Map();
    if (!this.startRecordingAtFirstNote) {
      const timeStamp = Date.now();
      this.firstNoteTimestamp = timeStamp;
    }
  }
  stop() {
    this.recording = false;
    const timeStamp = Date.now();
    this.onNotes.forEach((pitch, note) => {
      this.noteOff(note, timeStamp);
    });
    for (const input2 of this.midiInputs) {
      input2.onmidimessage = null;
    }
    if (this.clickLoop) {
      Transport.stop();
      this.clickLoop.stop();
    }
    if (this.notes.length === 0) {
      return null;
    }
    return this.getNoteSequence();
  }
  getNoteSequence() {
    if (this.notes.length === 0) {
      return null;
    }
    return NoteSequence.create({
      notes: this.notes,
      totalTime: this.notes[this.notes.length - 1].endTime
    });
  }
  reset() {
    const noteSequence = this.stop();
    this.firstNoteTimestamp = void 0;
    this.notes = [];
    this.onNotes = /* @__PURE__ */ new Map();
    return noteSequence;
  }
  midiMessageReceived(event) {
    if (!this.recording) {
      return;
    }
    let timeStampOffset;
    if (event.timeStamp !== void 0 && event.timeStamp !== 0) {
      timeStampOffset = event.timeStamp;
    } else {
      timeStampOffset = performance2.now();
    }
    const timeStamp = timeStampOffset + performance2.timing.navigationStart;
    if (this.firstNoteTimestamp === void 0) {
      this.firstNoteTimestamp = timeStamp;
    }
    const NOTE_ON = 9;
    const NOTE_OFF2 = 8;
    const cmd = event.data[0] >> 4;
    const pitch = event.data[1];
    const velocity = event.data.length > 2 ? event.data[2] : 1;
    const device = event.srcElement;
    if (cmd === NOTE_OFF2 || cmd === NOTE_ON && velocity === 0) {
      if (this.callbackObject && this.callbackObject.noteOff) {
        this.callbackObject.noteOff(pitch, velocity, device);
      }
      this.noteOff(pitch, timeStamp);
      if (this.callbackObject && this.callbackObject.run) {
        this.callbackObject.run(this.getNoteSequence());
      }
    } else if (cmd === NOTE_ON) {
      if (this.callbackObject && this.callbackObject.noteOn) {
        this.callbackObject.noteOn(pitch, velocity, device);
      }
      this.noteOn(pitch, velocity, timeStamp);
    }
  }
  noteOn(pitch, velocity, timeStamp) {
    const MILLIS_PER_SECOND = 1e3;
    const note = new NoteSequence.Note();
    note.pitch = pitch;
    note.startTime = (timeStamp - this.firstNoteTimestamp) / MILLIS_PER_SECOND;
    note.velocity = velocity;
    this.onNotes.set(pitch, note);
  }
  noteOff(pitch, timeStamp) {
    const MILLIS_PER_SECOND = 1e3;
    const note = this.onNotes.get(pitch);
    if (note) {
      note.endTime = (timeStamp - this.firstNoteTimestamp) / MILLIS_PER_SECOND;
      this.notes.push(note);
    }
    this.onNotes.delete(pitch);
  }
};

// node_modules/@magenta/music/esm/core/visualizer.js
var sr = __toESM(require_es6());
var MIN_NOTE_LENGTH = 1;
var BaseVisualizer = class {
  constructor(sequence, config = {}) {
    const isQuantized = isQuantizedSequence(sequence);
    const qpm = sequence.tempos && sequence.tempos.length > 0 ? sequence.tempos[0].qpm : void 0;
    this.noteSequence = isQuantized ? unquantizeSequence(sequence, qpm) : sequence;
    const defaultPixelsPerTimeStep = 30;
    this.config = {
      noteHeight: config.noteHeight || 6,
      noteSpacing: config.noteSpacing || 1,
      pixelsPerTimeStep: config.pixelsPerTimeStep || defaultPixelsPerTimeStep,
      noteRGB: config.noteRGB || "8, 41, 64",
      activeNoteRGB: config.activeNoteRGB || "240, 84, 119",
      minPitch: config.minPitch,
      maxPitch: config.maxPitch
    };
    const size = this.getSize();
    this.width = size.width;
    this.height = size.height;
  }
  updateMinMaxPitches(noExtraPadding = false) {
    if (this.config.minPitch && this.config.maxPitch) {
      return;
    }
    if (this.config.minPitch === void 0) {
      this.config.minPitch = MAX_MIDI_PITCH;
    }
    if (this.config.maxPitch === void 0) {
      this.config.maxPitch = MIN_MIDI_PITCH;
    }
    for (const note of this.noteSequence.notes) {
      this.config.minPitch = Math.min(note.pitch, this.config.minPitch);
      this.config.maxPitch = Math.max(note.pitch, this.config.maxPitch);
    }
    if (!noExtraPadding) {
      this.config.minPitch -= 2;
      this.config.maxPitch += 2;
    }
  }
  getSize() {
    this.updateMinMaxPitches();
    const height = (this.config.maxPitch - this.config.minPitch) * this.config.noteHeight;
    const endTime = this.noteSequence.totalTime;
    if (!endTime) {
      throw new Error("The sequence you are using with the visualizer does not have a totalQuantizedSteps or totalTime field set, so the visualizer can't be horizontally sized correctly.");
    }
    const width = endTime * this.config.pixelsPerTimeStep;
    return { width, height };
  }
  getNotePosition(note, noteIndex) {
    const duration = this.getNoteEndTime(note) - this.getNoteStartTime(note);
    const x = this.getNoteStartTime(note) * this.config.pixelsPerTimeStep;
    const w = Math.max(this.config.pixelsPerTimeStep * duration - this.config.noteSpacing, MIN_NOTE_LENGTH);
    const y = this.height - (note.pitch - this.config.minPitch) * this.config.noteHeight;
    return { x, y, w, h: this.config.noteHeight };
  }
  scrollIntoViewIfNeeded(scrollIntoView, activeNotePosition) {
    if (scrollIntoView && this.parentElement) {
      const containerWidth = this.parentElement.getBoundingClientRect().width;
      if (activeNotePosition > this.parentElement.scrollLeft + containerWidth) {
        this.parentElement.scrollLeft = activeNotePosition - 20;
      }
    }
  }
  getNoteStartTime(note) {
    return Math.round(note.startTime * 1e8) / 1e8;
  }
  getNoteEndTime(note) {
    return Math.round(note.endTime * 1e8) / 1e8;
  }
  isPaintingActiveNote(note, playedNote) {
    const isPlayedNote = this.getNoteStartTime(note) === this.getNoteStartTime(playedNote);
    const heldDownDuringPlayedNote = this.getNoteStartTime(note) <= this.getNoteStartTime(playedNote) && this.getNoteEndTime(note) >= this.getNoteEndTime(playedNote);
    return isPlayedNote || heldDownDuringPlayedNote;
  }
};
var PianoRollCanvasVisualizer = class extends BaseVisualizer {
  constructor(sequence, canvas, config = {}) {
    super(sequence, config);
    this.ctx = canvas.getContext("2d");
    this.parentElement = canvas.parentElement;
    const dpr = window.devicePixelRatio || 1;
    if (this.ctx) {
      this.ctx.canvas.width = dpr * this.width;
      this.ctx.canvas.height = dpr * this.height;
      canvas.style.width = `${this.width}px`;
      canvas.style.height = `${this.height}px`;
      this.ctx.scale(dpr, dpr);
    }
    this.redraw();
  }
  redraw(activeNote, scrollIntoView) {
    this.clear();
    let activeNotePosition;
    for (let i = 0; i < this.noteSequence.notes.length; i++) {
      const note = this.noteSequence.notes[i];
      const size = this.getNotePosition(note, i);
      const opacityBaseline = 0.2;
      const opacity = note.velocity ? note.velocity / 100 + opacityBaseline : 1;
      const isActive = activeNote && this.isPaintingActiveNote(note, activeNote);
      const fill2 = `rgba(${isActive ? this.config.activeNoteRGB : this.config.noteRGB},
  ${opacity})`;
      this.redrawNote(size.x, size.y, size.w, size.h, fill2);
      if (isActive && note === activeNote) {
        activeNotePosition = size.x;
      }
    }
    this.scrollIntoViewIfNeeded(scrollIntoView, activeNotePosition);
    return activeNotePosition;
  }
  clear() {
    this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
  }
  clearActiveNotes() {
    this.redraw();
  }
  redrawNote(x, y, w, h, fill2) {
    this.ctx.fillStyle = fill2;
    this.ctx.fillRect(Math.round(x), Math.round(y), Math.round(w), Math.round(h));
  }
};
var Visualizer = class extends PianoRollCanvasVisualizer {
  constructor(sequence, canvas, config = {}) {
    super(sequence, canvas, config);
    log2("mm.Visualizer is deprecated, and will be removed in a future          version. Please use mm.PianoRollCanvasVisualizer instead", "mm.Visualizer", 5);
  }
};
var BaseSVGVisualizer = class extends BaseVisualizer {
  constructor(sequence, config = {}) {
    super(sequence, config);
    this.drawn = false;
  }
  redraw(activeNote, scrollIntoView) {
    if (!this.drawn) {
      this.draw();
    }
    if (!activeNote) {
      return null;
    }
    this.unfillActiveRect(this.svg);
    let activeNotePosition;
    for (let i = 0; i < this.noteSequence.notes.length; i++) {
      const note = this.noteSequence.notes[i];
      const isActive = activeNote && this.isPaintingActiveNote(note, activeNote);
      if (!isActive) {
        continue;
      }
      const el = this.svg.querySelector(`rect[data-index="${i}"]`);
      this.fillActiveRect(el, note);
      if (note === activeNote) {
        activeNotePosition = parseFloat(el.getAttribute("x"));
      }
    }
    this.scrollIntoViewIfNeeded(scrollIntoView, activeNotePosition);
    return activeNotePosition;
  }
  fillActiveRect(el, note) {
    el.setAttribute("fill", this.getNoteFillColor(note, true));
    el.classList.add("active");
  }
  unfillActiveRect(svg) {
    const els = svg.querySelectorAll("rect.active");
    for (let i = 0; i < els.length; ++i) {
      const el = els[i];
      const fill2 = this.getNoteFillColor(this.noteSequence.notes[parseInt(el.getAttribute("data-index"), 10)], false);
      el.setAttribute("fill", fill2);
      el.classList.remove("active");
    }
  }
  draw() {
    for (let i = 0; i < this.noteSequence.notes.length; i++) {
      const note = this.noteSequence.notes[i];
      const size = this.getNotePosition(note, i);
      const fill2 = this.getNoteFillColor(note, false);
      const dataAttributes = [
        ["index", i],
        ["instrument", note.instrument],
        ["program", note.program],
        ["isDrum", note.isDrum === true],
        ["pitch", note.pitch]
      ];
      const cssProperties = [
        [
          "--midi-velocity",
          String(note.velocity !== void 0 ? note.velocity : 127)
        ]
      ];
      this.drawNote(size.x, size.y, size.w, size.h, fill2, dataAttributes, cssProperties);
    }
    this.drawn = true;
  }
  getNoteFillColor(note, isActive) {
    const opacityBaseline = 0.2;
    const opacity = note.velocity ? note.velocity / 100 + opacityBaseline : 1;
    const fill2 = `rgba(${isActive ? this.config.activeNoteRGB : this.config.noteRGB},
  ${opacity})`;
    return fill2;
  }
  drawNote(x, y, w, h, fill2, dataAttributes, cssProperties) {
    if (!this.svg) {
      return;
    }
    const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    rect.classList.add("note");
    rect.setAttribute("fill", fill2);
    rect.setAttribute("x", `${Math.round(x)}`);
    rect.setAttribute("y", `${Math.round(y)}`);
    rect.setAttribute("width", `${Math.round(w)}`);
    rect.setAttribute("height", `${Math.round(h)}`);
    dataAttributes.forEach(([key, value]) => {
      if (value !== void 0) {
        rect.dataset[key] = `${value}`;
      }
    });
    cssProperties.forEach(([key, value]) => {
      rect.style.setProperty(key, value);
    });
    this.svg.appendChild(rect);
  }
  clear() {
    this.svg.innerHTML = "";
    this.drawn = false;
  }
  clearActiveNotes() {
    this.unfillActiveRect(this.svg);
  }
};
var PianoRollSVGVisualizer = class extends BaseSVGVisualizer {
  constructor(sequence, svg, config = {}) {
    super(sequence, config);
    if (!(svg instanceof SVGSVGElement)) {
      throw new Error("This visualizer requires an <svg> element to display the visualization");
    }
    this.svg = svg;
    this.parentElement = svg.parentElement;
    const size = this.getSize();
    this.width = size.width;
    this.height = size.height;
    this.svg.style.width = `${this.width}px`;
    this.svg.style.height = `${this.height}px`;
    this.clear();
    this.draw();
  }
};
var WaterfallSVGVisualizer = class extends BaseSVGVisualizer {
  constructor(sequence, parentElement, config = {}) {
    super(sequence, config);
    this.NOTES_PER_OCTAVE = 12;
    this.WHITE_NOTES_PER_OCTAVE = 7;
    this.LOW_C = 24;
    this.firstDrawnOctave = 0;
    this.lastDrawnOctave = 6;
    if (!(parentElement instanceof HTMLDivElement)) {
      throw new Error("This visualizer requires a <div> element to display the visualization");
    }
    this.config.whiteNoteWidth = config.whiteNoteWidth || 20;
    this.config.blackNoteWidth = config.blackNoteWidth || this.config.whiteNoteWidth * 2 / 3;
    this.config.whiteNoteHeight = config.whiteNoteHeight || 70;
    this.config.blackNoteHeight = config.blackNoteHeight || 2 * 70 / 3;
    this.config.showOnlyOctavesUsed = config.showOnlyOctavesUsed;
    this.setupDOM(parentElement);
    const size = this.getSize();
    this.width = size.width;
    this.height = size.height;
    this.svg.style.width = `${this.width}px`;
    this.svg.style.height = `${this.height}px`;
    this.svgPiano.style.width = `${this.width}px`;
    this.svgPiano.style.height = `${this.config.whiteNoteHeight}px`;
    this.parentElement.style.width = `${this.width + this.config.whiteNoteWidth}px`;
    this.parentElement.scrollTop = this.parentElement.scrollHeight;
    this.clear();
    this.drawPiano();
    this.draw();
  }
  setupDOM(container) {
    this.parentElement = document.createElement("div");
    this.parentElement.classList.add("waterfall-notes-container");
    const height = Math.max(container.getBoundingClientRect().height, 200);
    this.parentElement.style.paddingTop = `${height - this.config.whiteNoteHeight}px`;
    this.parentElement.style.height = `${height - this.config.whiteNoteHeight}px`;
    this.parentElement.style.boxSizing = "border-box";
    this.parentElement.style.overflowX = "hidden";
    this.parentElement.style.overflowY = "auto";
    this.svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    this.svgPiano = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    this.svg.classList.add("waterfall-notes");
    this.svgPiano.classList.add("waterfall-piano");
    this.parentElement.appendChild(this.svg);
    container.innerHTML = "";
    container.appendChild(this.parentElement);
    container.appendChild(this.svgPiano);
  }
  redraw(activeNote, scrollIntoView) {
    if (!this.drawn) {
      this.draw();
    }
    if (!activeNote) {
      return null;
    }
    this.clearActiveNotes();
    this.parentElement.style.paddingTop = this.parentElement.style.height;
    for (let i = 0; i < this.noteSequence.notes.length; i++) {
      const note = this.noteSequence.notes[i];
      const isActive = activeNote && this.isPaintingActiveNote(note, activeNote);
      if (!isActive) {
        continue;
      }
      const el = this.svg.querySelector(`rect[data-index="${i}"]`);
      this.fillActiveRect(el, note);
      const key = this.svgPiano.querySelector(`rect[data-pitch="${note.pitch}"]`);
      this.fillActiveRect(key, note);
      if (note === activeNote) {
        const y = parseFloat(el.getAttribute("y"));
        const height = parseFloat(el.getAttribute("height"));
        if (y < this.parentElement.scrollTop - height) {
          this.parentElement.scrollTop = y + height;
        }
        return y;
      }
    }
    return null;
  }
  getSize() {
    this.updateMinMaxPitches(true);
    let whiteNotesDrawn = 52;
    if (this.config.showOnlyOctavesUsed) {
      let foundFirst = false, foundLast = false;
      for (let i = 1; i < 7; i++) {
        const c = this.LOW_C + this.NOTES_PER_OCTAVE * i;
        if (!foundFirst && c > this.config.minPitch) {
          this.firstDrawnOctave = i - 1;
          foundFirst = true;
        }
        if (!foundLast && c > this.config.maxPitch) {
          this.lastDrawnOctave = i - 1;
          foundLast = true;
        }
      }
      whiteNotesDrawn = (this.lastDrawnOctave - this.firstDrawnOctave + 1) * this.WHITE_NOTES_PER_OCTAVE;
    }
    const width = whiteNotesDrawn * this.config.whiteNoteWidth;
    const endTime = this.noteSequence.totalTime;
    if (!endTime) {
      throw new Error("The sequence you are using with the visualizer does not have a totalQuantizedSteps or totalTime field set, so the visualizer can't be horizontally sized correctly.");
    }
    const height = Math.max(endTime * this.config.pixelsPerTimeStep, MIN_NOTE_LENGTH);
    return { width, height };
  }
  getNotePosition(note, noteIndex) {
    const rect = this.svgPiano.querySelector(`rect[data-pitch="${note.pitch}"]`);
    if (!rect) {
      return null;
    }
    const len = this.getNoteEndTime(note) - this.getNoteStartTime(note);
    const x = Number(rect.getAttribute("x"));
    const w = Number(rect.getAttribute("width"));
    const h = Math.max(this.config.pixelsPerTimeStep * len - this.config.noteSpacing, MIN_NOTE_LENGTH);
    const y = this.height - this.getNoteStartTime(note) * this.config.pixelsPerTimeStep - h;
    return { x, y, w, h };
  }
  drawPiano() {
    this.svgPiano.innerHTML = "";
    const blackNoteOffset = this.config.whiteNoteWidth - this.config.blackNoteWidth / 2;
    const blackNoteIndexes = [1, 3, 6, 8, 10];
    let x = 0;
    let currentPitch = 0;
    if (this.config.showOnlyOctavesUsed) {
      currentPitch = this.firstDrawnOctave * this.NOTES_PER_OCTAVE + this.LOW_C;
    } else {
      currentPitch = this.LOW_C - 3;
      this.drawWhiteKey(currentPitch, x);
      this.drawWhiteKey(currentPitch + 2, this.config.whiteNoteWidth);
      currentPitch += 3;
      x = 2 * this.config.whiteNoteWidth;
    }
    for (let o = this.firstDrawnOctave; o <= this.lastDrawnOctave; o++) {
      for (let i = 0; i < this.NOTES_PER_OCTAVE; i++) {
        if (blackNoteIndexes.indexOf(i) === -1) {
          this.drawWhiteKey(currentPitch, x);
          x += this.config.whiteNoteWidth;
        }
        currentPitch++;
      }
    }
    if (this.config.showOnlyOctavesUsed) {
      currentPitch = this.firstDrawnOctave * this.NOTES_PER_OCTAVE + this.LOW_C;
      x = -this.config.whiteNoteWidth;
    } else {
      this.drawWhiteKey(currentPitch, x);
      currentPitch = this.LOW_C - 3;
      this.drawBlackKey(currentPitch + 1, blackNoteOffset);
      currentPitch += 3;
      x = this.config.whiteNoteWidth;
    }
    for (let o = this.firstDrawnOctave; o <= this.lastDrawnOctave; o++) {
      for (let i = 0; i < this.NOTES_PER_OCTAVE; i++) {
        if (blackNoteIndexes.indexOf(i) !== -1) {
          this.drawBlackKey(currentPitch, x + blackNoteOffset);
        } else {
          x += this.config.whiteNoteWidth;
        }
        currentPitch++;
      }
    }
  }
  drawWhiteKey(index, x) {
    const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    rect.dataset.pitch = String(index);
    rect.setAttribute("x", String(x));
    rect.setAttribute("y", "0");
    rect.setAttribute("width", String(this.config.whiteNoteWidth));
    rect.setAttribute("height", String(this.config.whiteNoteHeight));
    rect.setAttribute("fill", "white");
    rect.setAttribute("original-fill", "white");
    rect.setAttribute("stroke", "black");
    rect.setAttribute("stroke-width", "3px");
    rect.classList.add("white");
    this.svgPiano.appendChild(rect);
    return rect;
  }
  drawBlackKey(index, x) {
    const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    rect.dataset.pitch = String(index);
    rect.setAttribute("x", String(x));
    rect.setAttribute("y", "0");
    rect.setAttribute("width", String(this.config.blackNoteWidth));
    rect.setAttribute("height", String(this.config.blackNoteHeight));
    rect.setAttribute("fill", "black");
    rect.setAttribute("original-fill", "black");
    rect.setAttribute("stroke", "black");
    rect.setAttribute("stroke-width", "3px");
    rect.classList.add("black");
    this.svgPiano.appendChild(rect);
    return rect;
  }
  clearActiveNotes() {
    super.unfillActiveRect(this.svg);
    const els = this.svgPiano.querySelectorAll("rect.active");
    for (let i = 0; i < els.length; ++i) {
      const el = els[i];
      el.setAttribute("fill", el.getAttribute("original-fill"));
      el.classList.remove("active");
    }
  }
};
var ScrollType;
(function(ScrollType2) {
  ScrollType2[ScrollType2["PAGE"] = 0] = "PAGE";
  ScrollType2[ScrollType2["NOTE"] = 1] = "NOTE";
  ScrollType2[ScrollType2["BAR"] = 2] = "BAR";
})(ScrollType || (ScrollType = {}));
var StaffSVGVisualizer = class extends BaseVisualizer {
  constructor(sequence, div2, config = {}) {
    super(sequence, config);
    if (config.pixelsPerTimeStep === void 0 || config.pixelsPerTimeStep <= 0) {
      this.config.pixelsPerTimeStep = 0;
    }
    this.instruments = config.instruments || [];
    this.render = new sr.StaffSVGRender(this.getScoreInfo(sequence), {
      noteHeight: this.config.noteHeight,
      noteSpacing: this.config.noteSpacing,
      pixelsPerTimeStep: this.config.pixelsPerTimeStep,
      noteRGB: this.config.noteRGB,
      activeNoteRGB: this.config.activeNoteRGB,
      defaultKey: config.defaultKey || 0,
      scrollType: config.scrollType || ScrollType.PAGE
    }, div2);
    this.drawnNotes = sequence.notes.length;
    this.clear();
    this.redraw();
  }
  clear() {
    this.render.clear();
  }
  redraw(activeNote, scrollIntoView) {
    if (this.drawnNotes !== this.noteSequence.notes.length) {
      this.render.scoreInfo = this.getScoreInfo(this.noteSequence);
    }
    const activeNoteInfo = activeNote ? this.getNoteInfo(activeNote) : void 0;
    return this.render.redraw(activeNoteInfo, scrollIntoView);
  }
  isNoteInInstruments(note) {
    if (note.instrument === void 0 || this.instruments.length === 0) {
      return true;
    } else {
      return this.instruments.indexOf(note.instrument) >= 0;
    }
  }
  timeToQuarters(time2) {
    const q = time2 * this.noteSequence.tempos[0].qpm / 60;
    return Math.round(q * 16) / 16;
  }
  getNoteInfo(note) {
    const startQ = this.timeToQuarters(note.startTime);
    const endQ = this.timeToQuarters(note.endTime);
    return {
      start: startQ,
      length: endQ - startQ,
      pitch: note.pitch,
      intensity: note.velocity
    };
  }
  getScoreInfo(sequence) {
    const notesInfo = [];
    sequence.notes.forEach((note) => {
      if (this.isNoteInInstruments(note)) {
        notesInfo.push(this.getNoteInfo(note));
      }
    });
    return {
      notes: notesInfo,
      tempos: sequence.tempos ? sequence.tempos.map((t) => {
        return { start: this.timeToQuarters(t.time), qpm: t.qpm };
      }) : [],
      keySignatures: sequence.keySignatures ? sequence.keySignatures.map((ks) => {
        return { start: this.timeToQuarters(ks.time), key: ks.key };
      }) : [],
      timeSignatures: sequence.timeSignatures ? sequence.timeSignatures.map((ts) => {
        return {
          start: this.timeToQuarters(ts.time),
          numerator: ts.numerator,
          denominator: ts.denominator
        };
      }) : []
    };
  }
  clearActiveNotes() {
    this.redraw();
  }
};

// node_modules/@magenta/music/esm/coconet/coconet_utils.js
var IS_IOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
var NUM_PITCHES = 46;
var MIN_PITCH = 36;
var NUM_VOICES = 4;
function pianorollToSequence(pianoroll, numberOfSteps) {
  const reshaped = tidy(() => pianoroll.reshape([numberOfSteps, NUM_PITCHES, NUM_VOICES]).arraySync());
  const sequence = NoteSequence.create();
  const notes = [];
  for (let s = 0; s < numberOfSteps; s++) {
    for (let p = 0; p < NUM_PITCHES; p++) {
      for (let v = 0; v < NUM_VOICES; v++) {
        const value = reshaped[s][p][v];
        if (value === 1) {
          const note = NoteSequence.Note.create({
            pitch: p + MIN_PITCH,
            instrument: v,
            quantizedStartStep: s,
            quantizedEndStep: s + 1
          });
          notes.push(note);
        }
      }
    }
  }
  sequence.notes = notes;
  sequence.totalQuantizedSteps = notes[notes.length - 1].quantizedEndStep;
  sequence.quantizationInfo = { stepsPerQuarter: 4 };
  return sequence;
}
function sequenceToPianoroll(ns, numberOfSteps) {
  const pianoroll = tidy(() => zeros([numberOfSteps, NUM_PITCHES, NUM_VOICES]).arraySync());
  const notes = ns.notes;
  notes.forEach((note) => {
    const pitchIndex = note.pitch - MIN_PITCH;
    const stepIndex = note.quantizedStartStep;
    const duration = note.quantizedEndStep - note.quantizedStartStep;
    const voice = note.instrument;
    if (voice < 0 || voice >= NUM_VOICES) {
      log2(`Found invalid voice ${voice}. Skipping.`, "Coconet", 5);
    } else {
      if (stepIndex + duration > numberOfSteps) {
        throw new Error(`NoteSequence ${ns.id} has notes that are longer than the sequence's
          totalQuantizedSteps.`);
      }
      for (let i = stepIndex; i < stepIndex + duration; i++) {
        pianoroll[i][pitchIndex][voice] = 1;
      }
    }
  });
  return tensor([pianoroll]);
}

// node_modules/@magenta/music/esm/coconet/model.js
var DEFAULT_SPEC = {
  useSoftmaxLoss: true,
  batchNormVarianceEpsilon: 1e-7,
  numInstruments: 4,
  numFilters: 128,
  numLayers: 33,
  numRegularConvLayers: 0,
  dilation: [
    [1, 1],
    [2, 2],
    [4, 4],
    [8, 8],
    [16, 16],
    [16, 32],
    [1, 1],
    [2, 2],
    [4, 4],
    [8, 8],
    [16, 16],
    [16, 32],
    [1, 1],
    [2, 2],
    [4, 4],
    [8, 8],
    [16, 16],
    [16, 32],
    [1, 1],
    [2, 2],
    [4, 4],
    [8, 8],
    [16, 16],
    [16, 32],
    [1, 1],
    [2, 2],
    [4, 4],
    [8, 8],
    [16, 16],
    [16, 32]
  ],
  layers: null,
  interleaveSplitEveryNLayers: 16,
  numPointwiseSplits: 4
};
var ConvNet = class {
  constructor(spec, vars) {
    this.residualPeriod = 2;
    this.outputForResidual = null;
    this.residualCounter = -1;
    this.rawVars = null;
    this.spec = spec;
    this.rawVars = vars;
  }
  dispose() {
    if (this.rawVars !== null) {
      dispose(this.rawVars);
    }
    if (this.outputForResidual) {
      this.outputForResidual.dispose();
    }
  }
  predictFromPianoroll(pianoroll, masks) {
    return tidy(() => {
      let featuremaps = this.getConvnetInput(pianoroll, masks);
      const n = this.spec.layers.length;
      for (let i = 0; i < n; i++) {
        this.residualCounter += 1;
        this.residualSave(featuremaps);
        let numPointwiseSplits = null;
        if (this.spec.interleaveSplitEveryNLayers && i > 0 && i < n - 2 && i % (this.spec.interleaveSplitEveryNLayers + 1) === 0) {
          numPointwiseSplits = this.spec.numPointwiseSplits;
        }
        featuremaps = this.applyConvolution(featuremaps, this.spec.layers[i], i, i >= this.spec.numRegularConvLayers, numPointwiseSplits);
        featuremaps = this.applyResidual(featuremaps, i === 0, i === n - 1, i);
        featuremaps = this.applyActivation(featuremaps, this.spec.layers[i], i);
        featuremaps = this.applyPooling(featuremaps, this.spec.layers[i], i);
      }
      return this.computePredictions(featuremaps);
    });
  }
  computePredictions(logits) {
    if (this.spec.useSoftmaxLoss) {
      return logits.transpose([0, 1, 3, 2]).softmax().transpose([0, 1, 3, 2]);
    }
    return logits.sigmoid();
  }
  residualReset() {
    this.outputForResidual = null;
    this.residualCounter = 0;
  }
  residualSave(x) {
    if (this.residualCounter % this.residualPeriod === 1) {
      this.outputForResidual = x;
    }
  }
  applyResidual(x, isFirst, isLast, i) {
    if (this.outputForResidual == null) {
      return x;
    }
    if (this.outputForResidual.shape[this.outputForResidual.shape.length - 1] !== x.shape[x.shape.length - 1]) {
      this.residualReset();
      return x;
    }
    if (this.residualCounter % this.residualPeriod === 0) {
      if (!isFirst && !isLast) {
        x = x.add(this.outputForResidual);
      }
    }
    return x;
  }
  getVar(name, layerNum) {
    const varname = `model/conv${layerNum}/${name}`;
    return this.rawVars[varname];
  }
  getSepConvVar(name, layerNum) {
    const varname = `model/conv${layerNum}/SeparableConv2d/${name}`;
    return this.rawVars[varname];
  }
  getPointwiseSplitVar(name, layerNum, splitNum) {
    const varname = `model/conv${layerNum}/split_${layerNum}_${splitNum}/${name}`;
    return this.rawVars[varname];
  }
  applyConvolution(x, layer, i, depthwise, numPointwiseSplits) {
    if (layer.filters == null) {
      return x;
    }
    const filterShape = layer.filters;
    const stride = layer.convStride || 1;
    const padding = layer.convPad ? layer.convPad.toLowerCase() : "same";
    let conv = null;
    if (depthwise) {
      const dWeights = this.getSepConvVar("depthwise_weights", i);
      if (!numPointwiseSplits) {
        const pWeights = this.getSepConvVar("pointwise_weights", i);
        const biases = this.getSepConvVar("biases", i);
        const sepConv = separableConv2d(x, dWeights, pWeights, [stride, stride], padding, layer.dilation, "NHWC");
        conv = sepConv.add(biases);
      } else {
        conv = depthwiseConv2d(x, dWeights, [stride, stride], padding, "NHWC", layer.dilation);
        const splits = split(conv, numPointwiseSplits, conv.rank - 1);
        const pointwiseSplits = [];
        for (let splitIdx = 0; splitIdx < numPointwiseSplits; splitIdx++) {
          const outputShape = filterShape[3] / numPointwiseSplits;
          const weights = this.getPointwiseSplitVar("kernel", i, splitIdx);
          const biases = this.getPointwiseSplitVar("bias", i, splitIdx);
          const dot = matMul(splits[splitIdx].reshape([-1, outputShape]), weights, false, false);
          const bias = add(dot, biases);
          pointwiseSplits.push(bias.reshape([
            splits[splitIdx].shape[0],
            splits[splitIdx].shape[1],
            splits[splitIdx].shape[2],
            outputShape
          ]));
        }
        conv = concat(pointwiseSplits, conv.rank - 1);
      }
    } else {
      const weights = this.getVar("weights", i);
      const stride2 = layer.convStride || 1;
      const padding2 = layer.convPad ? layer.convPad.toLowerCase() : "same";
      conv = conv2d(x, weights, [stride2, stride2], padding2, "NHWC", [1, 1]);
    }
    return this.applyBatchnorm(conv, i);
  }
  applyBatchnorm(x, i) {
    const gammas = this.getVar("gamma", i);
    const betas = this.getVar("beta", i);
    const mean2 = this.getVar("popmean", i);
    const variance = this.getVar("popvariance", i);
    if (IS_IOS) {
      const v = variance.arraySync()[0][0][0];
      const stdevs = tensor(v.map((x2) => Math.sqrt(x2 + this.spec.batchNormVarianceEpsilon)));
      return x.sub(mean2).mul(gammas.div(stdevs)).add(betas);
    }
    return batchNorm(x, squeeze(mean2), squeeze(variance), squeeze(betas), squeeze(gammas), this.spec.batchNormVarianceEpsilon);
  }
  applyActivation(x, layer, i) {
    if (layer.activation === "identity") {
      return x;
    }
    return x.relu();
  }
  applyPooling(x, layer, i) {
    if (layer.pooling == null) {
      return x;
    }
    const pooling = layer.pooling;
    const padding = layer.poolPad ? layer.poolPad.toLowerCase() : "same";
    return maxPool(x, [pooling[0], pooling[1]], [pooling[0], pooling[1]], padding);
  }
  getConvnetInput(pianoroll, masks) {
    pianoroll = scalar(1, "float32").sub(masks).mul(pianoroll);
    masks = scalar(1, "float32").sub(masks);
    return pianoroll.concat(masks, 3);
  }
};
var Coconet = class {
  constructor(checkpointURL) {
    this.spec = null;
    this.initialized = false;
    this.checkpointURL = checkpointURL;
    this.spec = DEFAULT_SPEC;
  }
  async initialize() {
    this.dispose();
    const startTime = performance2.now();
    this.instantiateFromSpec();
    const vars = await fetch3(`${this.checkpointURL}/weights_manifest.json`).then((response) => response.json()).then((manifest) => io_exports.loadWeights(manifest, this.checkpointURL));
    this.convnet = new ConvNet(this.spec, vars);
    this.initialized = true;
    logWithDuration("Initialized model", startTime, "Coconet");
  }
  dispose() {
    if (this.convnet) {
      this.convnet.dispose();
    }
    this.initialized = false;
  }
  isInitialized() {
    return this.initialized;
  }
  instantiateFromSpec() {
    const nonFinalLayerFilterOuterSizes = 3;
    const finalTwoLayersFilterOuterSizes = 2;
    this.spec.layers = [];
    this.spec.layers.push({
      filters: [
        nonFinalLayerFilterOuterSizes,
        nonFinalLayerFilterOuterSizes,
        this.spec.numInstruments * 2,
        this.spec.numFilters
      ]
    });
    for (let i = 0; i < this.spec.numLayers - 3; i++) {
      this.spec.layers.push({
        filters: [
          nonFinalLayerFilterOuterSizes,
          nonFinalLayerFilterOuterSizes,
          this.spec.numFilters,
          this.spec.numFilters
        ],
        dilation: this.spec.dilation ? this.spec.dilation[i] : null
      });
    }
    this.spec.layers.push({
      filters: [
        finalTwoLayersFilterOuterSizes,
        finalTwoLayersFilterOuterSizes,
        this.spec.numFilters,
        this.spec.numFilters
      ]
    });
    this.spec.layers.push({
      filters: [
        finalTwoLayersFilterOuterSizes,
        finalTwoLayersFilterOuterSizes,
        this.spec.numFilters,
        this.spec.numInstruments
      ],
      activation: "identity"
    });
  }
  async infill(sequence, config) {
    assertIsRelativeQuantizedSequence(sequence);
    if (sequence.notes.length === 0) {
      throw new Error(`NoteSequence ${sequence.id} does not have any notes to infill.`);
    }
    const numSteps = sequence.totalQuantizedSteps || sequence.notes[sequence.notes.length - 1].quantizedEndStep;
    const pianoroll = sequenceToPianoroll(sequence, numSteps);
    let temperature = 0.99;
    let numIterations = 96;
    let outerMasks;
    if (config) {
      numIterations = config.numIterations || numIterations;
      temperature = config.temperature || temperature;
      outerMasks = this.getCompletionMaskFromInput(config.infillMask, pianoroll);
    } else {
      outerMasks = this.getCompletionMask(pianoroll);
    }
    const samples = await this.run(pianoroll, numIterations, temperature, outerMasks);
    const outputSequence = pianorollToSequence(samples, numSteps);
    pianoroll.dispose();
    samples.dispose();
    outerMasks.dispose();
    return outputSequence;
  }
  async run(pianorolls, numSteps, temperature, outerMasks) {
    return this.gibbs(pianorolls, numSteps, temperature, outerMasks);
  }
  getCompletionMaskFromInput(masks, pianorolls) {
    if (!masks) {
      return this.getCompletionMask(pianorolls);
    } else {
      const buffer2 = buffer([pianorolls.shape[1], 4]);
      for (let i = 0; i < masks.length; i++) {
        buffer2.set(1, masks[i].step, masks[i].voice);
      }
      return tidy(() => {
        return buffer2.toTensor().expandDims(1).tile([1, NUM_PITCHES, 1]).expandDims(0);
      });
    }
  }
  getCompletionMask(pianorolls) {
    return tidy(() => {
      const isEmpty = pianorolls.sum(2, true).equal(scalar(0, "float32"));
      return cast(isEmpty, "float32").add(zerosLike(pianorolls));
    });
  }
  async gibbs(pianorolls, numSteps, temperature, outerMasks) {
    const numStepsTensor = scalar(numSteps, "float32");
    let pianoroll = pianorolls.clone();
    for (let s = 0; s < numSteps; s++) {
      const pm = this.yaoSchedule(s, numStepsTensor);
      const innerMasks = this.bernoulliMask(pianoroll.shape, pm, outerMasks);
      await nextFrame();
      const predictions = tidy(() => {
        return this.convnet.predictFromPianoroll(pianoroll, innerMasks);
      });
      await nextFrame();
      pianoroll = tidy(() => {
        const samples = this.samplePredictions(predictions, temperature);
        const updatedPianorolls = where(cast(innerMasks, "bool"), samples, pianoroll);
        pianoroll.dispose();
        predictions.dispose();
        innerMasks.dispose();
        pm.dispose();
        return updatedPianorolls;
      });
      await nextFrame();
    }
    numStepsTensor.dispose();
    return pianoroll;
  }
  yaoSchedule(i, n) {
    return tidy(() => {
      const pmin = scalar(0.1, "float32");
      const pmax = scalar(0.9, "float32");
      const alpha = scalar(0.7, "float32");
      const wat = pmax.sub(pmin).mul(scalar(i, "float32")).div(n);
      const secondArg = pmax.sub(wat).div(alpha);
      return pmin.reshape([1]).concat(secondArg.reshape([1])).max();
    });
  }
  bernoulliMask(shape, pm, outerMasks) {
    return tidy(() => {
      const [bb, tt, pp, ii] = shape;
      const probs = tile(randomUniform([bb, tt, 1, ii], 0, 1, "float32"), [1, 1, pp, 1]);
      const masks = probs.less(pm);
      return cast(masks, "float32").mul(outerMasks);
    });
  }
  samplePredictions(predictions, temperature) {
    return tidy(() => {
      predictions = pow(predictions, scalar(1 / temperature, "float32"));
      const cmf = cumsum(predictions, 2, false, false);
      const totalMasses = cmf.slice([0, 0, cmf.shape[2] - 1, 0], [cmf.shape[0], cmf.shape[1], 1, cmf.shape[3]]);
      const u = randomUniform(totalMasses.shape, 0, 1, "float32");
      const i = u.mul(totalMasses).less(cmf).argMax(2);
      return oneHot(i.flatten(), predictions.shape[2], 1, 0).reshape([
        predictions.shape[0],
        predictions.shape[1],
        predictions.shape[3],
        predictions.shape[2]
      ]).transpose([0, 1, 3, 2]);
    });
  }
};

// node_modules/@magenta/music/esm/music_rnn/attention.js
var ATTENTION_PREFIX = "attention_cell_wrapper/";
var AttentionWrapper = class {
  constructor(cells, attnLength, attnSize) {
    this.cells = cells;
    this.attnLength = attnLength;
    this.attnSize = attnSize;
  }
  static isWrapped(vars) {
    return `rnn/${ATTENTION_PREFIX}kernel` in vars;
  }
  initialize(vars) {
    const prefix = `rnn/${ATTENTION_PREFIX}`;
    this.attnInputMatrix = vars[`${prefix}kernel`];
    this.attnInputBias = vars[`${prefix}bias`];
    this.attnW = vars[`${prefix}attention/attn_w`];
    this.attnV = vars[`${prefix}attention/attn_v`];
    this.attnMatrix = vars[`${prefix}attention/kernel`];
    this.attnBias = vars[`${prefix}attention/bias`];
    this.attnOutputMatrix = vars[`${prefix}attention_output_projection/kernel`];
    this.attnOutputBias = vars[`${prefix}attention_output_projection/bias`];
  }
  initState() {
    const attention = zeros([this.attnSize]);
    const attentionState = zeros([1, this.attnSize * this.attnLength]);
    return { attention, attentionState };
  }
  call(input2, c, h, state) {
    const nextAttnInput = concat([input2, state.attention.as2D(1, -1)], 1);
    const nextRnnInput = add(matMul(nextAttnInput, this.attnInputMatrix), this.attnInputBias.as2D(1, -1));
    [c, h] = multiRNNCell(this.cells, nextRnnInput, c, h);
    const attnHidden = reshape(state.attentionState, [-1, this.attnLength, 1, this.attnSize]);
    const attnHiddenFeatures = conv2d(attnHidden, this.attnW, [1, 1], "same");
    const attnQueryParts = [];
    for (let q = 0; q < c.length; q++) {
      attnQueryParts.push(c[q]);
      attnQueryParts.push(h[q]);
    }
    const attnQuery = concat(attnQueryParts, 1);
    const attnY = matMul(attnQuery, this.attnMatrix).reshape([
      -1,
      1,
      1,
      this.attnSize
    ]);
    const attnS = sum(mul(this.attnV, tanh(add(attnHiddenFeatures, attnY))), [2, 3]);
    const attnA = softmax(attnS);
    const attnD = sum(mul(reshape(attnA, [-1, this.attnLength, 1, 1]), attnHidden), [1, 2]);
    const newAttns = attnD.reshape([-1, this.attnSize]);
    const attnStates = state.attentionState.reshape([-1, this.attnLength, this.attnSize]);
    const newAttnStates = slice(attnStates, [0, 1, 0], [attnStates.shape[0], attnStates.shape[1] - 1, attnStates.shape[2]]);
    const output = add(matMul(concat([h[2], newAttns], 1), this.attnOutputMatrix), this.attnOutputBias);
    const attention = newAttns.flatten();
    const attentionState = concat([newAttnStates, output.as3D(output.shape[0], 1, output.shape[1])], 1).reshape([-1, this.attnLength * this.attnSize]);
    return { output, c, h, attentionState: { attention, attentionState } };
  }
};

// node_modules/@magenta/music/esm/music_rnn/model.js
var CELL_FORMAT = "multi_rnn_cell/cell_%d/basic_lstm_cell/";
var MusicRNN = class {
  constructor(checkpointURL, spec) {
    this.checkpointURL = checkpointURL;
    this.spec = spec;
    this.initialized = false;
    this.rawVars = {};
    this.biasShapes = [];
    this.lstmCells = [];
  }
  isInitialized() {
    return this.initialized;
  }
  instantiateFromSpec() {
    this.dataConverter = converterFromSpec(this.spec.dataConverter);
    this.attentionLength = this.spec.attentionLength;
    this.chordEncoder = this.spec.chordEncoder ? chordEncoderFromType(this.spec.chordEncoder) : void 0;
    this.auxInputs = this.spec.auxInputs ? this.spec.auxInputs.map((s) => auxiliaryInputFromSpec(s)) : void 0;
  }
  async initialize() {
    this.dispose();
    const startTime = performance2.now();
    if (!this.spec) {
      await fetch3(`${this.checkpointURL}/config.json`).then((response) => response.json()).then((spec) => {
        if (spec.type !== "MusicRNN") {
          throw new Error(`Attempted to instantiate MusicRNN model with incorrect type:
                  ${spec.type}`);
        }
        this.spec = spec;
      });
    }
    this.instantiateFromSpec();
    const vars = await fetch3(`${this.checkpointURL}/weights_manifest.json`).then((response) => response.json()).then((manifest) => io_exports.loadWeights(manifest, this.checkpointURL));
    const hasAttention = AttentionWrapper.isWrapped(vars);
    const rnnPrefix = hasAttention ? `rnn/${ATTENTION_PREFIX}` : "rnn/";
    this.forgetBias = scalar(1);
    this.lstmCells.length = 0;
    this.biasShapes.length = 0;
    let l = 0;
    while (true) {
      const cellPrefix = rnnPrefix + CELL_FORMAT.replace("%d", l.toString());
      if (!(`${cellPrefix}kernel` in vars)) {
        break;
      }
      this.lstmCells.push((data, c, h) => basicLSTMCell(this.forgetBias, vars[`${cellPrefix}kernel`], vars[`${cellPrefix}bias`], data, c, h));
      this.biasShapes.push(vars[`${cellPrefix}bias`].shape[0]);
      ++l;
    }
    this.lstmFcW = vars["fully_connected/weights"];
    this.lstmFcB = vars["fully_connected/biases"];
    if (hasAttention) {
      this.attentionWrapper = new AttentionWrapper(this.lstmCells, this.attentionLength, this.biasShapes[0] / 4);
      this.attentionWrapper.initialize(vars);
    }
    this.rawVars = vars;
    this.initialized = true;
    logWithDuration("Initialized model", startTime, "MusicRNN");
  }
  dispose() {
    Object.keys(this.rawVars).forEach((name) => this.rawVars[name].dispose());
    this.rawVars = {};
    if (this.forgetBias) {
      this.forgetBias.dispose();
      this.forgetBias = void 0;
    }
    this.initialized = false;
  }
  async continueSequence(sequence, steps, temperature, chordProgression) {
    const result = await this.continueSequenceImpl(sequence, steps, temperature, chordProgression, false);
    return result.sequence;
  }
  async continueSequenceAndReturnProbabilities(sequence, steps, temperature, chordProgression) {
    return this.continueSequenceImpl(sequence, steps, temperature, chordProgression, true);
  }
  async continueSequenceImpl(sequence, steps, temperature, chordProgression, returnProbs) {
    assertIsRelativeQuantizedSequence(sequence);
    if (this.chordEncoder && !chordProgression) {
      throw new Error("Chord progression expected but not provided.");
    }
    if (!this.chordEncoder && chordProgression) {
      throw new Error("Unexpected chord progression provided.");
    }
    if (!this.initialized) {
      await this.initialize();
    }
    const startTime = performance2.now();
    const oh = tidy(() => {
      const inputs = this.dataConverter.toTensor(sequence);
      const length = inputs.shape[0];
      const outputSize = inputs.shape[1];
      const controls = this.chordEncoder ? this.chordEncoder.encodeProgression(chordProgression, length + steps) : void 0;
      const auxInputs = this.auxInputs ? concat(this.auxInputs.map((auxInput) => auxInput.getTensors(length + steps)), 1) : void 0;
      const rnnResult = this.sampleRnn(inputs, steps, temperature, controls, auxInputs, returnProbs);
      const samples = rnnResult.samples;
      return {
        samples: stack(samples).as2D(samples.length, outputSize),
        probs: rnnResult.probs
      };
    });
    const samplesAndProbs = await oh;
    const result = this.dataConverter.toNoteSequence(samplesAndProbs.samples, sequence.quantizationInfo.stepsPerQuarter);
    const probs = [];
    if (returnProbs) {
      for (let i = 0; i < samplesAndProbs.probs.length; i++) {
        probs.push(await samplesAndProbs.probs[i].data());
        samplesAndProbs.probs[i].dispose();
      }
    }
    oh.samples.dispose();
    result.then(() => logWithDuration("Continuation completed", startTime, "MusicRNN", 20));
    return { sequence: result, probs };
  }
  sampleRnn(inputs, steps, temperature, controls, auxInputs, returnProbs) {
    const length = inputs.shape[0];
    const outputSize = inputs.shape[1];
    let c = [];
    let h = [];
    for (let i = 0; i < this.biasShapes.length; i++) {
      c.push(zeros([1, this.biasShapes[i] / 4]));
      h.push(zeros([1, this.biasShapes[i] / 4]));
    }
    let attentionState = this.attentionWrapper ? this.attentionWrapper.initState() : null;
    let lastOutput;
    inputs = inputs.toFloat();
    const samples = [];
    const probs = [];
    const splitInputs = split(inputs.toFloat(), length);
    const splitControls = controls ? split(controls, controls.shape[0]) : void 0;
    const splitAuxInputs = auxInputs ? split(auxInputs, auxInputs.shape[0]) : void 0;
    for (let i = 0; i < length + steps; i++) {
      let nextInput;
      if (i < length) {
        nextInput = splitInputs[i];
      } else {
        let logits = lastOutput.matMul(this.lstmFcW).add(this.lstmFcB).as1D();
        let sampledOutput;
        if (temperature) {
          logits = logits.div(scalar(temperature));
          sampledOutput = multinomial(logits, 1).as1D();
        } else {
          sampledOutput = logits.argMax().as1D();
        }
        if (returnProbs) {
          probs.push(softmax(logits));
        }
        nextInput = oneHot(sampledOutput, outputSize).toFloat();
        samples.push(nextInput.as1D());
      }
      if (i === length + steps - 1) {
        break;
      }
      const tensors = [];
      if (splitControls) {
        tensors.push(splitControls[i + 1]);
      }
      tensors.push(nextInput);
      if (splitAuxInputs) {
        tensors.push(splitAuxInputs[i]);
      }
      nextInput = concat(tensors, 1);
      if (this.attentionWrapper) {
        const wrapperOutput = this.attentionWrapper.call(nextInput, c, h, attentionState);
        c = wrapperOutput.c;
        h = wrapperOutput.h;
        attentionState = wrapperOutput.attentionState;
        lastOutput = wrapperOutput.output;
      } else {
        [c, h] = multiRNNCell(this.lstmCells, nextInput, c, h);
        lastOutput = h[h.length - 1];
      }
    }
    return { samples, probs };
  }
};

// node_modules/@magenta/music/esm/music_vae/midi_me.js
var SamplingLayer = class extends exports_layers_exports.Layer {
  constructor() {
    super({});
  }
  computeOutputShape(inputShape) {
    return inputShape[0];
  }
  call(inputs) {
    return tidy(() => {
      const [mu, sigma] = inputs;
      return add(mul(randomNormal(sigma.shape), sigma), mu);
    });
  }
  getClassName() {
    return "SamplingLayer";
  }
};
var MidiMe = class {
  constructor(config = {}) {
    this.trained = false;
    this.initialized = false;
    this.config = {
      encoder_layers: config.encoder_layers || [1024, 256, 64],
      decoder_layers: config.decoder_layers || [64, 256, 1024],
      input_size: config.input_size || 256,
      latent_size: config.latent_size || 4,
      beta: config.beta || 1,
      epochs: config.epochs || 10
    };
  }
  dispose() {
    if (!this.initialized) {
      return;
    }
    this.encoder.dispose();
    this.decoder.dispose();
    this.vae.dispose();
    this.initialized = false;
  }
  initialize() {
    this.dispose();
    const startTime = performance2.now();
    const x = input({ shape: [this.config["input_size"]] });
    this.encoder = this.getEncoder(x);
    const [z, ,] = this.encoder.apply(x);
    this.decoder = this.getDecoder(z.shape.slice(1));
    const y = this.decoder.apply(z);
    this.vae = model({ inputs: x, outputs: y, name: "vae" });
    this.initialized = true;
    logWithDuration("Initialized model", startTime, "MidiMe");
  }
  async train(xTrain, callback) {
    const startTime = performance2.now();
    this.trained = false;
    let learningRate = 1e-3;
    if (ENV.get("WEBGL_RENDER_FLOAT32_ENABLED") === false && ENV.get("WEBGL_DOWNLOAD_FLOAT_ENABLED") === false && ENV.get("WEBGL_VERSION") === 1) {
      learningRate = 5e-5;
    }
    const optimizer = train.adam(learningRate);
    for (let e = 0; e < this.config.epochs; e++) {
      await nextFrame();
      await optimizer.minimize(() => {
        return tidy(() => {
          const [, zMu, zSigma] = this.encoder.predict(xTrain);
          const y = this.vae.predict(xTrain);
          const loss = this.loss(zMu, zSigma, y, xTrain);
          if (callback) {
            callback(e, {
              y,
              total: loss.totalLoss.arraySync(),
              losses: [loss.reconLoss.arraySync(), loss.latentLoss.arraySync()]
            });
          }
          return loss.totalLoss;
        });
      });
      await nextFrame();
    }
    logWithDuration("Training finished", startTime, "MidiMe");
    this.trained = true;
    optimizer.dispose();
  }
  async sample(numSamples = 1) {
    if (!this.initialized) {
      await this.initialize();
    }
    return tidy(() => {
      const randZs = randomNormal([numSamples, this.config["latent_size"]]);
      return this.decoder.predict(randZs);
    });
  }
  async decode(z) {
    if (!this.initialized) {
      await this.initialize();
    }
    return this.decoder.predict(z);
  }
  async encode(z) {
    if (!this.initialized) {
      await this.initialize();
    }
    const [z_, ,] = this.encoder.predict(z);
    return z_;
  }
  predict(z) {
    return this.vae.predict(z);
  }
  getEncoder(input2) {
    let x = input2;
    for (let i = 0; i < this.config["encoder_layers"].length; i++) {
      x = exports_layers_exports.dense({ units: this.config["encoder_layers"][i], activation: "relu" }).apply(x);
    }
    const mu = this.getAffineLayers(x, this.config["latent_size"], input2, false);
    const sigma = this.getAffineLayers(x, this.config["latent_size"], input2, true);
    const z = new SamplingLayer().apply([mu, sigma]);
    return model({ inputs: input2, outputs: [z, mu, sigma], name: "encoder" });
  }
  getDecoder(shape) {
    const z = input({ shape });
    let x = z;
    for (let i = 0; i < this.config["decoder_layers"].length; i++) {
      x = exports_layers_exports.dense({ units: this.config["decoder_layers"][i], activation: "relu" }).apply(x);
    }
    const mu = this.getAffineLayers(x, this.config["input_size"], z, false);
    return model({ inputs: z, outputs: mu, name: "decoder" });
  }
  loss(zMu, zSigma, yPred, yTrue) {
    return tidy(() => {
      const latentLoss = this.klLoss(zMu, zSigma);
      const reconLoss = this.reconstructionLoss(yTrue, yPred);
      const totalLoss = add(reconLoss, mul(latentLoss, this.config["beta"]));
      return { latentLoss, reconLoss, totalLoss };
    });
  }
  reconstructionLoss(yTrue, yPred) {
    return tidy(() => {
      const se = pow(sub(yTrue, yPred), 2);
      const nll = div(se, mul(2, pow(ones([1]), 2)));
      return mean(sum(nll, -1));
    });
  }
  klLoss(mu, sigma) {
    return tidy(() => {
      const mu2 = pow(mu, 2);
      const sigma2 = pow(sigma, 2);
      const term1 = add(1, log(sigma2));
      const term2 = add(mu2, sigma2);
      const term = sub(term1, term2);
      const div2 = div(mean(sum(term, -1)), 2);
      return mul(-1, div2);
    });
  }
  getAffineLayers(x, outputSize, z_, softplus) {
    const linear = exports_layers_exports.dense({ units: outputSize });
    const output = linear.apply(x);
    if (softplus) {
      return exports_layers_exports.activation({ activation: "softplus" }).apply(output);
    } else {
      return output;
    }
  }
};

// node_modules/@magenta/music/esm/music_vae/model.js
var LayerVars = class {
  constructor(kernel, bias) {
    if (kernel === void 0) {
      throw Error("`kernel` is undefined.");
    }
    if (bias === void 0) {
      throw Error("`bias` is undefined.");
    }
    this.kernel = kernel;
    this.bias = bias;
  }
};
function dense(vars, inputs) {
  return inputs.matMul(vars.kernel).add(vars.bias);
}
var Encoder = class {
};
var BidirectionalLstm = class {
  constructor(lstmFwVars, lstmBwVars) {
    this.lstmFwVars = lstmFwVars;
    this.lstmBwVars = lstmBwVars;
  }
  process(sequence) {
    return tidy(() => {
      const fwStates = this.singleDirection(sequence, true);
      const bwStates = this.singleDirection(sequence, false);
      return [fwStates, bwStates];
    });
  }
  singleDirection(inputs, fw) {
    const batchSize = inputs.shape[0];
    const length = inputs.shape[1];
    const lstmVars = fw ? this.lstmFwVars : this.lstmBwVars;
    let state = [
      zeros([batchSize, lstmVars.bias.shape[0] / 4]),
      zeros([batchSize, lstmVars.bias.shape[0] / 4])
    ];
    const forgetBias = scalar(1);
    const lstm = (data, state2) => basicLSTMCell(forgetBias, lstmVars.kernel, lstmVars.bias, data, state2[0], state2[1]);
    const splitInputs = split(inputs.toFloat(), length, 1);
    const outputStates = [];
    for (const data of fw ? splitInputs : splitInputs.reverse()) {
      state = lstm(data.squeeze([1]), state);
      outputStates.push(state[1]);
    }
    return fw ? outputStates : outputStates.reverse();
  }
};
var BidirectionalLstmEncoder = class extends Encoder {
  constructor(lstmFwVars, lstmBwVars, muVars) {
    super();
    this.bidirectionalLstm = new BidirectionalLstm(lstmFwVars, lstmBwVars);
    this.muVars = muVars;
    this.zDims = muVars ? this.muVars.bias.shape[0] : null;
  }
  encode(sequence, segmentLengths) {
    if (segmentLengths) {
      throw new Error("Variable-length segments not supported in flat encoder");
    }
    return tidy(() => {
      const [fwStates, bwStates] = this.bidirectionalLstm.process(sequence);
      const finalState = concat([fwStates[fwStates.length - 1], bwStates[0]], 1);
      if (this.muVars) {
        return dense(this.muVars, finalState);
      } else {
        return finalState;
      }
    });
  }
};
var HierarchicalEncoder = class extends Encoder {
  constructor(baseEncoders, numSteps, muVars) {
    super();
    this.baseEncoders = baseEncoders;
    this.numSteps = numSteps;
    this.muVars = muVars;
    this.zDims = this.muVars.bias.shape[0];
  }
  encode(sequence, segmentLengths) {
    if (segmentLengths) {
      if (sequence.shape[0] !== 1) {
        throw new Error("When using variable-length segments, batch size must be 1.");
      }
      if (segmentLengths.length !== this.numSteps[0]) {
        throw new Error("Must provide length for all variable-length segments.");
      }
    }
    return tidy(() => {
      let inputs = sequence;
      for (let level = 0; level < this.baseEncoders.length; ++level) {
        const levelSteps = this.numSteps[level];
        const splitInputs = split(inputs, levelSteps, 1);
        const embeddings = [];
        for (let step = 0; step < levelSteps; ++step) {
          embeddings.push(this.baseEncoders[level].encode(level === 0 && segmentLengths ? slice3d(splitInputs[step], [0, 0, 0], [1, segmentLengths[step], -1]) : splitInputs[step]));
        }
        inputs = stack(embeddings, 1);
      }
      return dense(this.muVars, inputs.squeeze([1]));
    });
  }
};
function initLstmCells(z, lstmCellVars, zToInitStateVars) {
  const lstmCells = [];
  const c = [];
  const h = [];
  const initialStates = split(dense(zToInitStateVars, z).tanh(), 2 * lstmCellVars.length, 1);
  for (let i = 0; i < lstmCellVars.length; ++i) {
    const lv = lstmCellVars[i];
    const forgetBias = scalar(1);
    lstmCells.push((data, c2, h2) => basicLSTMCell(forgetBias, lv.kernel, lv.bias, data, c2, h2));
    c.push(initialStates[i * 2]);
    h.push(initialStates[i * 2 + 1]);
  }
  return { "cell": lstmCells, "c": c, "h": h };
}
var Decoder = class {
};
var BaseDecoder = class extends Decoder {
  constructor(lstmCellVars, zToInitStateVars, outputProjectVars, outputDims, controlLstmFwVars, controlLstmBwVars) {
    super();
    this.lstmCellVars = lstmCellVars;
    this.zToInitStateVars = zToInitStateVars;
    this.outputProjectVars = outputProjectVars;
    this.zDims = this.zToInitStateVars.kernel.shape[0];
    this.outputDims = outputDims || outputProjectVars.bias.shape[0];
    if (controlLstmFwVars && controlLstmBwVars) {
      this.controlBidirectionalLstm = new BidirectionalLstm(controlLstmFwVars, controlLstmBwVars);
    }
  }
  decode(z, length, initialInput, temperature, controls) {
    const batchSize = z.shape[0];
    return tidy(() => {
      const lstmCell = initLstmCells(z, this.lstmCellVars, this.zToInitStateVars);
      let expandedControls = controls ? expandDims(controls, 0) : void 0;
      const samples = [];
      let nextInput = initialInput ? initialInput : zeros([batchSize, this.outputDims]);
      if (this.controlBidirectionalLstm) {
        const [fwStates, bwStates] = this.controlBidirectionalLstm.process(expandedControls);
        expandedControls = concat([stack(fwStates, 1), stack(bwStates, 1)], 2);
      }
      const splitControls = expandedControls ? split(tile(expandedControls, [batchSize, 1, 1]), controls.shape[0], 1) : void 0;
      for (let i = 0; i < length; ++i) {
        const toConcat = splitControls ? [nextInput, z, squeeze(splitControls[i], [1])] : [nextInput, z];
        [lstmCell.c, lstmCell.h] = multiRNNCell(lstmCell.cell, concat(toConcat, 1), lstmCell.c, lstmCell.h);
        const lstmOutput = dense(this.outputProjectVars, lstmCell.h[lstmCell.h.length - 1]);
        nextInput = this.sample(lstmOutput, temperature);
        samples.push(nextInput);
      }
      return stack(samples, 1);
    });
  }
};
var BooleanDecoder = class extends BaseDecoder {
  sample(lstmOutput, temperature) {
    const logits = lstmOutput;
    return (temperature ? greaterEqual(sigmoid(logits.div(scalar(temperature))), randomUniform(logits.shape)) : greaterEqual(logits, 0)).toFloat();
  }
};
var CategoricalDecoder = class extends BaseDecoder {
  sample(lstmOutput, temperature) {
    const logits = lstmOutput;
    const timeLabels = temperature ? multinomial(logits.div(scalar(temperature)), 1).as1D() : logits.argMax(1).as1D();
    return oneHot(timeLabels, this.outputDims).toFloat();
  }
};
var NadeDecoder = class extends BaseDecoder {
  constructor(lstmCellVars, zToInitStateVars, outputProjectVars, nade, controlLstmFwVars, controlLstmBwVars) {
    super(lstmCellVars, zToInitStateVars, outputProjectVars, nade.numDims, controlLstmFwVars, controlLstmBwVars);
    this.nade = nade;
  }
  sample(lstmOutput, temperature) {
    const [encBias, decBias] = split(lstmOutput, [this.nade.numHidden, this.nade.numDims], 1);
    return this.nade.sample(encBias, decBias);
  }
};
var GrooveDecoder = class extends BaseDecoder {
  sample(lstmOutput, temperature) {
    let [hits, velocities, offsets] = split(lstmOutput, 3, 1);
    velocities = sigmoid(velocities);
    offsets = tanh(offsets);
    if (temperature) {
      hits = sigmoid(hits.div(scalar(temperature)));
      const threshold = randomUniform(hits.shape, 0, 1);
      hits = greater(hits, threshold).toFloat();
    } else {
      hits = greater(sigmoid(hits), 0.5).toFloat();
    }
    return concat([hits, velocities, offsets], 1);
  }
};
var SplitDecoder = class extends Decoder {
  constructor(coreDecoders) {
    super();
    this.coreDecoders = coreDecoders;
    this.numDecoders = this.coreDecoders.length;
    this.zDims = this.coreDecoders[0].zDims;
    this.outputDims = this.coreDecoders.reduce((dims, dec) => dims + dec.outputDims, 0);
  }
  decodeSeparately(z, length, initialInput, temperature, controls) {
    const samples = [];
    for (let i = 0; i < this.coreDecoders.length; ++i) {
      samples.push(this.coreDecoders[i].decode(z, length, initialInput[i], temperature, controls));
    }
    return samples;
  }
  decode(z, length, initialInput, temperature, controls) {
    return tidy(() => {
      const samples = this.decodeSeparately(z, length, this.coreDecoders.map((_) => initialInput), temperature, controls);
      return concat(samples, -1);
    });
  }
};
var ConductorDecoder = class extends Decoder {
  constructor(coreDecoders, lstmCellVars, zToInitStateVars, numSteps) {
    super();
    this.splitDecoder = new SplitDecoder(coreDecoders);
    this.lstmCellVars = lstmCellVars;
    this.zToInitStateVars = zToInitStateVars;
    this.numSteps = numSteps;
    this.zDims = this.zToInitStateVars.kernel.shape[0];
    this.outputDims = this.splitDecoder.outputDims;
  }
  decode(z, length, initialInput, temperature, controls) {
    const batchSize = z.shape[0];
    return tidy(() => {
      const lstmCell = initLstmCells(z, this.lstmCellVars, this.zToInitStateVars);
      const samples = [];
      let initialInput2 = new Array(this.splitDecoder.numDecoders).fill(void 0);
      const dummyInput = zeros([batchSize, 1]);
      const splitControls = controls ? split(controls, this.numSteps) : void 0;
      for (let i = 0; i < this.numSteps; ++i) {
        [lstmCell.c, lstmCell.h] = multiRNNCell(lstmCell.cell, dummyInput, lstmCell.c, lstmCell.h);
        const currSamples = this.splitDecoder.decodeSeparately(lstmCell.h[lstmCell.h.length - 1], length / this.numSteps, initialInput2, temperature, splitControls ? splitControls[i] : void 0);
        samples.push(concat(currSamples, -1));
        initialInput2 = currSamples.map((s) => s.slice([0, s.shape[1] - 1, 0], [batchSize, 1, s.shape[s.rank - 1]]).squeeze([1]).toFloat());
      }
      return concat(samples, 1);
    });
  }
};
var Nade = class {
  constructor(encWeights, decWeightsT) {
    this.numDims = encWeights.shape[0];
    this.numHidden = encWeights.shape[2];
    this.encWeights = encWeights.as2D(this.numDims, this.numHidden);
    this.decWeightsT = decWeightsT.as2D(this.numDims, this.numHidden);
  }
  sample(encBias, decBias) {
    const batchSize = encBias.shape[0];
    return tidy(() => {
      const samples = [];
      let a = encBias.clone();
      for (let i = 0; i < this.numDims; i++) {
        const h = sigmoid(a);
        const encWeightsI = this.encWeights.slice([i, 0], [1, this.numHidden]).as1D();
        const decWeightsTI = this.decWeightsT.slice([i, 0], [1, this.numHidden]);
        const decBiasI = decBias.slice([0, i], [batchSize, 1]);
        const contfogitsI = decBiasI.add(matMul(h, decWeightsTI, false, true));
        const condProbsI = contfogitsI.sigmoid();
        const samplesI = condProbsI.greaterEqual(scalar(0.5)).toFloat().as1D();
        if (i < this.numDims - 1) {
          a = a.add(outerProduct(samplesI.toFloat(), encWeightsI));
        }
        samples.push(samplesI);
      }
      return stack(samples, 1);
    });
  }
};
var MusicVAE = class {
  constructor(checkpointURL, spec) {
    this.initialized = false;
    this.checkpointURL = checkpointURL;
    this.spec = spec;
  }
  instantiateFromSpec() {
    this.dataConverter = converterFromSpec(this.spec.dataConverter);
    this.chordEncoder = this.spec.chordEncoder ? chordEncoderFromType(this.spec.chordEncoder) : void 0;
  }
  dispose() {
    if (this.rawVars !== void 0) {
      Object.keys(this.rawVars).forEach((name) => this.rawVars[name].dispose());
    }
    this.encoder = void 0;
    this.decoder = void 0;
    this.initialized = false;
  }
  getLstmLayers(cellFormat, vars) {
    const lstmLayers = [];
    let l = 0;
    while (true) {
      const cellPrefix = cellFormat.replace("%d", l.toString());
      if (!(cellPrefix + "kernel" in vars)) {
        break;
      }
      lstmLayers.push(new LayerVars(vars[cellPrefix + "kernel"], vars[cellPrefix + "bias"]));
      ++l;
    }
    return lstmLayers;
  }
  async initialize() {
    this.dispose();
    const startTime = performance2.now();
    if (!this.spec) {
      await fetch3(`${this.checkpointURL}/config.json`).then((response) => response.json()).then((spec) => {
        if (spec.type !== "MusicVAE") {
          throw new Error(`Attempted to instantiate MusicVAE model with incorrect type:
                  ${spec.type}`);
        }
        this.spec = spec;
      });
    }
    this.instantiateFromSpec();
    const LSTM_CELL_FORMAT = "cell_%d/lstm_cell/";
    const MUTLI_LSTM_CELL_FORMAT = `multi_rnn_cell/${LSTM_CELL_FORMAT}`;
    const CONDUCTOR_PREFIX = "decoder/hierarchical_level_0/";
    const BIDI_LSTM_CELL = "cell_%d/bidirectional_rnn/%s/multi_rnn_cell/cell_0/lstm_cell/";
    const ENCODER_FORMAT = `encoder/${BIDI_LSTM_CELL}`;
    const HIER_ENCODER_FORMAT = `encoder/hierarchical_level_%d/${BIDI_LSTM_CELL.replace("%d", "0")}`;
    const CONTROL_BIDI_LSTM_CELL = `control_preprocessing/${BIDI_LSTM_CELL}`;
    const vars = await fetch3(`${this.checkpointURL}/weights_manifest.json`).then((response) => response.json()).then((manifest) => io_exports.loadWeights(manifest, this.checkpointURL));
    this.rawVars = vars;
    const encMu = new LayerVars(vars["encoder/mu/kernel"], vars["encoder/mu/bias"]);
    if (this.dataConverter.numSegments) {
      const fwLayers = this.getLstmLayers(HIER_ENCODER_FORMAT.replace("%s", "fw"), vars);
      const bwLayers = this.getLstmLayers(HIER_ENCODER_FORMAT.replace("%s", "bw"), vars);
      if (fwLayers.length !== bwLayers.length || fwLayers.length !== 2) {
        throw Error(`Only 2 hierarchical encoder levels are supported. Got ${fwLayers.length} forward and ${bwLayers.length} backward.`);
      }
      const baseEncoders = [0, 1].map((l) => new BidirectionalLstmEncoder(fwLayers[l], bwLayers[l]));
      this.encoder = new HierarchicalEncoder(baseEncoders, [this.dataConverter.numSegments, 1], encMu);
    } else {
      const fwLayers = this.getLstmLayers(ENCODER_FORMAT.replace("%s", "fw"), vars);
      const bwLayers = this.getLstmLayers(ENCODER_FORMAT.replace("%s", "bw"), vars);
      if (fwLayers.length !== bwLayers.length || fwLayers.length !== 1) {
        throw Error(`Only single-layer bidirectional encoders are supported. Got ${fwLayers.length} forward and ${bwLayers.length} backward.`);
      }
      this.encoder = new BidirectionalLstmEncoder(fwLayers[0], bwLayers[0], encMu);
    }
    const hasControlBidiLayers = `${CONTROL_BIDI_LSTM_CELL.replace("%s", "fw").replace("%d", "0")}kernel` in vars;
    const decVarPrefix = this.dataConverter.numSegments ? "core_decoder/" : "";
    const decVarPrefixes = [];
    if (this.dataConverter.NUM_SPLITS) {
      for (let i = 0; i < this.dataConverter.NUM_SPLITS; ++i) {
        decVarPrefixes.push(`${decVarPrefix}core_decoder_${i}/decoder/`);
      }
    } else {
      decVarPrefixes.push(`${decVarPrefix}decoder/`);
    }
    let controlLstmFwLayers = [null];
    let controlLstmBwLayers = [null];
    if (hasControlBidiLayers) {
      controlLstmFwLayers = this.getLstmLayers(CONTROL_BIDI_LSTM_CELL.replace("%s", "fw"), vars);
      controlLstmBwLayers = this.getLstmLayers(CONTROL_BIDI_LSTM_CELL.replace("%s", "bw"), vars);
      if (controlLstmFwLayers.length !== controlLstmBwLayers.length || controlLstmFwLayers.length !== 1) {
        throw Error(`Only single-layer bidirectional control preprocessing is supported. Got ${controlLstmFwLayers.length} forward and ${controlLstmBwLayers.length} backward.`);
      }
    }
    const baseDecoders = decVarPrefixes.map((varPrefix) => {
      const decLstmLayers = this.getLstmLayers(varPrefix + MUTLI_LSTM_CELL_FORMAT, vars);
      const decZtoInitState = new LayerVars(vars[`${varPrefix}z_to_initial_state/kernel`], vars[`${varPrefix}z_to_initial_state/bias`]);
      const decOutputProjection = new LayerVars(vars[`${varPrefix}output_projection/kernel`], vars[`${varPrefix}output_projection/bias`]);
      if (`${varPrefix}nade/w_enc` in vars) {
        return new NadeDecoder(decLstmLayers, decZtoInitState, decOutputProjection, new Nade(vars[`${varPrefix}nade/w_enc`], vars[`${varPrefix}nade/w_dec_t`]), controlLstmFwLayers[0], controlLstmBwLayers[0]);
      } else if (this.spec.dataConverter.type === "GrooveConverter") {
        return new GrooveDecoder(decLstmLayers, decZtoInitState, decOutputProjection, void 0, controlLstmFwLayers[0], controlLstmBwLayers[0]);
      } else if (this.spec.useBooleanDecoder) {
        return new BooleanDecoder(decLstmLayers, decZtoInitState, decOutputProjection, void 0, controlLstmFwLayers[0], controlLstmBwLayers[0]);
      } else {
        return new CategoricalDecoder(decLstmLayers, decZtoInitState, decOutputProjection, void 0, controlLstmFwLayers[0], controlLstmBwLayers[0]);
      }
    });
    if (this.dataConverter.numSegments) {
      const condLstmLayers = this.getLstmLayers(CONDUCTOR_PREFIX + LSTM_CELL_FORMAT, vars);
      const condZtoInitState = new LayerVars(vars[`${CONDUCTOR_PREFIX}initial_state/kernel`], vars[`${CONDUCTOR_PREFIX}initial_state/bias`]);
      this.decoder = new ConductorDecoder(baseDecoders, condLstmLayers, condZtoInitState, this.dataConverter.numSegments);
    } else if (baseDecoders.length === 1) {
      this.decoder = baseDecoders[0];
    } else {
      this.decoder = new SplitDecoder(baseDecoders);
    }
    this.zDims = this.decoder.zDims;
    this.initialized = true;
    logWithDuration("Initialized model", startTime, "MusicVAE");
  }
  isInitialized() {
    return this.initialized;
  }
  checkControlArgs(controlArgs) {
    controlArgs = controlArgs || {};
    const extraControls = controlArgs.extraControls || {};
    if (this.chordEncoder && !controlArgs.chordProgression) {
      throw new Error("Chord progression expected but not provided.");
    }
    if (!this.chordEncoder && controlArgs.chordProgression) {
      throw new Error("Unexpected chord progression provided.");
    }
    if (this.chordEncoder && this.dataConverter.endTensor && controlArgs.chordProgression.length > 1) {
      throw new Error("Multiple chords not supported when using variable-length segments.");
    }
    if (this.spec.conditionOnKey && controlArgs.key == null) {
      throw new Error("Key expected but not provided.");
    }
    if (!this.spec.conditionOnKey && controlArgs.key != null) {
      throw new Error("Unexpected key provided.");
    }
    if (this.spec.extraControls) {
      for (const controlSpec of this.spec.extraControls) {
        if (controlSpec.name in extraControls) {
          if (extraControls[controlSpec.name].shape[1] !== controlSpec.depth) {
            throw new Error(`Control signal ${controlSpec.name} has invalid depth: ${extraControls[controlSpec.name].shape[1]} != ${controlSpec.depth}`);
          }
        } else {
          throw new Error(`Missing control signal: ${controlSpec.name}`);
        }
      }
    }
    const controlNames = this.spec.extraControls ? new Set(this.spec.extraControls.map((controlSpec) => controlSpec.name)) : /* @__PURE__ */ new Set();
    for (const name in extraControls) {
      if (!controlNames.has(name)) {
        log2(`Unspecified control signal provided: ${name}`, "MusicVAE", 5);
      }
    }
  }
  controlArgsToTensor(controlArgs) {
    controlArgs = controlArgs || {};
    return tidy(() => {
      const controls = [];
      if (controlArgs.chordProgression) {
        const encodedChords = this.encodeChordProgression(controlArgs.chordProgression);
        controls.push(encodedChords);
      }
      if (controlArgs.key != null) {
        const encodedKey = oneHot(fill([this.dataConverter.numSteps], controlArgs.key, "int32"), 12);
        controls.push(encodedKey);
      }
      if (controlArgs.extraControls) {
        for (const controlSpec of this.spec.extraControls) {
          controls.push(controlArgs.extraControls[controlSpec.name]);
        }
      }
      return controls.length ? concat2d(controls, 1) : void 0;
    });
  }
  async interpolateTensors(inputTensors, numInterps, temperature, controlArgs) {
    if (!this.initialized) {
      await this.initialize();
    }
    const inputZs = await this.encodeTensors(inputTensors, controlArgs);
    const interpZs = tidy(() => this.getInterpolatedZs(inputZs, numInterps));
    inputZs.dispose();
    const outputTensors = await this.decodeTensors(interpZs, temperature, controlArgs);
    interpZs.dispose();
    return outputTensors;
  }
  async interpolate(inputSequences, numInterps, temperature, controlArgs) {
    this.checkControlArgs(controlArgs);
    if (!this.initialized) {
      await this.initialize();
    }
    const startTime = 0;
    const inputZs = await this.encode(inputSequences, controlArgs);
    const interpZs = tidy(() => this.getInterpolatedZs(inputZs, numInterps));
    inputZs.dispose();
    const outputSequences = this.decode(interpZs, temperature, controlArgs);
    interpZs.dispose();
    outputSequences.then(() => logWithDuration("Interpolation completed", startTime, "MusicVAE", 20));
    return outputSequences;
  }
  async getSegmentLengths(inputTensors) {
    if (inputTensors.shape[0] > 1) {
      throw new Error("Variable-length segments not supported for batch size > 1.");
    }
    const numSteps = this.dataConverter.numSteps;
    const numSegments = this.dataConverter.numSegments;
    const isEndTensor = tidy(() => min(equal(inputTensors.squeeze([0]), this.dataConverter.endTensor.expandDims(0)), 1));
    const isEndArray = await isEndTensor.data();
    isEndTensor.dispose();
    const maxSegmentLength = numSteps / numSegments;
    const segmentLengths = [];
    let offset = 0;
    let fromIndex = isEndArray.indexOf(1);
    while (fromIndex !== -1) {
      segmentLengths.push(fromIndex - offset + 1);
      offset += maxSegmentLength;
      fromIndex = isEndArray.indexOf(1, offset);
    }
    if (segmentLengths.length !== numSegments) {
      throw new Error(`Incorrect number of segments: ${segmentLengths.length} != ${numSegments}`);
    }
    return segmentLengths;
  }
  encodeChordProgression(chordProgression) {
    const numSteps = this.dataConverter.numSteps;
    const numSegments = this.dataConverter.numSegments;
    const numChordSteps = this.dataConverter.SEGMENTED_BY_TRACK ? numSteps / numSegments : numSteps;
    const encodedChordProgression = this.dataConverter.SEGMENTED_BY_TRACK ? concat2d([
      this.chordEncoder.encode(NO_CHORD).expandDims(0),
      this.chordEncoder.encodeProgression(chordProgression, numChordSteps - 1)
    ], 0) : this.chordEncoder.encodeProgression(chordProgression, numChordSteps);
    return this.dataConverter.SEGMENTED_BY_TRACK ? tile(encodedChordProgression, [numSegments, 1]) : encodedChordProgression;
  }
  async encodeTensors(inputTensors, controlArgs) {
    this.checkControlArgs(controlArgs);
    if (!this.initialized) {
      await this.initialize();
    }
    const segmentLengths = this.dataConverter.endTensor ? await this.getSegmentLengths(inputTensors) : void 0;
    return tidy(() => {
      const controlTensor = this.controlArgsToTensor(controlArgs);
      const inputsAndControls = [inputTensors];
      if (controlTensor) {
        const tiles = tile(expandDims(controlTensor, 0), [inputTensors.shape[0], 1, 1]);
        inputsAndControls.push(tiles);
      }
      const inputTensorsWithControls = concat3d(inputsAndControls, 2);
      return this.encoder.encode(inputTensorsWithControls, segmentLengths);
    });
  }
  async encode(inputSequences, controlArgs) {
    if (!this.initialized) {
      await this.initialize();
    }
    const startTime = performance2.now();
    const inputTensors = tidy(() => stack(inputSequences.map((t) => this.dataConverter.toTensor(t))));
    const z = await this.encodeTensors(inputTensors, controlArgs);
    inputTensors.dispose();
    logWithDuration("Encoding completed", startTime, "MusicVAE", 20);
    return z;
  }
  async decodeTensors(z, temperature, controlArgs) {
    this.checkControlArgs(controlArgs);
    if (!this.initialized) {
      await this.initialize();
    }
    return tidy(() => {
      const controlTensor = this.controlArgsToTensor(controlArgs);
      return this.decoder.decode(z, this.dataConverter.numSteps, void 0, temperature, controlTensor);
    });
  }
  async decode(z, temperature, controlArgs, stepsPerQuarter = DEFAULT_STEPS_PER_QUARTER, qpm = DEFAULT_QUARTERS_PER_MINUTE) {
    if (!this.initialized) {
      await this.initialize();
    }
    const startTime = performance2.now();
    const tensors = await this.decodeTensors(z, temperature, controlArgs);
    const ohSeqs = tidy(() => {
      return split(tensors, tensors.shape[0]).map((oh) => oh.squeeze([0]));
    });
    const outputSequences = [];
    for (const oh of ohSeqs) {
      outputSequences.push(await this.dataConverter.toNoteSequence(oh, stepsPerQuarter, qpm));
      oh.dispose();
    }
    tensors.dispose();
    logWithDuration("Decoding completed", startTime, "MusicVAE", 20);
    return outputSequences;
  }
  getInterpolatedZs(z, numInterps) {
    if (typeof numInterps === "number") {
      numInterps = [numInterps];
    }
    if (z.shape[0] !== 2 && z.shape[0] !== 4) {
      throw new Error("Invalid number of input sequences. Requires length 2, or 4");
    }
    if (numInterps.length !== 1 && numInterps.length !== 2) {
      throw new Error("Invalid number of dimensions. Requires length 1, or 2.");
    }
    const w = numInterps[0];
    const h = numInterps.length === 2 ? numInterps[1] : w;
    const interpolatedZs = tidy(() => {
      const rangeX = linspace(0, 1, w);
      const z0 = z.slice([0, 0], [1, z.shape[1]]).as1D();
      const z1 = z.slice([1, 0], [1, z.shape[1]]).as1D();
      if (z.shape[0] === 2) {
        const zDiff = z1.sub(z0);
        return outerProduct(rangeX, zDiff).add(z0);
      } else if (z.shape[0] === 4) {
        const rangeY = linspace(0, 1, h);
        const z2 = z.slice([2, 0], [1, z.shape[1]]).as1D();
        const z3 = z.slice([3, 0], [1, z.shape[1]]).as1D();
        const revRangeX = scalar(1).sub(rangeX);
        const revRangeY = scalar(1).sub(rangeY);
        let finalZs = z0.mul(outerProduct(revRangeY, revRangeX).as3D(h, w, 1));
        finalZs = addStrict(finalZs, z1.mul(outerProduct(rangeY, revRangeX).as3D(h, w, 1)));
        finalZs = addStrict(finalZs, z2.mul(outerProduct(revRangeY, rangeX).as3D(h, w, 1)));
        finalZs = addStrict(finalZs, z3.mul(outerProduct(rangeY, rangeX).as3D(h, w, 1)));
        return finalZs.as2D(w * h, z.shape[1]);
      } else {
        throw new Error("Invalid number of note sequences. Requires length 2, or 4");
      }
    });
    return interpolatedZs;
  }
  async sampleTensors(numSamples, temperature = 0.5, controlArgs) {
    this.checkControlArgs(controlArgs);
    if (!this.initialized) {
      await this.initialize();
    }
    const randZs = tidy(() => randomNormal([numSamples, this.decoder.zDims]));
    const outputTensors = await this.decodeTensors(randZs, temperature, controlArgs);
    randZs.dispose();
    return outputTensors;
  }
  async sample(numSamples, temperature = 0.5, controlArgs, stepsPerQuarter = DEFAULT_STEPS_PER_QUARTER, qpm = DEFAULT_QUARTERS_PER_MINUTE) {
    this.checkControlArgs(controlArgs);
    if (!this.initialized) {
      await this.initialize();
    }
    const startTime = performance2.now();
    const randZs = tidy(() => randomNormal([numSamples, this.decoder.zDims]));
    const outputSequences = this.decode(randZs, temperature, controlArgs, stepsPerQuarter, qpm);
    randZs.dispose();
    outputSequences.then(() => logWithDuration("Sampling completed", startTime, "MusicVAE", 20));
    return outputSequences;
  }
  async similarTensors(inputTensor, numSamples, similarity, temperature, controlArgs) {
    if (similarity < 0 || similarity > 1) {
      throw new Error("Similarity must be between 0 and 1.");
    }
    if (!this.initialized) {
      await this.initialize();
    }
    const inputTensors = expandDims(inputTensor, 0);
    const inputZs = await this.encodeTensors(inputTensors, controlArgs);
    inputTensors.dispose();
    const similarZs = tidy(() => {
      const randZs = randomNormal([numSamples, this.decoder.zDims]);
      return add(inputZs.mul(similarity), randZs.mul(1 - similarity));
    });
    inputZs.dispose();
    const outputTensors = await this.decodeTensors(similarZs, temperature, controlArgs);
    similarZs.dispose();
    return outputTensors;
  }
  async similar(inputSequence, numSamples, similarity, temperature, controlArgs) {
    this.checkControlArgs(controlArgs);
    if (similarity < 0 || similarity > 1) {
      throw new Error("Similarity must be between 0 and 1.");
    }
    if (!this.initialized) {
      await this.initialize();
    }
    const startTime = 0;
    const inputZs = await this.encode([inputSequence], controlArgs);
    const similarZs = tidy(() => {
      const randZs = randomNormal([numSamples, this.decoder.zDims]);
      return add(inputZs.mul(similarity), randZs.mul(1 - similarity));
    });
    inputZs.dispose();
    const outputSequences = this.decode(similarZs, temperature, controlArgs);
    similarZs.dispose();
    outputSequences.then(() => logWithDuration("Similar sequence generation completed", startTime, "MusicVAE", 20));
    return outputSequences;
  }
};

// node_modules/@magenta/music/esm/piano_genie/model.js
var DATA_TIME_QUANTIZE_RATE = 31.25;
var DATA_MAX_DISCRETE_TIMES = 32;
var RNN_NLAYERS = 2;
var RNN_NUNITS = 128;
var NUM_BUTTONS = 8;
var NUM_PIANOKEYS = 88;
function createZeroState() {
  const state = { c: [], h: [] };
  for (let i = 0; i < RNN_NLAYERS; ++i) {
    state.c.push(zeros([1, RNN_NUNITS], "float32"));
    state.h.push(zeros([1, RNN_NUNITS], "float32"));
  }
  return state;
}
function disposeState(state) {
  for (let i = 0; i < RNN_NLAYERS; ++i) {
    state.c[i].dispose();
    state.h[i].dispose();
  }
}
function sampleLogits(logits, temperature, seed) {
  temperature = temperature !== void 0 ? temperature : 1;
  if (temperature < 0 || temperature > 1) {
    throw new Error("Invalid temperature specified");
  }
  let result;
  if (temperature === 0) {
    result = argMax(logits, 0);
  } else {
    if (temperature < 1) {
      logits = div(logits, scalar(temperature, "float32"));
    }
    const scores = reshape(softmax(logits, 0), [1, -1]);
    const sample = multinomial(scores, 1, seed, true);
    result = reshape(sample, []);
  }
  return result;
}
var PianoGenieBase = class {
  constructor(checkpointURL) {
    this.checkpointURL = checkpointURL;
    this.initialized = false;
  }
  isInitialized() {
    return this.initialized;
  }
  async initialize(staticVars) {
    if (this.initialized) {
      this.dispose();
    }
    if (this.checkpointURL === void 0 && staticVars === void 0) {
      throw new Error("Need to specify either URI or static variables");
    }
    if (staticVars === void 0) {
      const vars = await fetch3(`${this.checkpointURL}/weights_manifest.json`).then((response) => response.json()).then((manifest) => io_exports.loadWeights(manifest, this.checkpointURL));
      this.modelVars = vars;
    } else {
      this.modelVars = staticVars;
    }
    this.decLSTMCells = [];
    this.decForgetBias = scalar(1, "float32");
    for (let i = 0; i < RNN_NLAYERS; ++i) {
      const cellPrefix = `phero_model/decoder/rnn/rnn/multi_rnn_cell/cell_${i}/lstm_cell/`;
      this.decLSTMCells.push((data, c, h) => basicLSTMCell(this.decForgetBias, this.modelVars[cellPrefix + "kernel"], this.modelVars[cellPrefix + "bias"], data, c, h));
    }
    this.resetState();
    this.initialized = true;
    this.next(0);
    this.resetState();
  }
  getRnnInputFeats() {
    const feats = tidy(() => {
      const buttonTensor = tensor1d([this.button], "float32");
      const buttonScaled = sub(mul(2, div(buttonTensor, NUM_BUTTONS - 1)), 1);
      return buttonScaled.as1D();
    });
    return feats;
  }
  next(button, temperature, seed) {
    const sampleFunc = (logits) => {
      return sampleLogits(logits, temperature, seed);
    };
    return this.nextWithCustomSamplingFunction(button, sampleFunc);
  }
  nextFromKeyList(button, keyList, temperature, seed) {
    const sampleFunc = (logits) => {
      const keySubsetTensor = tensor1d(keyList, "int32");
      logits = gather(logits, keySubsetTensor);
      let result = sampleLogits(logits, temperature, seed);
      const result1d = gather(keySubsetTensor, reshape(result, [1]));
      result = reshape(result1d, []);
      return result;
    };
    return this.nextWithCustomSamplingFunction(button, sampleFunc);
  }
  nextFromKeyWhitelist(button, keyList, temperature, seed) {
    logging_exports.log("nextFromKeyWhitelist() is deprecated, and will be removed in a future          version. Please use nextFromKeyList() instead", "PianoGenie", 5);
    return this.nextFromKeyList(button, keyList, temperature, seed);
  }
  nextWithCustomSamplingFunction(button, sampleFunc) {
    const lastState = this.lastState;
    this.button = button;
    const rnnInput = this.getRnnInputFeats();
    const [state, output] = this.evaluateModelAndSample(rnnInput, lastState, sampleFunc);
    rnnInput.dispose();
    disposeState(this.lastState);
    this.lastState = state;
    return output;
  }
  evaluateModelAndSample(rnnInput1d, initialState, sampleFunc) {
    if (!this.initialized) {
      throw new Error("Model is not initialized.");
    }
    const [finalState, output] = tidy(() => {
      let rnnInput = matMul(expandDims(rnnInput1d, 0), this.modelVars["phero_model/decoder/rnn_input/dense/kernel"]);
      rnnInput = add(rnnInput, this.modelVars["phero_model/decoder/rnn_input/dense/bias"]);
      const [c, h] = multiRNNCell(this.decLSTMCells, rnnInput, initialState.c, initialState.h);
      const finalState2 = { c, h };
      let logits = matMul(h[RNN_NLAYERS - 1], this.modelVars["phero_model/decoder/pitches/dense/kernel"]);
      logits = add(logits, this.modelVars["phero_model/decoder/pitches/dense/bias"]);
      const logits1D = reshape(logits, [NUM_PIANOKEYS]);
      const sample = sampleFunc(logits1D);
      const output2 = sample.dataSync()[0];
      return [finalState2, output2];
    });
    return [finalState, output];
  }
  resetState() {
    if (this.lastState !== void 0) {
      disposeState(this.lastState);
    }
    this.lastState = createZeroState();
  }
  dispose() {
    if (!this.initialized) {
      return;
    }
    Object.keys(this.modelVars).forEach((name) => this.modelVars[name].dispose());
    this.decForgetBias.dispose();
    disposeState(this.lastState);
    this.initialized = false;
  }
};
var PianoGenieAutoregressiveDeltaTime = class extends PianoGenieBase {
  getRnnInputFeats() {
    const feats = tidy(() => {
      const featsArr = [super.getRnnInputFeats()];
      const lastOutput = this.lastOutput;
      const lastTime = this.lastTime;
      const time2 = this.time;
      let deltaTime;
      if (this.deltaTimeOverride === void 0) {
        deltaTime = (time2.getTime() - lastTime.getTime()) / 1e3;
      } else {
        deltaTime = this.deltaTimeOverride;
        this.deltaTimeOverride = void 0;
      }
      const lastOutputTensor = scalar(lastOutput, "int32");
      const lastOutputInc = addStrict(lastOutputTensor, scalar(1, "int32"));
      const lastOutputOh = cast(oneHot(lastOutputInc, NUM_PIANOKEYS + 1), "float32");
      featsArr.push(lastOutputOh);
      const deltaTimeTensor = scalar(deltaTime, "float32");
      const deltaTimeBin = round(mul(deltaTimeTensor, DATA_TIME_QUANTIZE_RATE));
      const deltaTimeTrunc = minimum(deltaTimeBin, DATA_MAX_DISCRETE_TIMES);
      const deltaTimeInt = cast(add(deltaTimeTrunc, 1e-4), "int32");
      const deltaTimeOh = oneHot(deltaTimeInt, DATA_MAX_DISCRETE_TIMES + 1);
      const deltaTimeOhFloat = cast(deltaTimeOh, "float32");
      featsArr.push(deltaTimeOhFloat);
      this.lastTime = time2;
      return concat1d(featsArr);
    });
    return feats;
  }
  nextWithCustomSamplingFunction(button, sampleFunc) {
    this.time = /* @__PURE__ */ new Date();
    const output = super.nextWithCustomSamplingFunction(button, sampleFunc);
    this.lastOutput = output;
    this.lastTime = this.time;
    return output;
  }
  overrideLastOutput(lastOutput) {
    this.lastOutput = lastOutput;
  }
  overrideDeltaTime(deltaTime) {
    this.deltaTimeOverride = deltaTime;
  }
  resetState() {
    super.resetState();
    this.lastOutput = -1;
    this.lastTime = /* @__PURE__ */ new Date();
    this.lastTime.setSeconds(this.lastTime.getSeconds() - 1e5);
    this.time = /* @__PURE__ */ new Date();
  }
};
var PitchClass;
(function(PitchClass2) {
  PitchClass2[PitchClass2["None"] = 0] = "None";
  PitchClass2[PitchClass2["C"] = 1] = "C";
  PitchClass2[PitchClass2["Cs"] = 2] = "Cs";
  PitchClass2[PitchClass2["D"] = 3] = "D";
  PitchClass2[PitchClass2["Eb"] = 4] = "Eb";
  PitchClass2[PitchClass2["E"] = 5] = "E";
  PitchClass2[PitchClass2["F"] = 6] = "F";
  PitchClass2[PitchClass2["Fs"] = 7] = "Fs";
  PitchClass2[PitchClass2["G"] = 8] = "G";
  PitchClass2[PitchClass2["Ab"] = 9] = "Ab";
  PitchClass2[PitchClass2["A"] = 10] = "A";
  PitchClass2[PitchClass2["Bb"] = 11] = "Bb";
  PitchClass2[PitchClass2["B"] = 12] = "B";
})(PitchClass || (PitchClass = {}));
var ChordFamily;
(function(ChordFamily2) {
  ChordFamily2[ChordFamily2["None"] = 0] = "None";
  ChordFamily2[ChordFamily2["Maj"] = 1] = "Maj";
  ChordFamily2[ChordFamily2["Min"] = 2] = "Min";
  ChordFamily2[ChordFamily2["Aug"] = 3] = "Aug";
  ChordFamily2[ChordFamily2["Dim"] = 4] = "Dim";
  ChordFamily2[ChordFamily2["Seven"] = 5] = "Seven";
  ChordFamily2[ChordFamily2["Maj7"] = 6] = "Maj7";
  ChordFamily2[ChordFamily2["Min7"] = 7] = "Min7";
  ChordFamily2[ChordFamily2["Min7b5"] = 8] = "Min7b5";
})(ChordFamily || (ChordFamily = {}));
var PianoGenieAutoregressiveDeltaTimeChord = class extends PianoGenieAutoregressiveDeltaTime {
  getRnnInputFeats() {
    const feats = tidy(() => {
      const feats1d = super.getRnnInputFeats();
      const featsArr = [feats1d];
      const chordRootTensor = scalar(this.chordRoot, "int32");
      const chordRootTensorSubOne = subStrict(chordRootTensor, scalar(1, "int32"));
      const chordRootTensorOh = cast(oneHot(chordRootTensorSubOne, 12), "float32");
      featsArr.push(chordRootTensorOh);
      const chordFamilyTensor = scalar(this.chordFamily, "int32");
      const chordFamilyTensorSubOne = subStrict(chordFamilyTensor, scalar(1, "int32"));
      const chordFamilyTensorOh = cast(oneHot(chordFamilyTensorSubOne, 8), "float32");
      featsArr.push(chordFamilyTensorOh);
      return concat1d(featsArr);
    });
    return feats;
  }
  setChordRoot(chordRoot) {
    this.chordRoot = chordRoot;
  }
  setChordFamily(chordFamily) {
    this.chordFamily = chordFamily;
  }
  resetState() {
    super.resetState();
    this.chordRoot = PitchClass.None;
    this.chordFamily = ChordFamily.None;
  }
};
var PianoGenieAutoregressiveDeltaTimeKeysig = class extends PianoGenieAutoregressiveDeltaTime {
  getRnnInputFeats() {
    const feats = tidy(() => {
      const feats1d = super.getRnnInputFeats();
      const featsArr = [feats1d];
      const keySigTensor = scalar(this.keySignature, "int32");
      const keySigTensorSubOne = subStrict(keySigTensor, scalar(1, "int32"));
      const keySigTensorOh = cast(oneHot(keySigTensorSubOne, 12), "float32");
      featsArr.push(keySigTensorOh);
      return concat1d(featsArr);
    });
    return feats;
  }
  setKeySignature(keySignature) {
    this.keySignature = keySignature;
  }
  resetState() {
    super.resetState();
    this.keySignature = PitchClass.None;
  }
};
var PianoGenieAutoregressiveDeltaTimeKeysigChord = class extends PianoGenieAutoregressiveDeltaTimeKeysig {
  getRnnInputFeats() {
    const feats = tidy(() => {
      const feats1d = super.getRnnInputFeats();
      const featsArr = [feats1d];
      const chordRootTensor = scalar(this.chordRoot, "int32");
      const chordRootTensorSubOne = subStrict(chordRootTensor, scalar(1, "int32"));
      const chordRootTensorOh = cast(oneHot(chordRootTensorSubOne, 12), "float32");
      featsArr.push(chordRootTensorOh);
      const chordFamilyTensor = scalar(this.chordFamily, "int32");
      const chordFamilyTensorSubOne = subStrict(chordFamilyTensor, scalar(1, "int32"));
      const chordFamilyTensorOh = cast(oneHot(chordFamilyTensorSubOne, 8), "float32");
      featsArr.push(chordFamilyTensorOh);
      return concat1d(featsArr);
    });
    return feats;
  }
  setChordRoot(chordRoot) {
    this.chordRoot = chordRoot;
  }
  setChordFamily(chordFamily) {
    this.chordFamily = chordFamily;
  }
  resetState() {
    super.resetState();
    this.chordRoot = PitchClass.None;
    this.chordFamily = ChordFamily.None;
  }
};
var PianoGenieAutoregressiveDeltaTimeKeysigChordFamily = class extends PianoGenieAutoregressiveDeltaTimeKeysig {
  getRnnInputFeats() {
    const feats = tidy(() => {
      const feats1d = super.getRnnInputFeats();
      const featsArr = [feats1d];
      const chordFamilyTensor = scalar(this.chordFamily, "int32");
      const chordFamilyTensorSubOne = subStrict(chordFamilyTensor, scalar(1, "int32"));
      const chordFamilyTensorOh = cast(oneHot(chordFamilyTensorSubOne, 8), "float32");
      featsArr.push(chordFamilyTensorOh);
      return concat1d(featsArr);
    });
    return feats;
  }
  setChordFamily(chordFamily) {
    this.chordFamily = chordFamily;
  }
  resetState() {
    super.resetState();
    this.chordFamily = ChordFamily.None;
  }
};
var PianoGenie = class extends PianoGenieAutoregressiveDeltaTime {
};
var PianoGenieChord = class extends PianoGenieAutoregressiveDeltaTimeChord {
};
var PianoGenieKeysig = class extends PianoGenieAutoregressiveDeltaTimeKeysig {
};
var PianoGenieKeysigChord = class extends PianoGenieAutoregressiveDeltaTimeKeysigChord {
};
var PianoGenieKeysigChordFamily = class extends PianoGenieAutoregressiveDeltaTimeKeysigChordFamily {
};

// node_modules/@magenta/music/esm/core/audio_utils.js
var FFT2 = __toESM(require_fft());
var ndarray = __toESM(require_ndarray());
var resample = __toESM(require_resample());
var SAMPLE_RATE = 16e3;
var offlineCtx = getOfflineAudioContext(SAMPLE_RATE);
async function loadAudioFromUrl(url) {
  return fetch3(url).then((body) => body.arrayBuffer()).then((buffer2) => offlineCtx.decodeAudioData(buffer2));
}
async function loadAudioFromFile(blob) {
  const fileReader = new FileReader();
  const loadFile = new Promise((resolve, reject) => {
    fileReader.onerror = () => {
      fileReader.abort();
      reject(new DOMException("Something went wrong reading that file."));
    };
    fileReader.onload = () => {
      resolve(fileReader.result);
    };
    fileReader.readAsArrayBuffer(blob);
  });
  return loadFile.then((arrayBuffer) => offlineCtx.decodeAudioData(arrayBuffer));
}
function melSpectrogram(y, params) {
  if (!params.power) {
    params.power = 2;
  }
  const stftMatrix = stft(y, params);
  const [spec, nFft] = magSpectrogram(stftMatrix, params.power);
  params.nFft = nFft;
  const melBasis = createMelFilterbank(params);
  return applyWholeFilterbank(spec, melBasis);
}
function powerToDb(spec, amin = 1e-10, topDb = 80) {
  const width = spec.length;
  const height = spec[0].length;
  const logSpec = [];
  for (let i = 0; i < width; i++) {
    logSpec[i] = new Float32Array(height);
  }
  for (let i = 0; i < width; i++) {
    for (let j = 0; j < height; j++) {
      const val = spec[i][j];
      logSpec[i][j] = 10 * Math.log10(Math.max(amin, val));
    }
  }
  if (topDb) {
    if (topDb < 0) {
      throw new Error(`topDb must be non-negative.`);
    }
    for (let i = 0; i < width; i++) {
      const maxVal = max(logSpec[i]);
      for (let j = 0; j < height; j++) {
        logSpec[i][j] = Math.max(logSpec[i][j], maxVal - topDb);
      }
    }
  }
  return logSpec;
}
function getMonoAudio(audioBuffer) {
  if (audioBuffer.numberOfChannels === 1) {
    return audioBuffer.getChannelData(0);
  }
  if (audioBuffer.numberOfChannels !== 2) {
    throw Error(`${audioBuffer.numberOfChannels} channel audio is not supported.`);
  }
  const ch0 = audioBuffer.getChannelData(0);
  const ch1 = audioBuffer.getChannelData(1);
  const mono = new Float32Array(audioBuffer.length);
  for (let i = 0; i < audioBuffer.length; ++i) {
    mono[i] = (ch0[i] + ch1[i]) / 2;
  }
  return mono;
}
async function resampleAndMakeMono(audioBuffer, targetSr = SAMPLE_RATE) {
  if (audioBuffer.sampleRate === targetSr) {
    return getMonoAudio(audioBuffer);
  }
  const sourceSr = audioBuffer.sampleRate;
  const lengthRes = audioBuffer.length * targetSr / sourceSr;
  if (!isSafari) {
    const _offlineCtx = new OfflineAudioContext(audioBuffer.numberOfChannels, audioBuffer.duration * targetSr, targetSr);
    const bufferSource = _offlineCtx.createBufferSource();
    bufferSource.buffer = audioBuffer;
    bufferSource.connect(_offlineCtx.destination);
    bufferSource.start();
    return _offlineCtx.startRendering().then((buffer2) => buffer2.getChannelData(0));
  } else {
    log2("Safari does not support WebAudio resampling, so this may be slow.", "O&F", 5);
    const originalAudio = getMonoAudio(audioBuffer);
    const resampledAudio = new Float32Array(lengthRes);
    resample(ndarray(resampledAudio, [lengthRes]), ndarray(originalAudio, [originalAudio.length]));
    return resampledAudio;
  }
}
function magSpectrogram(stft2, power) {
  const spec = stft2.map((fft2) => pow2(mag(fft2), power));
  const nFft = stft2[0].length - 1;
  return [spec, nFft];
}
function stft(y, params) {
  const nFft = params.nFft || 2048;
  const winLength = params.winLength || nFft;
  const hopLength = params.hopLength || Math.floor(winLength / 4);
  let fftWindow = hannWindow(winLength);
  fftWindow = padCenterToLength(fftWindow, nFft);
  y = padReflect(y, Math.floor(nFft / 2));
  const yFrames = frame(y, nFft, hopLength);
  const stftMatrix = [];
  const width = yFrames.length;
  const height = nFft + 2;
  for (let i = 0; i < width; i++) {
    const col = new Float32Array(height);
    stftMatrix[i] = col;
  }
  for (let i = 0; i < width; i++) {
    const winBuffer = applyWindow(yFrames[i], fftWindow);
    const col = fft(winBuffer);
    stftMatrix[i].set(col.slice(0, height));
  }
  return stftMatrix;
}
function applyWholeFilterbank(spec, filterbank) {
  const out = [];
  for (let i = 0; i < spec.length; i++) {
    out[i] = applyFilterbank(spec[i], filterbank);
  }
  return out;
}
function applyFilterbank(mags, filterbank) {
  if (mags.length !== filterbank[0].length) {
    throw new Error(`Each entry in filterbank should have dimensions matching FFT. |mags| = ${mags.length}, |filterbank[0]| = ${filterbank[0].length}.`);
  }
  const out = new Float32Array(filterbank.length);
  for (let i = 0; i < filterbank.length; i++) {
    const win = applyWindow(mags, filterbank[i]);
    out[i] = win.reduce((a, b) => a + b);
  }
  return out;
}
function applyWindow(buffer2, win) {
  if (buffer2.length !== win.length) {
    console.error(`Buffer length ${buffer2.length} != window length ${win.length}.`);
    return null;
  }
  const out = new Float32Array(buffer2.length);
  for (let i = 0; i < buffer2.length; i++) {
    out[i] = win[i] * buffer2[i];
  }
  return out;
}
function padCenterToLength(data, length) {
  if (data.length > length) {
    throw new Error("Data is longer than length.");
  }
  const paddingLeft = Math.floor((length - data.length) / 2);
  const paddingRight = length - data.length - paddingLeft;
  return padConstant(data, [paddingLeft, paddingRight]);
}
function padConstant(data, padding) {
  let padLeft, padRight;
  if (typeof padding === "object") {
    [padLeft, padRight] = padding;
  } else {
    padLeft = padRight = padding;
  }
  const out = new Float32Array(data.length + padLeft + padRight);
  out.set(data, padLeft);
  return out;
}
function padReflect(data, padding) {
  const out = padConstant(data, padding);
  for (let i = 0; i < padding; i++) {
    out[i] = out[2 * padding - i];
    out[out.length - i - 1] = out[out.length - 2 * padding + i - 1];
  }
  return out;
}
function frame(data, frameLength, hopLength) {
  const bufferCount = Math.floor((data.length - frameLength) / hopLength) + 1;
  const buffers = Array.from({ length: bufferCount }, (x, i) => new Float32Array(frameLength));
  for (let i = 0; i < bufferCount; i++) {
    const ind = i * hopLength;
    const buffer2 = data.slice(ind, ind + frameLength);
    buffers[i].set(buffer2);
    if (buffer2.length !== frameLength) {
      continue;
    }
  }
  return buffers;
}
function createMelFilterbank(params) {
  const fMin = params.fMin || 0;
  const fMax = params.fMax || params.sampleRate / 2;
  const nMels = params.nMels || 128;
  const nFft = params.nFft || 2048;
  const fftFreqs = calculateFftFreqs(params.sampleRate, nFft);
  const melFreqs = calculateMelFreqs(nMels + 2, fMin, fMax);
  const melDiff = internalDiff(melFreqs);
  const ramps = outerSubtract(melFreqs, fftFreqs);
  const filterSize = ramps[0].length;
  const weights = [];
  for (let i = 0; i < nMels; i++) {
    weights[i] = new Float32Array(filterSize);
    for (let j = 0; j < ramps[i].length; j++) {
      const lower = -ramps[i][j] / melDiff[i];
      const upper = ramps[i + 2][j] / melDiff[i + 1];
      const weight = Math.max(0, Math.min(lower, upper));
      weights[i][j] = weight;
    }
  }
  for (let i = 0; i < weights.length; i++) {
    const enorm = 2 / (melFreqs[2 + i] - melFreqs[i]);
    weights[i] = weights[i].map((val) => val * enorm);
  }
  return weights;
}
function fft(y) {
  const fft2 = new FFT2(y.length);
  const out = fft2.createComplexArray();
  const data = fft2.toComplexArray(y);
  fft2.transform(out, data);
  return out;
}
function hannWindow(length) {
  const win = new Float32Array(length);
  for (let i = 0; i < length; i++) {
    win[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / (length - 1)));
  }
  return win;
}
function linearSpace(start2, end, count) {
  const delta = (end - start2) / (count - 1);
  const out = new Float32Array(count);
  for (let i = 0; i < count; i++) {
    out[i] = start2 + delta * i;
  }
  return out;
}
function mag(y) {
  const out = new Float32Array(y.length / 2);
  for (let i = 0; i < y.length / 2; i++) {
    out[i] = Math.sqrt(y[i * 2] * y[i * 2] + y[i * 2 + 1] * y[i * 2 + 1]);
  }
  return out;
}
function midiToHz(notes) {
  let notesTensor = sub(notes, 69);
  notesTensor = div(notesTensor, 12);
  notesTensor = pow(2, notesTensor);
  notesTensor = mul(440, notesTensor);
  return notesTensor;
}
async function hzToMidi(frequencies) {
  let frequenciesTensor = sub(div(log(frequencies), log(2)), div(log(440), log(2)));
  frequenciesTensor = mul(12, frequenciesTensor);
  frequenciesTensor = add(frequenciesTensor, 69);
  const frequenciesVal = await frequenciesTensor.array();
  return frequenciesVal;
}
function hzToMel(hz) {
  return 1125 * Math.log(1 + hz / 700);
}
function melToHz(mel) {
  return 700 * (Math.exp(mel / 1125) - 1);
}
function calculateFftFreqs(sampleRate, nFft) {
  return linearSpace(0, sampleRate / 2, Math.floor(1 + nFft / 2));
}
function calculateMelFreqs(nMels, fMin, fMax) {
  const melMin = hzToMel(fMin);
  const melMax = hzToMel(fMax);
  const mels = linearSpace(melMin, melMax, nMels);
  const hzs = mels.map((mel) => melToHz(mel));
  return hzs;
}
function internalDiff(arr) {
  const out = new Float32Array(arr.length - 1);
  for (let i = 0; i < arr.length; i++) {
    out[i] = arr[i + 1] - arr[i];
  }
  return out;
}
function outerSubtract(arr, arr2) {
  const out = [];
  for (let i = 0; i < arr.length; i++) {
    out[i] = new Float32Array(arr2.length);
  }
  for (let i = 0; i < arr.length; i++) {
    for (let j = 0; j < arr2.length; j++) {
      out[i][j] = arr[i] - arr2[j];
    }
  }
  return out;
}
function pow2(arr, power) {
  return arr.map((v) => Math.pow(v, power));
}
function max(arr) {
  return arr.reduce((a, b) => Math.max(a, b));
}

// node_modules/@magenta/music/esm/transcription/constants.js
var SAMPLE_RATE2 = 16e3;
var SPEC_HOP_LENGTH = 512;
var FRAME_LENGTH_SECONDS = SPEC_HOP_LENGTH / SAMPLE_RATE2;
var MEL_SPEC_BINS = 229;
var MIN_MIDI_PITCH2 = 21;
var MAX_MIDI_PITCH2 = 108;
var MIDI_PITCHES2 = MAX_MIDI_PITCH2 - MIN_MIDI_PITCH2 + 1;

// node_modules/@magenta/music/esm/transcription/audio_utils.js
async function preprocessAudio(audioBuffer) {
  const resampledMonoAudio = await resampleAndMakeMono(audioBuffer);
  return powerToDb(melSpectrogram(resampledMonoAudio, {
    sampleRate: SAMPLE_RATE2,
    hopLength: SPEC_HOP_LENGTH,
    nMels: MEL_SPEC_BINS,
    nFft: 2048,
    fMin: 30
  }));
}

// node_modules/@magenta/music/esm/transcription/transcription_utils.js
var RF_PAD = 3;
function batchInput(input2, batchLength) {
  let batchSize = Math.ceil(input2.length / batchLength);
  let batchRemainder = input2.length % batchLength;
  let mergedRemainder = 0;
  if (batchSize > 1 && batchRemainder > 0 && batchRemainder <= RF_PAD) {
    batchSize -= 1;
    mergedRemainder = batchRemainder;
    batchRemainder = 0;
  }
  if (batchSize === 1) {
    return tensor2d(input2).expandDims(0);
  }
  const actualBatchLength = batchLength + 2 * RF_PAD;
  const firstBatch = tensor2d(input2.slice(0, actualBatchLength)).expandDims(0);
  const lastBatch = tensor2d(input2.slice(input2.length - actualBatchLength)).expandDims(0);
  if (batchSize === 2) {
    return concat([firstBatch, lastBatch], 0);
  }
  let naivePaddedBatches;
  if (batchRemainder) {
    naivePaddedBatches = tensor2d(input2).pad([[0, batchLength - batchRemainder], [0, 0]]).as3D(batchSize, batchLength, -1);
  } else {
    naivePaddedBatches = tensor2d(input2.slice(0, input2.length - mergedRemainder)).as3D(batchSize, batchLength, -1);
  }
  const leftPad = slice(naivePaddedBatches, [0, batchLength - RF_PAD], [batchSize - 2, -1]);
  const rightPad = slice(naivePaddedBatches, [2, 0], [-1, RF_PAD]);
  const midBatches = concat([leftPad, naivePaddedBatches.slice(1, batchSize - 2), rightPad], 1);
  return concat([firstBatch, midBatches, lastBatch], 0);
}
function unbatchOutput(batches, batchLength, totalLength) {
  if (batches.shape[0] === 1) {
    return batches;
  }
  return tidy(() => {
    const firstBatch = batches.slice([0, 0], [1, batchLength]);
    let finalBatchLength = totalLength % batchLength;
    if (finalBatchLength <= RF_PAD) {
      finalBatchLength += batchLength;
    }
    const finalBatch = batches.slice([batches.shape[0] - 1, batches.shape[1] - finalBatchLength], [-1, -1]);
    let toConcat = [firstBatch, finalBatch];
    if (batches.shape[0] > 2) {
      const midBatchSize = batches.shape[0] - 2;
      const midBatches = batches.slice([1, RF_PAD], [midBatchSize, batchLength]);
      toConcat = [
        firstBatch,
        midBatches.as3D(1, midBatchSize * batchLength, -1),
        finalBatch
      ];
    }
    return concat(toConcat, 1);
  });
}
async function pianorollToNoteSequence(frameProbs, onsetProbs, velocityValues, onsetThreshold = 0.5, frameThreshold = 0.5) {
  const ns = NoteSequence.create();
  const pitchStartStepPlusOne = new Uint32Array(MIDI_PITCHES2);
  const onsetVelocities = new Uint8Array(MIDI_PITCHES2);
  let previousOnsets = new Uint8Array(MIDI_PITCHES2);
  function endPitch(pitch, endFrame) {
    ns.notes.push(NoteSequence.Note.create({
      pitch: pitch + MIN_MIDI_PITCH2,
      startTime: (pitchStartStepPlusOne[pitch] - 1) * FRAME_LENGTH_SECONDS,
      endTime: endFrame * FRAME_LENGTH_SECONDS,
      velocity: onsetVelocities[pitch]
    }));
    pitchStartStepPlusOne[pitch] = 0;
  }
  function processOnset(p, f, velocity) {
    if (pitchStartStepPlusOne[p]) {
      if (!previousOnsets[p]) {
        endPitch(p, f);
        pitchStartStepPlusOne[p] = f + 1;
        onsetVelocities[p] = velocity;
      }
    } else {
      pitchStartStepPlusOne[p] = f + 1;
      onsetVelocities[p] = velocity;
    }
  }
  const predictions = tidy(() => {
    let onsetPredictions = greater(onsetProbs, onsetThreshold);
    let framePredictions = greater(frameProbs, frameThreshold);
    onsetPredictions = onsetPredictions.pad([[0, 1], [0, 0]]);
    framePredictions = framePredictions.pad([[0, 1], [0, 0]]);
    velocityValues = velocityValues.pad([[0, 1], [0, 0]]);
    framePredictions = logicalOr(framePredictions, onsetPredictions);
    return [framePredictions, onsetPredictions, velocityValues];
  });
  const [frames, onsets, velocities] = await Promise.all(predictions.map((t) => t.data()));
  predictions.forEach((t) => t.dispose());
  const numFrames = frameProbs.shape[0];
  for (let f = 0; f < numFrames + 1; ++f) {
    for (let p = 0; p < MIDI_PITCHES2; ++p) {
      const i = f * MIDI_PITCHES2 + p;
      if (onsets[i]) {
        processOnset(p, f, velocities[i]);
      } else if (!frames[i] && pitchStartStepPlusOne[p]) {
        endPitch(p, f);
      }
    }
    previousOnsets = onsets.slice(f * MIDI_PITCHES2, (f + 1) * MIDI_PITCHES2);
  }
  ns.totalTime = numFrames * FRAME_LENGTH_SECONDS;
  return ns;
}

// node_modules/@magenta/music/esm/transcription/model.js
var OnsetsAndFrames = class {
  constructor(checkpointURL, chunkLength = 250) {
    this.checkpointURL = checkpointURL;
    this.chunkLength = chunkLength;
  }
  async initialize() {
    this.dispose();
    const startTime = performance2.now();
    const vars = await fetch3(`${this.checkpointURL}/weights_manifest.json`).then((response) => response.json()).then((manifest) => io_exports.loadWeights(manifest, this.checkpointURL));
    this.build(vars);
    Object.keys(vars).map((name) => vars[name].dispose());
    this.initialized = true;
    logWithDuration("Initialized model", startTime, "O&F");
  }
  dispose() {
    if (!this.initialized) {
      return;
    }
    this.onsetsCnn.dispose();
    this.onsetsRnn.dispose();
    this.activationCnn.dispose();
    this.frameRnn.dispose();
    this.velocityCnn.dispose();
    this.initialized = false;
  }
  isInitialized() {
    return this.initialized;
  }
  async transcribeFromMelSpec(melSpec, parallelBatches = 4) {
    if (!this.isInitialized()) {
      this.initialize();
    }
    const startTime = performance2.now();
    log2("Computing onsets, frames, and velocities...", "O&F", 20);
    const [frameProbs, onsetProbs, velocities] = tidy(() => {
      const batches = batchInput(melSpec, this.chunkLength);
      return this.processBatches(batches, this.chunkLength, melSpec.length, parallelBatches);
    });
    log2("Converting to NoteSequence...", "O&F", 20);
    const ns = pianorollToNoteSequence(frameProbs, onsetProbs, velocities);
    ns.then(() => {
      frameProbs.dispose();
      onsetProbs.dispose();
      velocities.dispose();
      logWithDuration("Transcribed from mel spec", startTime, "O&F");
    });
    return ns;
  }
  async transcribeFromAudioBuffer(audioBuffer, batchSize = 4) {
    const startTime = performance2.now();
    const melSpec = preprocessAudio(audioBuffer);
    melSpec.then(() => logWithDuration("Converted audio to mel spec", startTime, "O&F", 20));
    return melSpec.then((spec) => this.transcribeFromMelSpec(spec.map((a) => Array.from(a), batchSize)));
  }
  async transcribeFromAudioFile(blob) {
    const audio = await loadAudioFromFile(blob);
    return this.transcribeFromAudioBuffer(audio);
  }
  async transcribeFromAudioURL(url) {
    const audio = await loadAudioFromUrl(url);
    return this.transcribeFromAudioBuffer(audio);
  }
  processBatches(batches, chunkLength, fullLength, batchSize) {
    const runCnns = ((batch) => [
      this.onsetsCnn.predict(batch, batchSize),
      this.activationCnn.predict(batch, batchSize),
      this.velocityCnn.predict(batch, batchSize)
    ]);
    let onsetsCnnOut, activationProbs, scaledVelocities;
    if (batches.shape[0] === 1) {
      [onsetsCnnOut, activationProbs, scaledVelocities] = runCnns(batches.expandDims(-1));
    } else {
      const batchesOutput = runCnns(batches.expandDims(-1));
      const allOutputs = [];
      for (let i = 0; i < 3; ++i) {
        allOutputs.push(unbatchOutput(batchesOutput[i], chunkLength, fullLength));
      }
      [onsetsCnnOut, activationProbs, scaledVelocities] = allOutputs;
    }
    const onsetProbs = this.onsetsRnn.predict(onsetsCnnOut, this.chunkLength);
    onsetsCnnOut.dispose();
    const frameProbInputs = concat3d([onsetProbs, activationProbs], -1);
    activationProbs.dispose();
    const frameProbs = this.frameRnn.predict(frameProbInputs, this.chunkLength);
    const velocities = clipByValue(scaledVelocities, 0, 1).mul(scalar(80)).add(scalar(10)).toInt();
    scaledVelocities.dispose();
    return [frameProbs.squeeze(), onsetProbs.squeeze(), velocities.squeeze()];
  }
  build(vars) {
    tidy(() => {
      this.onsetsCnn = new AcousticCnn();
      this.onsetsCnn.setWeights(vars, "onsets");
      this.onsetsRnn = new Lstm([null, this.onsetsCnn.outputShape[2]]);
      this.onsetsRnn.setWeights(vars, "onsets", "onset_probs");
      this.activationCnn = new AcousticCnn("sigmoid");
      this.activationCnn.setWeights(vars, "frame", "activation_probs");
      this.frameRnn = new Lstm([null, MIDI_PITCHES2 * 2]);
      this.frameRnn.setWeights(vars, "frame", "frame_probs");
      this.velocityCnn = new AcousticCnn("linear");
      this.velocityCnn.setWeights(vars, "velocity", "onset_velocities");
    });
  }
};
var AcousticCnn = class {
  constructor(finalDenseActivation) {
    this.nn = sequential();
    const convConfig = {
      filters: 48,
      kernelSize: [3, 3],
      activation: "linear",
      useBias: false,
      padding: "same",
      dilationRate: [1, 1],
      inputShape: [null, MEL_SPEC_BINS, 1],
      trainable: false
    };
    const batchNormConfig = { scale: false, trainable: false };
    this.nn.add(exports_layers_exports.conv2d(convConfig));
    this.nn.add(exports_layers_exports.batchNormalization(batchNormConfig));
    this.nn.add(exports_layers_exports.activation({ activation: "relu" }));
    convConfig.inputShape = null;
    this.nn.add(exports_layers_exports.conv2d(convConfig));
    this.nn.add(exports_layers_exports.batchNormalization(batchNormConfig));
    this.nn.add(exports_layers_exports.activation({ activation: "relu" }));
    this.nn.add(exports_layers_exports.maxPooling2d({ poolSize: [1, 2], strides: [1, 2] }));
    convConfig.filters = 96;
    this.nn.add(exports_layers_exports.conv2d(convConfig));
    this.nn.add(exports_layers_exports.batchNormalization(batchNormConfig));
    this.nn.add(exports_layers_exports.activation({ activation: "relu" }));
    this.nn.add(exports_layers_exports.maxPooling2d({ poolSize: [1, 2], strides: [1, 2] }));
    const dims = this.nn.outputShape;
    this.nn.add(exports_layers_exports.reshape({ targetShape: [dims[1], dims[2] * dims[3]] }));
    this.nn.add(exports_layers_exports.dense({ units: 768, activation: "relu", trainable: false }));
    if (finalDenseActivation) {
      this.nn.add(exports_layers_exports.dense({
        units: MIDI_PITCHES2,
        activation: finalDenseActivation,
        trainable: false
      }));
    }
    this.outputShape = this.nn.outputShape;
  }
  dispose() {
    this.nn.dispose();
  }
  predict(inputs, batchSize) {
    return this.nn.predict(inputs, { batchSize });
  }
  setWeights(vars, scope, denseName) {
    function getVar(name) {
      const v = vars[name];
      if (v === void 0) {
        throw Error(`Variable not found: ${name}`);
      }
      return v;
    }
    let weights = [
      getVar(`${scope}/conv0/weights`),
      getVar(`${scope}/conv0/BatchNorm/beta`),
      getVar(`${scope}/conv0/BatchNorm/moving_mean`),
      getVar(`${scope}/conv0/BatchNorm/moving_variance`),
      getVar(`${scope}/conv1/weights`),
      getVar(`${scope}/conv1/BatchNorm/beta`),
      getVar(`${scope}/conv1/BatchNorm/moving_mean`),
      getVar(`${scope}/conv1/BatchNorm/moving_variance`),
      getVar(`${scope}/conv2/weights`),
      getVar(`${scope}/conv2/BatchNorm/beta`),
      getVar(`${scope}/conv2/BatchNorm/moving_mean`),
      getVar(`${scope}/conv2/BatchNorm/moving_variance`),
      getVar(`${scope}/fc_end/weights`),
      getVar(`${scope}/fc_end/biases`)
    ];
    if (denseName) {
      weights = weights.concat([
        getVar(`${scope}/${denseName}/weights`),
        getVar(`${scope}/${denseName}/biases`)
      ]);
    }
    this.nn.setWeights(weights);
  }
};
var Lstm = class {
  constructor(inputShape, units = 384) {
    this.dense = sequential();
    this.units = units;
    function getLstm() {
      const lstm = exports_layers_exports.lstm({
        inputShape,
        units,
        returnSequences: true,
        recurrentActivation: "sigmoid",
        returnState: true,
        kernelInitializer: "zeros",
        recurrentInitializer: "zeros",
        biasInitializer: "zeros",
        trainable: false
      });
      const inputs = [
        input({ shape: inputShape }),
        input({ shape: [units] }),
        input({ shape: [units] })
      ];
      const outputs = lstm.apply(inputs);
      return model({ inputs, outputs });
    }
    this.lstm = getLstm();
    this.dense.add(exports_layers_exports.dense({
      inputShape: [null, units],
      units: MIDI_PITCHES2,
      activation: "sigmoid",
      trainable: false
    }));
  }
  dispose() {
    this.lstm.dispose();
    this.dense.dispose();
  }
  setWeights(vars, scope, denseName) {
    function getVar(name) {
      const v = vars[name];
      if (v === void 0) {
        throw Error(`Variable not found: ${name}`);
      }
      return v;
    }
    const reorderGates = ((weights, forgetBias = 0) => {
      const [i, c, f, o] = split(weights, 4, -1);
      return concat([i, f.add(scalar(forgetBias)), c, o], -1);
    });
    const splitAndReorderKernel = ((kernel) => split(reorderGates(kernel), [kernel.shape[0] - this.units, this.units]));
    const LSTM_PREFIX = "cudnn_lstm/rnn/multi_rnn_cell/cell_0/cudnn_compatible_lstm_cell";
    const setLstmWeights = (lstm) => lstm.setWeights(splitAndReorderKernel(getVar(`${scope}/${LSTM_PREFIX}/kernel`)).concat(reorderGates(getVar(`${scope}/${LSTM_PREFIX}/bias`), 1)));
    setLstmWeights(this.lstm);
    this.dense.setWeights([
      getVar(`${scope}/${denseName}/weights`),
      getVar(`${scope}/${denseName}/biases`)
    ]);
  }
  predict(inputs, chunkSize) {
    return tidy(() => this.predictImpl(inputs, chunkSize));
  }
  predictImpl(inputs, chunkSize) {
    const fullLength = inputs.shape[1];
    const numChunks = Math.ceil(fullLength / chunkSize);
    let state = [zeros([1, this.units]), zeros([1, this.units])];
    const outputChunks = [];
    for (let i = 0; i < numChunks; ++i) {
      const chunk = inputs.slice([0, i * chunkSize], [-1, i < numChunks - 1 ? chunkSize : -1]);
      const result = this.lstm.predict([
        chunk,
        state[0],
        state[1]
      ]);
      outputChunks.push(this.dense.predict(result[0]));
      state = result.slice(1);
    }
    return outputChunks.length === 1 ? outputChunks[0] : concat3d(outputChunks, 1);
  }
};

// node_modules/@magenta/music/esm/gansynth/audio_utils.js
var FFT3 = __toESM(require_fft());

// node_modules/@magenta/music/esm/gansynth/constants.js
var MAG_DESCALE_A = 0.0661371661726;
var MAG_DESCALE_B = 0.113718730221;
var PHASE_DESCALE_A = 0.8;
var PHASE_DESCALE_B = 0;
var SAMPLE_RATE3 = 16e3;
var SAMPLE_LENGTH = 64e3;
var N_HOP = 512;
var N_FFT = 2048;

// node_modules/@magenta/music/esm/gansynth/mel_sparse_coeffs.js
var MEL_SPARSE_COEFFS = [
  [1, 1, 1.0087615084725814],
  [2, 1, 0.029087889211125567],
  [2, 2, 0.958243896036208],
  [3, 2, 0.5326346877272624],
  [3, 3, 0.45988057223186607],
  [4, 3, 1.0072850129664943],
  [5, 4, 1.0050894259864507],
  [6, 4, 0.016233689242197466],
  [6, 5, 0.9763230964529687],
  [7, 5, 0.5149287456976357],
  [7, 6, 0.48299891928441196],
  [8, 6, 1.0020339883784544],
  [9, 7, 1.0013940582804204],
  [10, 7, 0.004285414445239434],
  [10, 8, 0.9936677765505681],
  [11, 8, 0.4979349533263788],
  [11, 9, 0.5020647178266697],
  [12, 9, 0.9896782321684733],
  [12, 10, 0.006967080931645349],
  [13, 10, 1.0022486641537054],
  [14, 11, 1.0033233953996759],
  [15, 11, 0.4782757843614299],
  [15, 12, 0.5183887055972138],
  [16, 12, 0.9736767011426267],
  [16, 13, 0.01804416217807709],
  [17, 13, 1.0056329663266226],
  [18, 14, 1.00808642668908],
  [19, 14, 0.4576416347984229],
  [19, 15, 0.5340800956534676],
  [20, 15, 0.9582897445862256],
  [20, 16, 0.028988367857957848],
  [21, 16, 1.008754652772106],
  [22, 17, 1.0122552436937966],
  [23, 17, 0.4380796830853842],
  [23, 18, 0.5491738237632201],
  [24, 18, 0.9434838949694413],
  [24, 19, 0.039794474296176746],
  [25, 19, 1.0116287566447584],
  [26, 20, 1.0158945544322868],
  [27, 20, 0.41952402212367873],
  [27, 21, 0.5637020154076856],
  [28, 21, 0.9292283399303117],
  [28, 22, 0.05045785324282485],
  [29, 22, 1.0142694870195312],
  [30, 23, 1.0190617246342517],
  [31, 23, 0.40191289323704393],
  [31, 24, 0.5776942788784806],
  [32, 24, 0.915494649120402],
  [32, 25, 0.060974426459003916],
  [33, 25, 1.016690283888679],
  [34, 26, 1.0218076651124588],
  [35, 26, 0.3851885348435194],
  [35, 27, 0.5911779611807773],
  [36, 27, 0.9022565352474414],
  [36, 28, 0.07134062388959171],
  [37, 28, 1.0189038677945517],
  [38, 29, 1.0241776077147466],
  [39, 29, 0.369297000124277],
  [39, 30, 0.6041783722578726],
  [40, 30, 0.8894896443111251],
  [40, 31, 0.08155334505527755],
  [41, 31, 1.0209222848386956],
  [42, 32, 1.0262117836546005],
  [43, 32, 0.35418795675261777],
  [43, 33, 0.6167189821271176],
  [44, 33, 0.87717137085618],
  [44, 34, 0.09160992335204851],
  [45, 34, 1.0227569476841007],
  [46, 35, 1.0279460165329002],
  [47, 35, 0.3398144781420294],
  [47, 36, 0.628821594757742],
  [48, 36, 0.8652806947525041],
  [48, 37, 0.10150809298528844],
  [49, 37, 1.0244186730654867],
  [50, 38, 1.029412240942602],
  [51, 38, 0.32613283297317347],
  [51, 39, 0.6405065019041107],
  [52, 39, 0.8537980365619783],
  [52, 40, 0.11124595830527892],
  [53, 40, 1.0259177162406141],
  [54, 41, 1.030638956235277],
  [55, 41, 0.3131022777355948],
  [55, 42, 0.6517926196031543],
  [56, 42, 0.8427051290118196],
  [56, 43, 0.12082196533877268],
  [57, 43, 1.0272638027474759],
  [58, 44, 1.031651623831845],
  [59, 44, 0.3006848555240512],
  [59, 45, 0.6626976096262132],
  [60, 45, 0.8319849024715039],
  [60, 46, 0.13023487533380312],
  [61, 46, 1.0284661577762764],
  [62, 47, 1.0324730153919173],
  [63, 47, 0.28884520321029805],
  [63, 48, 0.6732379878311283],
  [64, 48, 0.821621382643116],
  [64, 49, 0.1394837401591093],
  [65, 49, 1.0295335334192939],
  [66, 50, 1.0331235182054521],
  [67, 50, 0.27755036829985363],
  [67, 51, 0.68342922107227],
  [68, 51, 0.8115995989355603],
  [68, 52, 0.148567879414825],
  [69, 52, 1.0304742340231496],
  [70, 53, 1.0336214033370148],
  [71, 53, 0.2667696361817086],
  [71, 54, 0.6932858140884962],
  [72, 54, 0.8019055022130549],
  [72, 55, 0.1574868591255191],
  [73, 55, 1.031296139836255],
  [74, 56, 1.0339830613212895],
  [75, 56, 0.2564743680536822],
  [75, 57, 0.7028213875855097],
  [76, 57, 0.7925258907912134],
  [76, 58, 0.16624047189958738],
  [77, 58, 1.032006729117501],
  [78, 59, 1.0342232095724524],
  [79, 59, 0.24663784949713183],
  [79, 60, 0.7120487485622758],
  [80, 60, 0.7834483437084975],
  [80, 61, 0.17482871845079165],
  [81, 61, 1.032613098850059],
  [82, 62, 1.0343550751159198],
  [83, 62, 0.2372351494674972],
  [83, 63, 0.7209799537859948],
  [84, 63, 0.7746611604312031],
  [84, 64, 0.18325179038711914],
  [85, 64, 1.0331219841851924],
  [86, 65, 1.0343905557724016],
  [87, 65, 0.22824298931879333],
  [87, 66, 0.7296263672031092],
  [88, 66, 0.7661533062642226],
  [88, 67, 0.19151005417692718],
  [89, 67, 1.0335397767254908],
  [90, 68, 1.0343403625078313],
  [91, 68, 0.21963962139622123],
  [91, 69, 0.7379987119645334],
  [92, 69, 0.7579143628308538],
  [92, 70, 0.19960403621540457],
  [93, 70, 1.0338725417430177],
  [94, 71, 1.0342141453043734],
  [95, 71, 0.21140471667072153],
  [95, 72, 0.746107117663542],
  [96, 72, 0.7499344830670268],
  [96, 73, 0.20753440891552338],
  [97, 73, 1.0341260344172454],
  [98, 74, 1.034020604597683],
  [99, 74, 0.20351926086574523],
  [99, 75, 0.7539611633021215],
  [100, 75, 0.7422043502477234],
  [100, 76, 0.2153019777561019],
  [101, 76, 1.0343057151671131],
  [102, 77, 1.0337675900563705],
  [103, 77, 0.19596545852169872],
  [103, 78, 0.7615699164421695],
  [104, 78, 0.734715140616724],
  [104, 79, 0.22290766922455862],
  [105, 79, 1.034416764143981],
  [106, 80, 1.03346218824938],
  [107, 80, 0.1887266444456389],
  [107, 81, 0.7689419689404797],
  [108, 81, 0.7274584892496355],
  [108, 82, 0.23035251959385997],
  [109, 82, 1.0344640949448594],
  [110, 83, 1.0331108005456808],
  [111, 83, 0.18178720201436843],
  [111, 84, 0.7760854696185804],
  [112, 84, 0.7204264588178948],
  [112, 85, 0.23763766448199494],
  [113, 85, 1.0344523675990727],
  [114, 86, 1.032719212418228],
  [115, 86, 0.1751324878193402],
  [115, 87, 0.7830081541774375],
  [116, 87, 0.7136115109646374],
  [116, 88, 0.2447643291417676],
  [117, 88, 1.0343860008764458],
  [118, 89, 1.0322926551739824],
  [119, 89, 0.16874876216974247],
  [119, 90, 0.789717372631832],
  [120, 90, 0.7070064800338803],
  [120, 91, 0.2517338194331562],
  [121, 91, 1.0342691839607763],
  [122, 92, 1.0318358610025598],
  [123, 92, 0.16262312499771858],
  [123, 93, 0.7962201145052664],
  [124, 93, 0.7006045489251309],
  [124, 94, 0.25854751343650967],
  [125, 94, 1.0341058875275075],
  [126, 95, 1.0313531121234998],
  [127, 95, 0.15674345673841866],
  [127, 96, 0.8025230320033012],
  [128, 96, 0.6943992268713032],
  [128, 97, 0.2652068536620191],
  [129, 97, 1.033899874262366],
  [130, 98, 1.030848284714744],
  [131, 98, 0.1510983637896712],
  [131, 99, 0.8086324613545763],
  [132, 99, 0.6883843289574696],
  [132, 100, 0.2717133398209474],
  [133, 100, 1.033654708853177],
  [134, 101, 1.0303248882205327],
  [135, 101, 0.14567712818173575],
  [135, 102, 0.8145544424922615],
  [136, 102, 0.6825539572209546],
  [136, 103, 0.2780685221191216],
  [137, 103, 1.033373767485838],
  [138, 104, 1.0297861005632643],
  [139, 104, 0.14046966111762169],
  [139, 105, 0.8202947372282664],
  [140, 105, 0.6769024831869065],
  [140, 106, 0.28427399504058354],
  [141, 106, 1.0330602468722847],
  [142, 107, 1.029234799720434],
  [143, 107, 0.13546646006984392],
  [143, 108, 0.8258588460540109],
  [144, 108, 0.671424531713726],
  [144, 109, 0.290331391589362],
  [145, 109, 1.0327171728357682],
  [146, 110, 1.0286735920712562],
  [147, 110, 0.13065856914309196],
  [147, 111, 0.8312520236957351],
  [148, 111, 0.6661149660273628],
  [148, 112, 0.2962423779602388],
  [149, 112, 1.03234740847843],
  [150, 113, 1.0281048378703825],
  [151, 113, 0.12603754244145],
  [151, 114, 0.8364792935255917],
  [152, 114, 0.6609688738465388],
  [152, 115, 0.30200864860954885],
  [153, 115, 1.0319536619522978],
  [154, 116, 1.0275306741623285],
  [155, 116, 0.12159541018943322],
  [155, 117, 0.8415454609370665],
  [156, 117, 0.655981554500098],
  [156, 118, 0.3076319217011811],
  [157, 118, 1.031538493855763],
  [158, 119, 1.0269530354146845],
  [159, 119, 0.11732464738966399],
  [159, 120, 0.846455125764718],
  [160, 120, 0.6511485069565366],
  [160, 121, 0.3131139349019227],
  [161, 121, 1.0311043242739946],
  [162, 122, 1.0263736721146446],
  [163, 122, 0.11321814480714538],
  [163, 123, 0.851212693834753],
  [164, 123, 0.6464654186857061],
  [164, 124, 0.3184564415055735],
  [165, 124, 1.0306534394819706],
  [166, 125, 1.0257941675461106],
  [167, 125, 0.10926918209624069],
  [167, 126, 0.8558223877141483],
  [168, 126, 0.6419281552876014],
  [168, 127, 0.32366120686047056],
  [169, 127, 1.0301879983273805],
  [170, 128, 1.0252159529388847],
  [171, 128, 0.10547140289367021],
  [171, 129, 0.8602882567276612],
  [172, 129, 0.6375327508240597],
  [172, 130, 0.32873000508360367],
  [173, 130, 1.0297100383091813],
  [174, 131, 1.0246403211604227],
  [175, 131, 0.10181879172477112],
  [175, 132, 0.8646141862987496],
  [176, 132, 0.6332753987956673],
  [176, 133, 0.33366461604209907],
  [177, 133, 1.0292214813668379],
  [178, 134, 1.0240684391009978],
  [179, 134, 0.09830565257411007],
  [179, 135, 0.8688039066707689],
  [180, 135, 0.6291524437169539],
  [180, 136, 0.3384668225808326],
  [181, 136, 1.0287241393952773],
  [182, 137, 1.0235013588866442],
  [183, 137, 0.0949265889928822],
  [183, 138, 0.8728610010546515],
  [184, 138, 0.6251603732380943],
  [184, 139, 0.3431384079843332],
  [185, 139, 1.0282197194980238],
  [186, 140, 1.0229400280388043],
  [187, 140, 0.09167648561647405],
  [187, 141, 0.8767889132518744],
  [188, 141, 0.6212958107744541],
  [188, 142, 0.3476811536535296],
  [189, 142, 1.0277098289923983],
  [190, 143, 1.0223852986877378],
  [191, 143, 0.08855049098843445],
  [191, 144, 0.8805909547856343],
  [192, 144, 0.6175555086043407],
  [192, 145, 0.35209683698566024],
  [193, 145, 1.0271959801772084],
  [194, 146, 1.021837935933431],
  [195, 146, 0.08554400158179727],
  [195, 147, 0.8842703115872171],
  [196, 147, 0.6139363413989273],
  [196, 148, 0.35638722943949186],
  [197, 148, 1.026679594876984],
  [198, 149, 1.0212986254395027],
  [199, 149, 0.082652646931321],
  [199, 150, 0.8878300502607867],
  [200, 150, 0.6104353001536761],
  [200, 151, 0.3605540947783916],
  [201, 151, 1.0261620087703698],
  [202, 152, 1.020767980334856],
  [203, 152, 0.07987227578640096],
  [203, 153, 0.8912731239662092],
  [204, 153, 0.6070494864912312],
  [204, 154, 0.364599187472458],
  [205, 154, 1.025644475516362],
  [206, 155, 1.0202465474911722],
  [207, 155, 0.07719894321045902],
  [207, 156, 0.8946023779404728],
  [208, 156, 0.6037761073076129],
  [208, 157, 0.36852425125748506],
  [209, 157, 1.0251281706842847],
  [210, 158, 1.0197348132361097],
  [211, 158, 0.07462889855138014],
  [211, 159, 0.8978205546916732],
  [212, 159, 0.6006124697383151],
  [212, 160, 0.3723310178292769],
  [213, 160, 1.0246141955013988],
  [214, 161, 1.0192332085569418],
  [215, 161, 0.07215857422040488],
  [215, 162, 0.9009302988805],
  [216, 162, 0.5975559764226185],
  [216, 163, 0.37602120567284064],
  [217, 163, 1.024103580422386],
  [218, 164, 1.018742113842709],
  [219, 164, 0.06978457521665815],
  [219, 165, 0.9039341619174114],
  [220, 165, 0.5946041210439893],
  [220, 166, 0.3795965190111676],
  [221, 166, 1.0235972885322195],
  [222, 167, 1.0182618632088625],
  [223, 167, 0.0675036693443592],
  [223, 168, 0.9068346062921914],
  [224, 168, 0.5917544841265701],
  [224, 169, 0.3830586468674795],
  [225, 169, 1.0230962187892327],
  [226, 170, 1.0177927484431766],
  [227, 170, 0.06531277806896706],
  [227, 171, 0.9096340096561174],
  [228, 171, 0.5890047290713193],
  [228, 172, 0.38640926223293437],
  [229, 172, 1.0226012091159231],
  [230, 173, 1.017335022608167],
  [231, 173, 0.0632089679653424],
  [231, 174, 0.9123346686734497],
  [232, 174, 0.586352598418078],
  [232, 175, 0.3896500213288084],
  [233, 175, 1.0221130393455482],
  [234, 176, 1.0168889033326205],
  [235, 176, 0.06118944272087777],
  [235, 177, 0.914938802652698],
  [236, 177, 0.5837959103122896],
  [236, 178, 0.39278256296329067],
  [237, 178, 1.0216324340290364],
  [238, 179, 1.0164545758191],
  [239, 179, 0.05925153564332089],
  [239, 180, 0.9174485569826359],
  [240, 180, 0.5813325551691159],
  [240, 181, 0.3958085079669357],
  [241, 181, 1.0211600651125134],
  [242, 182, 1.01603219559476],
  [243, 182, 0.05739270264601734],
  [243, 183, 0.919866006375456],
  [244, 183, 0.578960492519135],
  [244, 184, 0.39872945870775167],
  [245, 184, 1.020696554488055],
  [246, 185, 1.0156218910279706],
  [247, 185, 0.055610515672866775],
  [247, 186, 0.9221931579354511],
  [248, 186, 0.5766777480237313],
  [248, 187, 0.4015469986761612],
  [249, 187, 1.0202424764259312],
  [250, 188, 1.0152237656316911],
  [251, 188, 0.05390265653168126],
  [251, 189, 0.9244319540637365],
  [252, 189, 0.5744824106486663],
  [252, 190, 0.4042626921377848],
  [253, 190, 1.0197983598926021],
  [254, 191, 1.0148379001729047],
  [255, 191, 0.052266911108559244],
  [255, 192, 0.9265842752073952],
  [256, 192, 0.5723726299899468],
  [256, 193, 0.40687808384383367],
  [257, 193, 1.0193646907609162],
  [258, 194, 1.0144643546050645],
  [259, 194, 0.05070116393653833],
  [259, 195, 0.9286519424651887],
  [260, 195, 0.5703466137364466],
  [260, 196, 0.4093946987997115],
  [261, 196, 1.0189419139168765],
  [262, 197, 1.014103169839173],
  [263, 197, 0.04920339309393266],
  [263, 198, 0.9306367200572258],
  [264, 198, 0.5684026252644323],
  [264, 199, 0.41181404208517797],
  [265, 199, 1.0185304352678317],
  [266, 200, 1.0137543693675302],
  [267, 200, 0.04777166540942449],
  [267, 201, 0.9325403176671191],
  [268, 201, 0.5665389813575877],
  [268, 202, 0.4141375987198434],
  [269, 202, 1.0181306236573189],
  [270, 203, 1.0134179607527265],
  [271, 203, 0.04640413195303674],
  [271, 204, 0.934364392667829],
  [272, 204, 0.5647540500383554],
  [272, 205, 0.4163668335733731],
  [273, 205, 1.017742812691386],
  [274, 206, 1.0130939369942324],
  [275, 206, 0.04509902379599986],
  [275, 207, 0.9361105522297561],
  [276, 207, 0.5630462485124229],
  [276, 208, 0.4185031913161667],
  [277, 208, 1.0173673024779883],
  [278, 209, 1.0127822777820206],
  [279, 209, 0.043854648017688035],
  [279, 210, 0.9377803553285139],
  [280, 210, 0.5614140412123577],
  [280, 211, 0.42054809640522234],
  [281, 211, 1.0170043612872055],
  [282, 212, 1.0124829506474082],
  [283, 212, 0.042669383945431606],
  [283, 213, 0.9393753146522579],
  [284, 213, 0.5598559379382144],
  [284, 214, 0.42250295310432634],
  [285, 214, 1.016654227133528],
  [286, 215, 1.0121959120202477],
  [287, 215, 0.04154167961383383],
  [287, 216, 0.9408968984130733],
  [288, 216, 0.5583704920894111],
  [288, 217, 0.42436914553372207],
  [289, 217, 1.0163171092845467],
  [290, 218, 1.0119211081990869],
  [291, 218, 0.04047004842376173],
  [291, 219, 0.9423465320743504],
  [292, 219, 0.5569562989809166],
  [292, 220, 0.4261480377490578],
  [293, 220, 1.0159931896995795],
  [294, 221, 1.0116584762427925],
  [295, 221, 0.03945306599345366],
  [295, 222, 0.9437255999933521],
  [296, 222, 0.5556119942410062],
  [296, 223, 0.4278409738424421],
  [297, 223, 1.0156826244024533],
  [298, 224, 1.0114079447897668],
  [299, 224, 0.038489367187566605],
  [299, 225, 0.9450354469842541],
  [300, 225, 0.5543362522836106],
  [300, 226, 0.42944927807097044],
  [301, 226, 1.015385544788648],
  [302, 227, 1.0111694348102989],
  [303, 227, 0.03757764331096192],
  [303, 228, 0.9462773798108762],
  [304, 228, 0.5531277848528364],
  [304, 229, 0.4309742550012965],
  [305, 229, 1.0151020588742643],
  [306, 230, 1.010942860298229],
  [307, 230, 0.036716639459590646],
  [307, 231, 0.9474526686068676],
  [308, 231, 0.5519853396352962],
  [308, 232, 0.4324171896758833],
  [309, 232, 1.0148322524854105],
  [310, 233, 1.0107281289063446],
  [311, 233, 0.03590515201636021],
  [311, 234, 0.9485625482321702],
  [312, 234, 0.5509076989367998],
  [312, 235, 0.43377934779319954],
  [313, 235, 1.0145761903940136],
  [314, 236, 1.0105251425307091],
  [315, 236, 0.03514202628559325],
  [315, 237, 0.9496082195647421],
  [316, 237, 0.5498936784177629],
  [316, 238, 0.4350619759070698],
  [317, 238, 1.014333917399279],
  [318, 239, 1.0103337978471305],
  [319, 239, 0.03442615425358563],
  [319, 240, 0.9505908507379167],
  [320, 240, 0.5489421258861396],
  [320, 241, 0.43626630163460317],
  [321, 241, 1.0141054593619083],
  [322, 242, 1.01015398680447],
  [323, 242, 0.03375647247069698],
  [323, 243, 0.9515115783174108],
  [324, 243, 0.5480519201477565],
  [324, 244, 0.43739353387882146],
  [325, 244, 1.0138908241879996],
  [326, 245, 1.0099855970782285],
  [327, 245, 0.033131960048180864],
  [327, 246, 0.9523715084281075],
  [328, 246, 0.5472219699015581],
  [328, 247, 0.438444863061944],
  [329, 247, 1.013690002769195],
  [330, 248, 1.009828512486449],
  [331, 248, 0.0325516367573507],
  [331, 249, 0.9531717178331495],
  [332, 249, 0.5464512126887197],
  [332, 250, 0.43942146136466664],
  [333, 250, 1.0135029698801676],
  [334, 251, 1.0096826133725936],
  [335, 251, 0.03201456123217285],
  [335, 252, 0.9539132549610332],
  [336, 252, 0.5457386138858732],
  [336, 253, 0.4403244829779182],
  [337, 253, 1.0133296850325435],
  [338, 254, 1.009547776957031],
  [339, 254, 0.03151982926510845],
  [339, 255, 0.9545971408911784],
  [340, 255, 0.5450831657405287],
  [340, 256, 0.44115506435778573],
  [341, 256, 1.0131700932920482],
  [342, 257, 1.0094238776594737],
  [343, 257, 0.031066572189892106],
  [343, 258, 0.9552243702967873],
  [344, 258, 0.5444838864501296],
  [344, 259, 0.44191432448690826],
  [345, 259, 1.013024126057376],
  [346, 260, 1.0093107873949636],
  [347, 260, 0.030653955347715485],
  [347, 261, 0.9557959123477745],
  [348, 261, 0.5439398192781751],
  [348, 262, 0.44260336514265247],
  [349, 262, 1.01289170180302],
  [350, 263, 1.0092083758457435],
  [351, 263, 0.03028117663272106],
  [351, 264, 0.956312711573757],
  [352, 264, 0.5434500317097861],
  [352, 265, 0.44322327116676213],
  [353, 265, 1.012772726788603],
  [354, 266, 1.0091165107105933],
  [355, 266, 0.029947465111254432],
  [355, 267, 0.9567756886915669],
  [356, 267, 0.5430136146404813],
  [356, 268, 0.443775110739594],
  [357, 268, 1.0126670957357586],
  [358, 269, 1.0090350579329337],
  [359, 269, 0.02965207970869547],
  [359, 270, 0.9571857414000476],
  [360, 270, 0.5426296815994802],
  [360, 271, 0.44425993565630856],
  [361, 271, 1.012574692474406],
  [362, 272, 1.0089638819102829],
  [363, 272, 0.029394307963707546],
  [363, 273, 0.9575437451393404],
  [364, 273, 0.5422973680058967],
  [364, 274, 0.4446787816043237],
  [365, 274, 1.0124953905592755],
  [366, 275, 1.0089028456858484],
  [367, 275, 0.029173464843693937],
  [367, 276, 0.9578505538209541],
  [368, 276, 0.5420158304528419],
  [368, 277, 0.44503266844280676],
  [369, 277, 1.0124290538587923],
  [370, 278, 1.0088518111235036],
  [371, 278, 0.028988891617224174],
  [371, 279, 0.9581070005279474],
  [372, 279, 0.5417842460227992],
  [372, 280, 0.4453226004830567],
  [373, 280, 1.012375537116488],
  [374, 281, 1.0088106390682976],
  [375, 281, 0.028839954783933083],
  [375, 282, 0.9583138981860433],
  [376, 282, 0.5416018116287169],
  [376, 283, 0.4455495667668758],
  [377, 283, 1.0123346864882432],
  [378, 284, 1.008779189492711],
  [379, 284, 0.02872604505481853],
  [379, 285, 0.9584720402070429],
  [380, 285, 0.5414677433849261],
  [380, 286, 0.44571454134485444],
  [381, 286, 1.0123063400541175],
  [382, 287, 1.008757321629678],
  [383, 287, 0.028646576380597488],
  [383, 288, 0.9585822011116006],
  [384, 288, 0.5413812759956369],
  [384, 289, 0.4458184835568685],
  [385, 289, 1.0122903283078832],
  [386, 290, 1.0087448940943453],
  [387, 290, 0.028600985028178233],
  [387, 291, 0.9586451371206854],
  [388, 291, 0.541341662177547],
  [388, 292, 0.44586233830592226],
  [389, 292, 1.0122864746237836],
  [390, 293, 1.0087417649949195],
  [391, 293, 0.028588728701898054],
  [391, 294, 0.9586615867284015],
  [392, 294, 0.5413481720936798],
  [392, 295, 0.44584703633543826],
  [393, 295, 1.0122945957030358],
  [394, 296, 1.0087477920325896],
  [395, 296, 0.028609285702619672],
  [395, 297, 0.958632271251788],
  [396, 297, 0.5414000928186515],
  [396, 298, 0.44577349450072723],
  [397, 298, 1.0123145019997328],
  [398, 299, 1.0087628325926643],
  [399, 299, 0.028662154128659946],
  [399, 300, 0.9585578953591529],
  [400, 300, 0.5414967278190544],
  [400, 301, 0.4456426160405528],
  [401, 301, 1.0123459981276965],
  [402, 302, 1.0087867438270437],
  [403, 302, 0.028746851113718195],
  [403, 303, 0.9584391475775814],
  [404, 303, 0.5416373964555454],
  [404, 304, 0.4454552908447334],
  [405, 304, 1.0123888832492127],
  [406, 305, 1.0088193827286074],
  [407, 305, 0.02886291209986826],
  [407, 306, 0.9582767007831089],
  [408, 306, 0.541821433501071],
  [408, 307, 0.44521239571891796],
  [409, 307, 1.0124429514472502],
  [410, 308, 1.0088606061980132],
  [411, 308, 0.029009890142771087],
  [411, 309, 0.9580712126699451],
  [412, 309, 0.5420481886827784],
  [412, 310, 0.4449147946460895],
  [413, 310, 1.01250799207953],
  [414, 311, 1.0089102711038211],
  [415, 311, 0.029187355249536997],
  [415, 312, 0.9578233262044412],
  [416, 312, 0.5423170262339921],
  [416, 313, 0.44456333904778883],
  [417, 313, 1.0125837901172945],
  [418, 314, 1.0089682343360202],
  [419, 314, 0.02939489374516595],
  [419, 315, 0.9575336700623188],
  [420, 315, 0.5426273244683578],
  [420, 316, 0.4441588680360723],
  [421, 316, 1.0126701264704934],
  [422, 317, 1.0090343528545804],
  [423, 317, 0.029632107670909735],
  [423, 318, 0.9572028590461733],
  [424, 318, 0.5429784753662162],
  [424, 319, 0.44370220866623333],
  [425, 319, 1.0127667782967882],
  [426, 320, 1.0091084837312583],
  [427, 320, 0.02989861420426184],
  [427, 321, 0.9568314944924141],
  [428, 321, 0.5433698841780775],
  [428, 322, 0.44319417618582607],
  [429, 322, 1.0128735192969558],
  [430, 323, 1.0091904841873789],
  [431, 323, 0.03019404510848359],
  [431, 324, 0.9564201646615609],
  [432, 324, 0.5438009690392793],
  [432, 325, 0.442635574278337],
  [433, 325, 1.0129901199984148],
  [434, 326, 1.0092802116265451],
  [435, 326, 0.030518046204357472],
  [435, 327, 0.9559694451142186],
  [436, 327, 0.5442711606026257],
  [436, 328, 0.4420271953022404],
  [437, 328, 1.013116348025554],
  [438, 329, 1.0093775236632159],
  [439, 329, 0.030870276865616747],
  [439, 330, 0.9554798990737882],
  [440, 330, 0.5447799016825403],
  [440, 331, 0.4413698205263152],
  [441, 331, 1.0132519683584005],
  [442, 332, 1.009482278147551],
  [443, 332, 0.03125040953717358],
  [443, 333, 0.9549520777754482],
  [444, 333, 0.5453266469100869],
  [444, 334, 0.4406642203630321],
  [445, 334, 1.0133967435791398],
  [446, 335, 1.009594333186143],
  [447, 335, 0.031658129272365214],
  [447, 336, 0.9543865208053518],
  [448, 336, 0.5459108623998897],
  [448, 337, 0.43991115459682073],
  [449, 337, 1.0135504341086077],
  [450, 338, 1.0097135471594447],
  [451, 338, 0.03209313328990995],
  [451, 339, 0.9537837564264052],
  [452, 339, 0.5465320254328632],
  [452, 340, 0.4391113726049666],
  [453, 340, 1.013712798432744],
  [454, 341, 1.009839778736762],
  [455, 341, 0.03255513055252836],
  [455, 342, 0.9531443018899375],
  [456, 342, 0.5471896241467579],
  [456, 343, 0.43826561357805704],
  [457, 343, 1.0138835933177033],
  [458, 344, 1.0099728868869051],
  [459, 344, 0.033043841357819334],
  [459, 345, 0.9524686637453139],
  [460, 345, 0.5478831572348231],
  [460, 346, 0.437374606734874],
  [461, 346, 1.0140625740178375],
  [462, 347, 1.0101127308880269],
  [463, 347, 0.03355899695286791],
  [463, 348, 0.9517573381261256],
  [464, 348, 0.5486121336621822],
  [464, 349, 0.436439071532636],
  [465, 349, 1.0142494944714182],
  [466, 350, 1.0102591703335964],
  [467, 350, 0.03410033916008615],
  [467, 351, 0.9510108110386514],
  [468, 351, 0.5493760723833191],
  [468, 352, 0.4354597178717026],
  [469, 352, 1.0144441074918717],
  [470, 353, 1.0104120651366326],
  [471, 353, 0.03466762001996195],
  [471, 354, 0.9502295586328896],
  [472, 354, 0.5501745020753853],
  [472, 355, 0.43443724629963687],
  [473, 355, 1.0146461649465606],
  [474, 356, 1.0105712755316636],
  [475, 356, 0.035260601448092795],
  [475, 357, 0.9494140474694148],
  [476, 357, 0.5510069608761691],
  [476, 358, 0.43337234820709825],
  [477, 358, 1.0148554179311553],
  [478, 359, 1.0107366620751033],
  [479, 359, 0.035879054907258415],
  [479, 360, 0.9485647347731454],
  [480, 360, 0.5518729961339426],
  [480, 361, 0.4322657060211073],
  [481, 361, 1.0150716169344107],
  [482, 362, 1.0109080856433987],
  [483, 362, 0.036522761091017805],
  [483, 363, 0.9476820686815849],
  [484, 363, 0.5527721641646695],
  [484, 364, 0.4311179933933358],
  [485, 364, 1.0152945119966836],
  [486, 365, 1.011085407429963],
  [487, 365, 0.037191509621709105],
  [487, 366, 0.9467664884832998],
  [488, 366, 0.5537040300164661],
  [488, 367, 0.42992987538427074],
  [489, 367, 1.0155238528614574],
  [490, 368, 1.0112684889404733],
  [491, 368, 0.03788509876006132],
  [491, 369, 0.945818424848663],
  [492, 369, 0.5546681672409077],
  [492, 370, 0.42870200864543534],
  [493, 370, 1.015759389119438],
  [494, 371, 1.0114571919861517],
  [495, 371, 0.038603335123549486],
  [495, 372, 0.9448383000574974],
  [496, 372, 0.5556641576735553],
  [496, 373, 0.42743504159139284],
  [497, 373, 1.016000870349307],
  [498, 374, 1.0116513786769457],
  [499, 374, 0.03934603342038135],
  [499, 375, 0.9438265282100843],
  [500, 375, 0.556691591222498],
  [500, 376, 0.42612961457530607],
  [501, 376, 1.0162480462474877],
  [502, 377, 1.011850911412824],
  [503, 377, 0.0401130161915153],
  [503, 378, 0.9427835154401112],
  [504, 378, 0.5577500656591832],
  [504, 379, 0.42478636005357434],
  [505, 379, 1.0165006667574357],
  [506, 380, 1.012055652873517],
  [507, 380, 0.04090411356002747],
  [507, 381, 0.9417096601187289],
  [508, 381, 0.5588391864205529],
  [508, 382, 0.4234059027505881],
  [509, 382, 1.016758482190165],
  [510, 383, 1.0122654660085202],
  [511, 383, 0.04171916299559172],
  [511, 384, 0.940605353048487],
  [512, 384, 0.5599585664146272],
  [512, 385, 0.4219888598177451],
  [513, 385, 1.0170212433404524],
  [514, 386, 1.0124802140252198],
  [515, 386, 0.04255800908365318],
  [515, 387, 0.9394709776545362],
  [516, 387, 0.5611078258344457],
  [516, 388, 0.42053584098827806],
  [517, 388, 1.0172887015980372],
  [518, 389, 1.0126997603766286],
  [519, 389, 0.04342050330548295],
  [519, 390, 0.9383069101697904],
  [520, 390, 0.5622865919744513],
  [520, 391, 0.4190474487280153],
  [521, 391, 1.0175606090547666],
  [522, 392, 1.0129239687479124],
  [523, 392, 0.044306503823998804],
  [523, 393, 0.9371135198133816],
  [524, 393, 0.5634944990567509],
  [524, 394, 0.41752427838399275],
  [525, 394, 1.017836718605313],
  [526, 395, 1.0131527030429122],
  [527, 395, 0.04521587528078427],
  [527, 396, 0.9358911689630978],
  [528, 396, 0.5647311880602439],
  [528, 397, 0.4159669183258934],
  [529, 397, 1.0181167840454461],
  [530, 398, 1.013385827369556],
  [531, 398, 0.04614848859869256],
  [531, 399, 0.9346402133241121],
  [532, 399, 0.5659963065530312],
  [532, 400, 0.41437595008823225],
  [533, 400, 1.0184005601646522],
  [534, 401, 1.0136232060250132],
  [535, 401, 0.04710422079259773],
  [535, 402, 0.9333610020906034],
  [536, 402, 0.5672895085344858],
  [536, 403, 0.41275194850334485],
  [537, 403, 1.0186878028359048],
  [538, 404, 1.0138647034793364],
  [539, 404, 0.048082954782625906],
  [539, 405, 0.9320538781067357],
  [540, 405, 0.5686104542795039],
  [540, 406, 0.4110954818363832],
  [541, 406, 1.0189782691001303],
  [542, 407, 1.0141101843606544],
  [543, 407, 0.04908457922335384],
  [543, 408, 0.9307191780153855],
  [544, 408, 0.5699588101870642],
  [544, 409, 0.40940711191046436],
  [545, 409, 1.0192717172488233],
  [546, 410, 1.0143595134378742],
  [547, 410, 0.05010898832967291],
  [547, 411, 0.9293572324099554],
  [548, 411, 0.571334248633412],
  [548, 412, 0.4076873942350095],
  [549, 412, 1.0195679069010588],
  [550, 413, 1.014612555604275],
  [551, 413, 0.05115608171422347],
  [551, 414, 0.9279683659767549],
  [552, 414, 0.5727364478324755],
  [552, 415, 0.4059368781231612],
  [553, 415, 1.0198665990790994],
  [554, 416, 1.0148691758602966],
  [555, 416, 0.05222576422885553],
  [555, 417, 0.9265528976348417],
  [556, 417, 0.5741650916958022],
  [556, 418, 0.40415610681371494],
  [557, 418, 1.0201675562784311],
  [558, 419, 1.0151292392959954],
  [559, 419, 0.05331794581129548],
  [559, 420, 0.9251111406735011],
  [560, 420, 0.575619869698764],
  [560, 421, 0.40234561758289383],
  [561, 421, 1.020470542537326],
  [562, 422, 1.0153926110734461],
  [563, 422, 0.05443254133751677],
  [563, 423, 0.9236434028815992],
  [564, 423, 0.577100476753225],
  [564, 424, 0.40050594185671334],
  [565, 424, 1.0207753235006762],
  [566, 425, 1.0156591564087798],
  [567, 425, 0.05556947047932675],
  [567, 426, 0.9221499866777003],
  [568, 426, 0.5786066130792553],
  [568, 427, 0.3986376053171075],
  [569, 427, 1.021081666483685],
  [570, 428, 1.0159287405542117],
  [571, 428, 0.056728657567230105],
  [571, 429, 0.9206311892316345],
  [572, 429, 0.5801379840824749],
  [572, 430, 0.3967411280111777],
  [573, 430, 1.0213893405291132],
  [574, 431, 1.016201228779567],
  [575, 431, 0.057910031456259455],
  [575, 432, 0.9190873025878152],
  [576, 432, 0.5816943002369833],
  [576, 433, 0.39481702444623007],
  [577, 433, 1.021698116466727],
  [578, 434, 1.0164764863538518],
  [579, 434, 0.05911352539724152],
  [579, 435, 0.9175186137811212],
  [580, 435, 0.5832752769689779],
  [580, 436, 0.3928658036922941],
  [581, 436, 1.0220077669657777],
  [582, 437, 1.0167543785266802],
  [583, 437, 0.06033907691219022],
  [583, 438, 0.9159254049505173],
  [584, 438, 0.5848806345442068],
  [584, 439, 0.3908879694785636],
  [585, 439, 1.022318066586335],
  [586, 440, 1.017034770509633],
  [587, 440, 0.061586627674206584],
  [587, 441, 0.914307953451257],
  [588, 441, 0.58651009795775],
  [588, 442, 0.3888840202832941],
  [589, 442, 1.0226287918300547],
  [590, 443, 1.017317527457434],
  [591, 443, 0.06285612338957339],
  [591, 444, 0.9126665319603182],
  [592, 444, 0.5881633968320044],
  [592, 445, 0.3868544494242516],
  [593, 445, 1.0229397211858324],
  [594, 446, 1.0176025144493452],
  [595, 446, 0.06414751368695158],
  [595, 447, 0.9110014085827639],
  [596, 447, 0.5898402653081352],
  [596, 448, 0.3847997451452973],
  [597, 448, 1.0232506351759092],
  [598, 449, 1.0178895964699735],
  [599, 449, 0.06546075200505637],
  [599, 450, 0.9093128469516464],
  [600, 450, 0.5915404419502857],
  [600, 451, 0.38272039070347513],
  [601, 451, 1.0235613163962847],
  [602, 452, 1.018178638390636],
  [603, 452, 0.06679579548876291],
  [603, 453, 0.9076011063291527],
  [604, 453, 0.5932636696450677],
  [604, 454, 0.3806168644453139],
  [605, 454, 1.0238715495601471],
  [606, 455, 1.0184695049504477],
  [607, 455, 0.06815260488510425],
  [607, 456, 0.9058664416991429],
  [608, 456, 0.5950096955107654],
  [608, 457, 0.37848963988927037],
  [609, 457, 1.024181121533852],
  [610, 458, 1.0187620607370533],
  [611, 458, 0.06953114444294146],
  [611, 459, 0.9041091038666588],
  [612, 459, 0.5967782707982764],
  [612, 460, 0.3763391858013562],
  [613, 460, 1.0244898213757605],
  [614, 461, 1.0190561701684775],
  [615, 461, 0.07093138181829654],
  [615, 462, 0.9023293395404434],
  [616, 462, 0.5985691508103589],
  [616, 463, 0.37416596626748977],
  [617, 463, 1.0247974403689852],
  [618, 464, 1.0193516974735164],
  [619, 464, 0.07235328797779521],
  [619, 465, 0.9005273914292568],
  [620, 465, 0.6003820948062436],
  [620, 466, 0.37197044076689306],
  [621, 466, 1.0251037720559506],
  [622, 467, 1.0196485066733956],
  [623, 467, 0.07379683710904351],
  [623, 468, 0.8987034983230944],
  [624, 468, 0.6022168659211814],
  [624, 469, 0.3697530642404009],
  [625, 469, 1.025408612268551],
  [626, 470, 1.01994646156273],
  [627, 470, 0.07526200653052777],
  [627, 471, 0.8968578951803935],
  [628, 471, 0.6040732310832857],
  [628, 472, 0.36751428715382667],
  [629, 472, 1.0257117591594511],
  [630, 473, 1.0202454256910738],
  [631, 473, 0.07674877660715493],
  [631, 474, 0.8949908132065928],
  [632, 474, 0.6059509609308075],
  [632, 475, 0.3652545555682938],
  [633, 475, 1.0260130132278693],
  [634, 476, 1.0205452623441595],
  [635, 476, 0.07825713066499564],
  [635, 477, 0.8931024799348216],
  [636, 477, 0.6078498297369068],
  [636, 478, 0.36297431119783957],
  [637, 478, 1.026312177347325],
  [638, 479, 1.0208458345252258],
  [639, 479, 0.07978705490923481],
  [639, 480, 0.8911931193041005],
  [640, 480, 0.6097696153313106],
  [640, 481, 0.360673991471839],
  [641, 481, 1.0266090567901067],
  [642, 482, 1.021147004936792],
  [643, 482, 0.08133853834681559],
  [643, 483, 0.8892629517341233],
  [644, 483, 0.6117100990244927],
  [644, 484, 0.3583540295921792],
  [645, 484, 1.0269034592511874],
  [646, 485, 1.0214486359623245],
  [647, 485, 0.08291157270803175],
  [647, 486, 0.8873121941972261],
  [648, 486, 0.6136710655396947],
  [648, 487, 0.35601485458732646],
  [649, 487, 1.0271951948700204],
  [650, 488, 1.0217505896477503],
  [651, 488, 0.08450615237016054],
  [651, 489, 0.885341060291742],
  [652, 489, 0.6156523029400911],
  [652, 490, 0.3536568913681695],
  [653, 490, 1.0274840762511013],
  [654, 491, 1.022052727683594],
  [655, 491, 0.08612227428601159],
  [655, 492, 0.8833497603088218],
  [656, 492, 0.6176536025590085],
  [656, 493, 0.3512805607832744],
  [657, 493, 1.02776991848203],
  [658, 494, 1.0223549113867765],
  [659, 494, 0.08775993791161714],
  [659, 495, 0.8813385013049766],
  [660, 495, 0.6196747589336273],
  [660, 496, 0.34888627966024516],
  [661, 496, 1.028052539155018],
  [662, 497, 1.0226570016825074],
  [663, 497, 0.08941914513388247],
  [663, 498, 0.8793074871648813],
  [664, 498, 0.621715569739104],
  [664, 499, 0.346474460866357],
  [665, 499, 1.0283317583791294],
  [666, 500, 1.0229588590871557],
  [667, 500, 0.09109990020637701],
  [667, 501, 0.8772569186645972],
  [668, 501, 0.6237758357289777],
  [668, 502, 0.34404551334349676],
  [669, 502, 1.0286073987990987],
  [670, 503, 1.023260343690056],
  [671, 503, 0.09280220968027517],
  [671, 504, 0.8751869935378795],
  [672, 504, 0.6258553606671395],
  [672, 505, 0.3415998421603758],
  [673, 505, 1.0288792856085094],
  [674, 506, 1.0235613151361742],
  [675, 506, 0.09452608233896752],
  [675, 507, 0.8730979065358732],
  [676, 507, 0.6279539512706841],
  [676, 508, 0.33913784855416224],
  [677, 508, 1.0291472465628844],
  [678, 509, 1.0238616326091752],
  [679, 509, 0.09627152913686766],
  [679, 510, 0.8709898494841083],
  [680, 510, 0.6300714171530707],
  [680, 511, 0.3366599299694516],
  [681, 511, 1.0294111119920568],
  [682, 512, 1.0241611548135297],
  [683, 512, 0.09803856313307117],
  [683, 513, 0.8688630113461538],
  [684, 513, 0.6322075707612916],
  [684, 514, 0.3341664801038121],
  [685, 514, 1.0296707148107829],
  [686, 515, 1.0244597399582411],
  [687, 515, 0.09982719943517422],
  [687, 516, 0.8667175782751595],
  [688, 516, 0.6343622273238361],
  [688, 517, 0.33165788894132453],
  [689, 517, 1.029925890529174],
  [690, 518, 1.024757245739534],
  [691, 518, 0.10163745513498708],
  [691, 519, 0.864553733672022],
  [692, 519, 0.6365352047963319],
  [692, 520, 0.32913454279236454],
  [693, 520, 1.0301764772610114],
  [694, 521, 1.0250535293244536],
  [695, 521, 0.10346934925456013],
  [695, 522, 0.8623716582378126],
  [696, 522, 0.6387263238040831],
  [696, 523, 0.32659682433041565],
  [697, 523, 1.0304223157317631],
  [698, 524, 1.0253484473338592],
  [699, 524, 0.10532290268142636],
  [699, 525, 0.8601715300305955],
  [700, 525, 0.6409354075949926],
  [700, 526, 0.32404511262442137],
  [701, 526, 1.0306632492858765],
  [702, 527, 1.0256418558269649],
  [703, 527, 0.10719813812199533],
  [703, 528, 0.8579535245094766],
  [704, 528, 0.6431622819855923],
  [704, 529, 0.3214797831731655],
  [705, 529, 1.0308991238920382],
  [706, 530, 1.0259336102845216],
  [707, 530, 0.10909508003982304],
  [707, 531, 0.855717814591042],
  [708, 531, 0.6454067753119441],
  [708, 532, 0.3189012079363341],
  [709, 532, 1.03112978814904],
  [710, 533, 1.0262235655929648],
  [711, 533, 0.11101375459950885],
  [711, 534, 0.8534645706974212],
  [712, 534, 0.6476687183847731],
  [712, 535, 0.31630975536452444],
  [713, 535, 1.0313550932895121],
  [714, 536, 1.0265115760290215],
  [715, 536, 0.11295418962138112],
  [715, 537, 0.8511939607995829],
  [716, 537, 0.6499479444348513],
  [716, 538, 0.3137057904341974],
  [717, 538, 1.0315748931821125],
  [718, 539, 1.0267974952437684],
  [719, 539, 0.11491641452111552],
  [719, 540, 0.8489061504692988],
  [720, 540, 0.6522442890739327],
  [720, 541, 0.3110896746693046],
  [721, 541, 1.0317890443354898],
  [722, 542, 1.027081176247435],
  [723, 542, 0.11690046026072583],
  [723, 543, 0.8466013029223681],
  [724, 543, 0.6545575902471419],
  [724, 544, 0.3084617661720711],
  [725, 544, 1.0319974058989068],
  [726, 545, 1.0273624713942857],
  [727, 545, 0.11890635929917114],
  [727, 546, 0.8442795790631381],
  [728, 546, 0.6568876881880987],
  [728, 547, 0.3058224196480645],
  [729, 547, 1.0321998396634169],
  [730, 548, 1.0276412323675237],
  [731, 548, 0.12093414553884717],
  [731, 549, 0.8419411375296247],
  [732, 549, 0.6592344253774453],
  [732, 550, 0.3031719864317822],
  [733, 550, 1.0323962100616533],
  [734, 551, 1.027917310164898],
  [735, 551, 0.12298385427920393],
  [735, 552, 0.8395861347312832],
  [736, 552, 0.661597646501151],
  [736, 553, 0.30051081451364153],
  [737, 553, 1.0325863841657408],
  [738, 554, 1.028190555083932],
  [739, 554, 0.12505552216817234],
  [739, 555, 0.8372147248951822],
  [740, 555, 0.6639771984076539],
  [740, 556, 0.2978392485576317],
  [741, 556, 1.0327702316879357],
  [742, 557, 1.0284608167076257],
  [743, 557, 0.12714918714905468],
  [743, 558, 0.8348270601054527],
  [744, 558, 0.6663729300704698],
  [744, 559, 0.2951576299293991],
  [745, 559, 1.0329476249762861],
  [746, 560, 1.0287279438905246],
  [747, 560, 0.12926488841857217],
  [747, 561, 0.8324232903405301],
  [748, 561, 0.6687846925454237],
  [748, 562, 0.2924662967182933],
  [749, 562, 1.0331184390116956],
  [750, 563, 1.0289917847447467],
  [751, 563, 0.13140266637549056],
  [751, 564, 0.8300035635173267],
  [752, 564, 0.6712123389365675],
  [752, 565, 0.28976558374944045],
  [753, 565, 1.033282551406384],
  [754, 566, 1.0292521866268258],
  [755, 566, 0.13356256257828694],
  [755, 567, 0.8275680255195722],
  [756, 567, 0.6736557243576808],
  [756, 568, 0.28705582261488644],
  [757, 568, 1.0334398423957492],
  [758, 569, 1.0295089961237516],
  [759, 569, 0.1357446196959754],
  [759, 570, 0.8251168202441111],
  [760, 570, 0.6761147058925864],
  [760, 571, 0.2843373416864493],
  [761, 571, 1.0335901948361186],
  [762, 572, 1.0297620590403478],
  [763, 572, 0.13794888146102224],
  [763, 573, 0.822650089632257],
  [764, 573, 0.6785891425651428],
  [764, 574, 0.2816104661359854],
  [765, 574, 1.0337334941973482],
  [766, 575, 1.0300112203862977],
  [767, 575, 0.1401753926301894],
  [767, 576, 0.8201679737037143],
  [768, 576, 0.6810788952992894],
  [768, 577, 0.278875517953921],
  [769, 577, 1.0338696285566522],
  [770, 578, 1.0302563243634062],
  [771, 578, 0.14242419893016717],
  [771, 579, 0.8176706105975015],
  [772, 579, 0.6835838268889712],
  [772, 580, 0.2761328159639002],
  [773, 580, 1.0339984885922306],
  [774, 581, 1.0304972143534852],
  [775, 581, 0.14469534702456693],
  [775, 582, 0.8151581365963325],
  [776, 582, 0.6861038019600981],
  [776, 583, 0.2733826758448351],
  [777, 583, 1.0341199675739228],
  [778, 584, 1.0307337329063364],
  [779, 584, 0.14698888445850505],
  [779, 585, 0.8126306861670012],
  [780, 585, 0.6886386869453004],
  [780, 586, 0.2706254101402667],
  [781, 586, 1.0342339613562985],
  [782, 587, 1.0309657217274584],
  [783, 587, 0.14930485962229872],
  [783, 588, 0.810088391991206],
  [784, 588, 0.6911883500416512],
  [784, 589, 0.267861328280309],
  [785, 589, 1.0343403683692496],
  [786, 590, 1.0311930216672842],
  [787, 590, 0.1516433217043255],
  [787, 591, 0.80753138499415],
  [788, 591, 0.6937526611907388],
  [788, 592, 0.2650907365900638],
  [789, 592, 1.0344390896084676],
  [790, 593, 1.0314154727094134],
  [791, 593, 0.1540043206504027],
  [791, 594, 0.8049597943767033],
  [792, 594, 0.6963314920402311],
  [792, 595, 0.2623139383094437],
  [793, 595, 1.034530028625162],
  [794, 596, 1.0316329139598897],
  [795, 596, 0.1563879071152346],
  [795, 597, 0.8023737476471726],
  [796, 597, 0.6989247159176777],
  [796, 598, 0.25953123360660696],
  [797, 598, 1.0346130915153564],
  [798, 599, 1.0318451836365417],
  [799, 599, 0.15879413242528773],
  [799, 600, 0.799773370648628],
  [800, 600, 0.7015322078013413],
  [800, 601, 0.256742919587031],
  [801, 601, 1.0346881869094755],
  [802, 602, 1.0320521190584917],
  [803, 602, 0.16122304853347555],
  [803, 603, 0.7971587875884961],
  [804, 603, 0.7041538442893039],
  [804, 604, 0.2539492903120581],
  [805, 604, 1.0347552259598483],
  [806, 605, 1.032253556636297],
  [807, 605, 0.16367470797552194],
  [807, 606, 0.7945301210672343],
  [808, 606, 0.7067895035746306],
  [808, 607, 0.2511506368077842],
  [809, 607, 1.0348141223290412],
  [810, 608, 1.0324493318619021],
  [811, 608, 0.16614916382632547],
  [811, 609, 0.7918874921076472],
  [812, 609, 0.709439065413448],
  [812, 610, 0.24834724708249672],
  [813, 610, 1.0348647921767888],
  [814, 611, 1.032639279299876],
  [815, 611, 0.1686464696616927],
  [815, 612, 0.7892310201754584],
  [816, 612, 0.7121024111062217],
  [816, 613, 0.24553940613187852],
  [817, 613, 1.0349071541468273],
  [818, 614, 1.0328232325774014],
  [819, 614, 0.17116667951302045],
  [819, 615, 0.7865608232133336],
  [820, 615, 0.7147794234616441],
  [820, 616, 0.24272739595679857],
  [821, 616, 1.0349411293537],
  [822, 617, 1.0330010243763053],
  [823, 617, 0.17370984782335191],
  [823, 618, 0.7838770176637189],
  [824, 618, 0.7174699867799718],
  [824, 619, 0.23991149556876706],
  [825, 619, 1.0349666413686411],
  [826, 620, 1.033172486424039],
  [827, 620, 0.17627602940857415],
  [827, 621, 0.7811797184924586],
  [828, 621, 0.720173986819918],
  [828, 622, 0.23709198101021747],
  [829, 622, 1.0349836162040225],
  [830, 623, 1.0333374494861536],
  [831, 623, 0.1788652794118951],
  [831, 624, 0.7784690392157592],
  [832, 624, 0.7228913107823544],
  [832, 625, 0.234269125354749],
  [833, 625, 1.0349919822996723],
  [834, 626, 1.0334957433581187],
  [835, 626, 0.18147765326305537],
  [835, 627, 0.7757450919251534],
  [836, 627, 0.7256218472813651],
  [836, 628, 0.23144319872166874],
  [837, 628, 1.0349916705072433],
  [838, 629, 1.033647196858036],
  [839, 629, 0.1841132066386375],
  [839, 630, 0.773007987305413],
  [840, 630, 0.7283654863202004],
  [840, 631, 0.22861446829229304],
  [841, 631, 1.0349826140730403],
  [842, 632, 1.033791637819688],
  [843, 632, 0.1867719954109858],
  [843, 633, 0.7702578346682248],
  [844, 633, 0.7311221192693971],
  [844, 634, 0.2257831983137577],
  [845, 634, 1.0349647486235953],
  [846, 635, 1.0339288930859631],
  [847, 635, 0.18945407561392777],
  [847, 636, 0.7674947419659374],
  [848, 636, 0.7338916388459672],
  [848, 637, 0.22294965011006523],
  [849, 637, 1.0349380121480094],
  [850, 638, 1.0342420464149167],
  [851, 638, 0.1924281237940313],
  [851, 639, 0.5378425839134362],
  [852, 639, 0.5202524171708031],
  [852, 640, 0.4568109772775498],
  [852, 641, 0.05199677850209752],
  [853, 640, 0.24351254102567055],
  [853, 641, 0.5225687624093359],
  [853, 642, 0.2921493228893563],
  [854, 642, 0.25538328243481595],
  [854, 643, 0.5241438210153896],
  [854, 644, 0.23257172527298814],
  [855, 643, 0.011987787701546808],
  [855, 644, 0.3172219958151092],
  [855, 645, 0.4868674616302827],
  [855, 646, 0.176468024136203],
  [856, 645, 0.07357769424953754],
  [856, 646, 0.38294232266815553],
  [856, 647, 0.4259205416014665],
  [856, 648, 0.11753224171517974],
  [857, 647, 0.13246196705929972],
  [857, 648, 0.4398303708699065],
  [857, 649, 0.36708371923835004],
  [857, 650, 0.06067586883292038],
  [858, 649, 0.18926719214302565],
  [858, 650, 0.4946697651421086],
  [858, 651, 0.3040061179704405],
  [858, 652, 0.005602736230038195],
  [859, 651, 0.23906249586178907],
  [859, 652, 0.5231149368578739],
  [859, 653, 0.2495840468006932],
  [860, 653, 0.2897970473112013],
  [860, 654, 0.5026442283960142],
  [860, 655, 0.20274559579570214],
  [861, 654, 0.04664315619110009],
  [861, 655, 0.3473240465998149],
  [861, 656, 0.4526192727121032],
  [861, 657, 0.1523595035438806],
  [862, 656, 0.09766699822939251],
  [862, 657, 0.3969699779916487],
  [862, 658, 0.40188113292822186],
  [862, 659, 0.1034820659161816],
  [863, 658, 0.14649823031506354],
  [863, 659, 0.44395391725661004],
  [863, 660, 0.3530826952522148],
  [863, 661, 0.056517279244449437],
  [864, 660, 0.193417537810633],
  [864, 661, 0.48905272813711814],
  [864, 662, 0.30196784607077015],
  [864, 663, 0.011088189502860925],
  [865, 662, 0.235165441654809],
  [865, 663, 0.5161755064939912],
  [865, 664, 0.25593745749264785],
  [866, 664, 0.27598857145168865],
  [866, 665, 0.5055165820237347],
  [866, 666, 0.21733399798014585],
  [867, 665, 0.03142691535889764],
  [867, 666, 0.321995701601107],
  [867, 667, 0.4677769922252197],
  [867, 668, 0.17692400337387545],
  [868, 667, 0.07312870986769164],
  [868, 668, 0.3630952451007391],
  [868, 669, 0.4264378437134144],
  [868, 670, 0.13731285791147696],
  [869, 669, 0.11270032695167025],
  [869, 670, 0.4009509624326517],
  [869, 671, 0.38688927555227676],
  [869, 672, 0.09946833663506985],
  [870, 671, 0.15050630725355646],
  [870, 672, 0.43706477714430675],
  [870, 673, 0.34910378546507886],
  [870, 674, 0.06336347754327785],
  [871, 673, 0.1865736616624162],
  [871, 674, 0.4714631653468664],
  [871, 675, 0.3125696686315781],
  [871, 676, 0.028869775846049314],
  [872, 675, 0.22058655357283705],
  [872, 676, 0.502393455771382],
  [872, 677, 0.27458473006488804],
  [873, 677, 0.24983886475629993],
  [873, 678, 0.5137748593109537],
  [873, 679, 0.24315322539257223],
  [874, 678, 0.0036240101488931717],
  [874, 679, 0.2812413419420975],
  [874, 680, 0.49584386088869215],
  [874, 681, 0.2153614227018543],
  [875, 680, 0.034735500335029305],
  [875, 681, 0.3144060917430617],
  [875, 682, 0.46485314373790926],
  [875, 683, 0.18595981453922283],
  [876, 682, 0.0641063484572785],
  [876, 683, 0.34219859962945964],
  [876, 684, 0.43549740951782173],
  [876, 685, 0.15817234633893226],
  [877, 684, 0.091864261548934],
  [877, 685, 0.3683988258245694],
  [877, 686, 0.407752916631107],
  [877, 687, 0.13197572785525458],
  [878, 686, 0.11803256264694018],
  [878, 687, 0.3930296465168421],
  [878, 688, 0.3815964769154389],
  [878, 689, 0.10734720976073055],
  [879, 688, 0.1426340315995158],
  [879, 689, 0.4161134070872291],
  [879, 690, 0.35700543857338174],
  [879, 691, 0.08426456699687354],
  [880, 690, 0.16569092182506315],
  [880, 691, 0.43767193845249674],
  [880, 692, 0.33395766972405766],
  [880, 693, 0.06270608273067858],
  [881, 692, 0.1872249764612122],
  [881, 693, 0.457726572814142],
  [881, 694, 0.3124315425508366],
  [881, 695, 0.04265053289025597],
  [882, 694, 0.20725744392861123],
  [882, 695, 0.47629815883858434],
  [882, 696, 0.29240591801936916],
  [882, 697, 0.024077171256560802],
  [883, 696, 0.22580909293436022],
  [883, 697, 0.49340707629100294],
  [883, 698, 0.272739666255128],
  [883, 699, 0.006906252371233933],
  [884, 698, 0.24190643067177103],
  [884, 699, 0.5047275543873398],
  [884, 700, 0.2549459812508028],
  [885, 700, 0.2567100539467806],
  [885, 701, 0.5031577036963546],
  [885, 702, 0.24065881914660317],
  [886, 701, 0.008634717813202674],
  [886, 702, 0.27224949572145724],
  [886, 703, 0.49094674236787206],
  [886, 704, 0.22719544196570912],
  [887, 703, 0.02292373131969297],
  [887, 704, 0.28597629401801355],
  [887, 705, 0.47672398599653515],
  [887, 706, 0.2143533208320832],
  [888, 705, 0.035751602096786475],
  [888, 706, 0.29743237559552355],
  [888, 707, 0.46390276826706217],
  [888, 708, 0.20289630196958544],
  [889, 707, 0.04719579903029385],
  [889, 708, 0.3075210742305127],
  [889, 709, 0.45246460115847775],
  [889, 710, 0.19280622955805915],
  [890, 709, 0.057274491299496445],
  [890, 710, 0.3162602301176305],
  [890, 711, 0.4423913913890736],
  [890, 712, 0.18406533389761395],
  [891, 711, 0.0660054606502899],
  [891, 712, 0.3236673045470217],
  [891, 713, 0.43366542899845073],
  [891, 714, 0.17665622026124392],
  [892, 713, 0.07340611260620647],
  [892, 714, 0.3297593908476435],
  [892, 715, 0.4262693763198494],
  [892, 716, 0.17056185812791913],
  [893, 715, 0.07949348729590157],
  [893, 716, 0.33455322495703466],
  [893, 717, 0.42018625732795906],
  [893, 718, 0.16576557078065143],
  [894, 717, 0.0842842699121286],
  [894, 718, 0.3380651956328206],
  [894, 719, 0.41539944734620887],
  [894, 720, 0.16225102525634236],
  [895, 719, 0.0877948008176482],
  [895, 720, 0.3403113543186734],
  [895, 721, 0.41189266310148215],
  [895, 722, 0.1600022226324315],
  [896, 721, 0.09004108530992379],
  [896, 722, 0.3413074246800344],
  [896, 723, 0.4096499531105413],
  [896, 724, 0.15900348863810745],
  [897, 723, 0.0910388030604564],
  [897, 724, 0.341068811820455],
  [897, 725, 0.4086556883871424],
  [897, 726, 0.15923946457791555],
  [898, 725, 0.09080331723824445],
  [898, 726, 0.33961061119156805],
  [898, 727, 0.40889455345709996],
  [898, 728, 0.16069509855546693],
  [899, 727, 0.08934968333179105],
  [899, 728, 0.33694761720865024],
  [899, 729, 0.41035153766953336],
  [899, 730, 0.1633556369851302],
  [900, 729, 0.08669265767999552],
  [900, 730, 0.33309433158306806],
  [900, 731, 0.41301192679237225],
  [900, 732, 0.16720661638248935],
  [901, 731, 0.08284670572359325],
  [901, 732, 0.32806497138102175],
  [901, 733, 0.41686129488304347],
  [901, 734, 0.17223385542154263],
  [902, 733, 0.0778260099865808],
  [902, 734, 0.3218734768206457],
  [902, 735, 0.421885496422382],
  [902, 736, 0.17842344724960524],
  [903, 735, 0.07164447779930824],
  [903, 736, 0.31453351881588426],
  [903, 737, 0.42807065870301164],
  [903, 738, 0.185761752049803],
  [904, 737, 0.06431574877136567],
  [904, 738, 0.3060585062772846],
  [904, 739, 0.435403174462235],
  [904, 740, 0.19423538984244326],
  [905, 739, 0.05585320202451507],
  [905, 740, 0.29646159317816856],
  [905, 741, 0.4438696947508069],
  [905, 742, 0.20383123351642937],
  [906, 741, 0.04626996319383157],
  [906, 742, 0.2857556853951481],
  [906, 743, 0.4534571220289279],
  [906, 744, 0.21453640208174513],
  [907, 743, 0.03557891120608933],
  [907, 744, 0.27395344733160587],
  [907, 745, 0.4640838862781736],
  [907, 746, 0.2259711147745072],
  [908, 745, 0.02378916236694485],
  [908, 746, 0.26064383557298154],
  [908, 747, 0.4744097020055178],
  [908, 748, 0.23741469023048611],
  [908, 749, 0.0029874664482454345],
  [909, 747, 0.010888485342882084],
  [909, 748, 0.24524012825579347],
  [909, 749, 0.47705262348683797],
  [909, 750, 0.25146343127990345],
  [909, 751, 0.018030374036361534],
  [910, 750, 0.23051594568994063],
  [910, 751, 0.4659638155007443],
  [910, 752, 0.26789265476733026],
  [910, 753, 0.034103962104678205],
  [911, 752, 0.2157780537828917],
  [911, 753, 0.4490488012027463],
  [911, 754, 0.28394240197843773],
  [911, 755, 0.051207169174446954],
  [912, 754, 0.19869680451466967],
  [912, 755, 0.4309201309554197],
  [912, 756, 0.3010279740476113],
  [912, 757, 0.06933596927309439],
  [913, 756, 0.18059146729117878],
  [913, 757, 0.4117775174928008],
  [913, 758, 0.3191380672559441],
  [913, 759, 0.08847923890660256],
  [914, 758, 0.16147315955443303],
  [914, 759, 0.3916318997027402],
  [914, 760, 0.33826157637971177],
  [914, 761, 0.10862604895508292],
  [915, 760, 0.14135280401108383],
  [915, 761, 0.37049402581791996],
  [915, 762, 0.35838758963377015],
  [915, 763, 0.12976565972904766],
  [916, 762, 0.12024113359574008],
  [916, 763, 0.34837445826725],
  [916, 764, 0.3795053837685538],
  [916, 765, 0.15188751617588445],
  [917, 764, 0.0981486962833266],
  [917, 765, 0.32528357838026745],
  [917, 766, 0.40160441931520835],
  [917, 767, 0.17498124323033803],
  [918, 766, 0.07508585975635881],
  [918, 767, 0.30123159095005636],
  [918, 768, 0.42467433597326765],
  [918, 769, 0.19903664130457108],
  [919, 768, 0.05106281593203439],
  [919, 769, 0.2762285286588279],
  [919, 770, 0.4480441892579001],
  [919, 771, 0.22091817857346802],
  [920, 770, 0.02605116606412028],
  [920, 771, 0.24679268601046497],
  [920, 772, 0.4613333588465915],
  [920, 773, 0.24636316696152993],
  [920, 774, 0.026661594315488448],
  [921, 772, 17143112777602207e-20],
  [921, 773, 0.22016507993495968],
  [921, 774, 0.4450006731455823],
  [921, 775, 0.27654268563105877],
  [921, 776, 0.05450703342817279],
  [922, 775, 0.19537707282293476],
  [922, 776, 0.4169980825615683],
  [922, 777, 0.3043455873211709],
  [922, 778, 0.08322496813649063],
  [923, 777, 0.16671893224886847],
  [923, 778, 0.3873911007134449],
  [923, 779, 0.333032487802997],
  [923, 780, 0.11284587069811512],
  [924, 779, 0.1371380798307044],
  [924, 780, 0.3568813039463011],
  [924, 781, 0.36262258254682433],
  [924, 782, 0.14336176762117853],
  [925, 781, 0.10666365535341012],
  [925, 782, 0.32548606626333626],
  [925, 783, 0.39310680323983005],
  [925, 784, 0.17476372572452537],
  [926, 783, 0.07530458232966944],
  [926, 784, 0.2932141772790525],
  [926, 785, 0.4235343782302751],
  [926, 786, 0.20429957725699868],
  [927, 785, 0.04297407877416276],
  [927, 786, 0.2566282342451322],
  [927, 787, 0.44609730979381396],
  [927, 788, 0.23600300007995265],
  [927, 789, 0.023774697332874434],
  [928, 787, 0.00973561058609779],
  [928, 788, 0.22213324067090034],
  [928, 789, 0.4366882593279592],
  [928, 790, 0.27231575108916795],
  [928, 791, 0.058813271383982776],
  [929, 790, 0.1899112794795718],
  [929, 791, 0.4051174305988943],
  [929, 792, 0.3087329260703045],
  [929, 793, 0.09459113946159277],
  [930, 792, 0.15536737862587172],
  [930, 793, 0.36909687837539557],
  [930, 794, 0.3443998634306182],
  [930, 795, 0.13113054742980831],
  [931, 794, 0.11887833690004168],
  [931, 795, 0.3317399346424034],
  [931, 796, 0.3809015150071346],
  [931, 797, 0.1684974582828263],
  [932, 796, 0.08156315084174257],
  [932, 797, 0.29356399783457987],
  [932, 798, 0.4168389957384664],
  [932, 799, 0.2027189344423823],
  [933, 798, 0.043285265762028874],
  [933, 799, 0.2496929999720567],
  [933, 800, 0.44089395742648096],
  [933, 801, 0.24052352812737388],
  [933, 802, 0.03507425254057242],
  [934, 800, 0.0043335535351657515],
  [934, 801, 0.21027601904641954],
  [934, 802, 0.42143856683278325],
  [934, 803, 0.2844016743443022],
  [934, 804, 0.07585590645285804],
  [935, 803, 0.17353832434253885],
  [935, 804, 0.38262846297038483],
  [935, 805, 0.3257498632562316],
  [935, 806, 0.11730189433403454],
  [936, 805, 0.13268775789077444],
  [936, 806, 0.3407519309130924],
  [936, 807, 0.3670972990020704],
  [936, 808, 0.15947396875496164],
  [937, 807, 0.09057464650490143],
  [937, 808, 0.2978183751219168],
  [937, 809, 0.40749895190525254],
  [937, 810, 0.19795010289674397],
  [938, 809, 0.0474866463063797],
  [938, 810, 0.24850494279526708],
  [938, 811, 0.4346436181876547],
  [938, 812, 0.2403211224239381],
  [938, 813, 0.04014881320170647],
  [939, 811, 0.003878639500178961],
  [939, 812, 0.2047038150773143],
  [939, 813, 0.41157455841171137],
  [939, 814, 0.28957529821809164],
  [939, 815, 0.08560320920592149],
  [940, 814, 0.16385621221760913],
  [940, 815, 0.36828320787286745],
  [940, 816, 0.33550406688664397],
  [940, 817, 0.13164677712134118],
  [941, 816, 0.11836297424309958],
  [941, 817, 0.32185871977911545],
  [941, 818, 0.3799973298161782],
  [941, 819, 0.17581896778117206],
  [942, 818, 0.07143918326167292],
  [942, 819, 0.2705029465809176],
  [942, 820, 0.4180894904987747],
  [942, 821, 0.22040151023922497],
  [942, 822, 0.023261093492508676],
  [943, 820, 0.023754358875460287],
  [943, 821, 0.22082957274806367],
  [943, 822, 0.41735892037093947],
  [943, 823, 0.26975946681527463],
  [943, 824, 0.07244459405934162],
  [944, 823, 0.17462856886910824],
  [944, 824, 0.376380003235797],
  [944, 825, 0.32258384746152186],
  [944, 826, 0.12234695850241085],
  [945, 825, 0.12764964491952732],
  [945, 826, 0.32754202842781277],
  [945, 827, 0.3705351976091778],
  [945, 828, 0.17002290467196218],
  [946, 827, 0.07705703864783364],
  [946, 828, 0.27228373423426855],
  [946, 829, 0.4119493110954956],
  [946, 830, 0.21796235075295245],
  [946, 831, 0.024608216085607083],
  [947, 829, 0.025780053026113373],
  [947, 830, 0.2190518649272109],
  [947, 831, 0.41169318411556594],
  [947, 832, 0.27077590916361477],
  [947, 833, 0.07732052594065236],
  [948, 832, 0.1695115580680664],
  [948, 833, 0.36773423672329814],
  [948, 834, 0.3275311475162098],
  [948, 835, 0.13077893984001213],
  [949, 834, 0.11922966876699366],
  [949, 835, 0.31565346594837984],
  [949, 836, 0.37813100062036553],
  [949, 837, 0.17991281790206778],
  [950, 836, 0.06510103041600655],
  [950, 837, 0.25463712967072577],
  [950, 838, 0.4162975451493948],
  [950, 839, 0.23222690463246418],
  [950, 840, 0.043347365043106205],
  [951, 838, 0.010682336294089382],
  [951, 839, 0.20025854636251755],
  [951, 840, 0.3947874901107556],
  [951, 841, 0.2917173663646273],
  [951, 842, 0.09950708368621437],
  [952, 841, 0.14911244770443477],
  [952, 842, 0.3431424199239878],
  [952, 843, 0.3480530442639449],
  [952, 844, 0.15411315971947762],
  [953, 843, 0.0934299055238343],
  [953, 844, 0.2830893937829872],
  [953, 845, 0.3971235804951196],
  [953, 846, 0.20716078374370134],
  [953, 847, 0.020137203526012115],
  [954, 845, 0.036025540013401365],
  [954, 846, 0.22261124110739972],
  [954, 847, 0.40630997808531094],
  [954, 848, 0.2648205963423913],
  [954, 849, 0.07872881878459281],
  [955, 848, 0.16692727676480973],
  [955, 849, 0.35954874836594064],
  [955, 850, 0.328443108696204],
  [955, 851, 0.13751082396144756],
  [956, 850, 0.11152248261980105],
  [956, 851, 0.3006327942159715],
  [956, 852, 0.3829521945790107],
  [956, 853, 0.1916328343080391],
  [956, 854, 0.0076262937092498664],
  [957, 852, 0.0514953905500914],
  [957, 853, 0.2343500090068106],
  [957, 854, 0.41021535649217705],
  [957, 855, 0.25030428726128284],
  [957, 856, 0.06835964516566889],
  [958, 855, 0.17563114080501685],
  [958, 856, 0.3667504924135684],
  [958, 857, 0.31835263030310357],
  [958, 858, 0.1299663000321827],
  [959, 857, 0.11940718803292909],
  [959, 858, 0.3065438045294419],
  [959, 859, 0.37569491987401304],
  [959, 860, 0.18605528589059708],
  [959, 861, 0.004834820768368334],
  [960, 859, 0.05684866493974193],
  [960, 860, 0.2366688077210537],
  [960, 861, 0.4085057240274029],
  [960, 862, 0.24678375999468344],
  [960, 863, 0.06783571840441664],
  [961, 862, 0.17558642045742334],
  [961, 863, 0.36451985113857055],
  [961, 864, 0.3173137388508224],
  [961, 865, 0.13129392160626782],
  [962, 864, 0.11725721455632943],
  [962, 865, 0.3008194332920608],
  [962, 866, 0.37580301677160466],
  [962, 867, 0.19024874552861262],
  [962, 868, 0.011245575393110812],
  [963, 866, 0.05231298976932004],
  [963, 867, 0.23017401181136463],
  [963, 868, 0.40175554736854613],
  [963, 869, 0.2536595659979476],
  [963, 870, 0.07679940668774121],
  [964, 869, 0.16706057585212106],
  [964, 870, 0.35303258747063304],
  [964, 871, 0.3251768586309606],
  [964, 872, 0.14116418004635392],
  [965, 871, 0.10550294433561781],
  [965, 872, 0.28424844668945237],
  [965, 873, 0.38249269088982873],
  [965, 874, 0.2036626805762719],
  [965, 875, 0.02684871916582402],
  [966, 873, 0.03836058116912999],
  [966, 874, 0.21480488879977247],
  [966, 875, 0.389260042863657],
  [966, 876, 0.27095452974310497],
  [966, 877, 0.09504101254228686],
  [967, 876, 0.1502807743955375],
  [967, 877, 0.3328577086192332],
  [967, 878, 0.3421239629983485],
  [967, 879, 0.15918522100542254],
  [968, 878, 0.08474515454977341],
  [968, 879, 0.25820758590913884],
  [968, 880, 0.3938397310124852],
  [968, 881, 0.22523159171338067],
  [968, 882, 0.05190695217080459],
  [969, 880, 0.015820211753405387],
  [969, 881, 0.19007905592596833],
  [969, 882, 0.36921246833932636],
  [969, 883, 0.2980889913883655],
  [969, 884, 0.12132017371569158],
  [970, 883, 0.1247775639085626],
  [970, 884, 0.3015570552958629],
  [970, 885, 0.36552163552482225],
  [970, 886, 0.18684713857492927],
  [970, 887, 0.014284415706242481],
  [971, 885, 0.055013622481818666],
  [971, 886, 0.2263705108609403],
  [971, 887, 0.39186593267986564],
  [971, 888, 0.2561333080985603],
  [971, 889, 0.08592049273991473],
  [972, 888, 0.1575841200944441],
  [972, 889, 0.3370827060887002],
  [972, 890, 0.33284859953655166],
  [972, 891, 0.15390042438231766],
  [973, 890, 0.08972988049108406],
  [973, 891, 0.2590326783958039],
  [973, 892, 0.38812639016604245],
  [973, 893, 0.22348813860080616],
  [973, 894, 0.054161074977768404],
  [974, 892, 0.017081968749935856],
  [974, 893, 0.18740927170107446],
  [974, 894, 0.3625874079443392],
  [974, 895, 0.2990263270079478],
  [974, 896, 0.12613079428882987],
  [975, 895, 0.11819045745461297],
  [975, 896, 0.28905735771716573],
  [975, 897, 0.36789499357104777],
  [975, 898, 0.19628130377264577],
  [975, 899, 0.02735424128922767],
  [976, 897, 0.04494375361325131],
  [976, 898, 0.21330043570426716],
  [976, 899, 0.37902147922066165],
  [976, 900, 0.2697531768133337],
  [976, 901, 0.10241904377888808],
  [977, 900, 0.14130067843136315],
  [977, 901, 0.3150246804904708],
  [977, 902, 0.3480110183643501],
  [977, 903, 0.1725701388645175],
  [977, 904, 0.005966983373903607],
  [978, 902, 0.06884101502859519],
  [978, 903, 0.23351128359258333],
  [978, 904, 0.3898863909020141],
  [978, 905, 0.24593198700119934],
  [978, 906, 0.08224765045066],
  [979, 905, 0.1597942440306211],
  [979, 906, 0.3346851109670727],
  [979, 907, 0.3285973743088808],
  [979, 908, 0.15444027476874822],
  [980, 907, 0.08792661347585409],
  [980, 908, 0.2508895640647832],
  [980, 909, 0.38533070676895603],
  [980, 910, 0.22893712756876922],
  [980, 911, 0.06583953763953361],
  [981, 909, 0.01060737785460527],
  [981, 910, 0.17530908392596897],
  [981, 911, 0.34707093920704996],
  [981, 912, 0.3101853041457825],
  [981, 913, 0.1404924603408273],
  [982, 912, 0.1016482122325276],
  [982, 913, 0.2640331008343238],
  [982, 914, 0.3757885914855772],
  [982, 915, 0.21658719088481612],
  [982, 916, 0.05379076081392352],
  [983, 914, 0.023321537452804155],
  [983, 915, 0.1869789080592518],
  [983, 916, 0.35433193126746176],
  [983, 917, 0.2960976478285003],
  [983, 918, 0.13047091456929613],
  [984, 917, 0.11086010315035294],
  [984, 918, 0.272590889791831],
  [984, 919, 0.3683410258652817],
  [984, 920, 0.20801518542415245],
  [984, 921, 0.04616290894518408],
  [985, 919, 0.03202626907959427],
  [985, 920, 0.1942489952348069],
  [985, 921, 0.35801621736570555],
  [985, 922, 0.2871844809716754],
  [985, 923, 0.12448425960359358],
  [986, 922, 0.11614980664040801],
  [986, 923, 0.2769245860037902],
  [986, 924, 0.3634503371272694],
  [986, 925, 0.20337777894188264],
  [986, 926, 0.04278533591281287],
  [987, 924, 0.036633170664026604],
  [987, 925, 0.19735437260885233],
  [987, 926, 0.3585975660673821],
  [987, 927, 0.28298312203941667],
  [987, 928, 0.12237172260813765],
  [988, 927, 0.11761764880185657],
  [988, 928, 0.2769347836061358],
  [988, 929, 0.3613222869658947],
  [988, 930, 0.20269252495682932],
  [988, 931, 0.04352084243134597],
  [989, 929, 0.03715658569409518],
  [989, 930, 0.19646584076452728],
  [989, 931, 0.3563193376763676],
  [989, 932, 0.28325914825402143],
  [989, 933, 0.12401877287718965],
  [990, 932, 0.11535841088563661],
  [990, 933, 0.2726772185957825],
  [990, 934, 0.36193002492598775],
  [990, 935, 0.2058724789923987],
  [990, 936, 0.04828585408934835],
  [991, 934, 0.03368059076582972],
  [991, 935, 0.19166681871807822],
  [991, 936, 0.35120102320155516],
  [991, 937, 0.2879669101334489],
  [991, 938, 0.12934311950798513],
  [992, 937, 0.10947528483272252],
  [992, 938, 0.2643619456949593],
  [992, 939, 0.36503164238003943],
  [992, 940, 0.21273290367631378],
  [992, 941, 0.05704255868679827],
  [993, 939, 0.026351338857843194],
  [993, 940, 0.18296002570453515],
  [993, 941, 0.3430562989307297],
  [993, 942, 0.29724916938947604],
  [993, 943, 0.13830626997954892],
  [994, 942, 0.10006782116457263],
  [994, 943, 0.2523219642979947],
  [994, 944, 0.3701807952606593],
  [994, 945, 0.22297333198451888],
  [994, 946, 0.06976592160365215],
  [995, 944, 0.015392306252147629],
  [995, 945, 0.17030051412165803],
  [995, 946, 0.33152253946088156],
  [995, 947, 0.31147369956054877],
  [995, 948, 0.1509473916728322],
  [996, 947, 0.087196881644584],
  [996, 948, 0.2369586950063475],
  [996, 949, 0.376718339613223],
  [996, 950, 0.2345765114615184],
  [996, 951, 0.08521591343298078],
  [997, 949, 0.0011357385555340561],
  [997, 950, 0.15263475001807864],
  [997, 951, 0.311827742306229],
  [997, 952, 0.32860504822914505],
  [997, 953, 0.16942021655341175],
  [997, 954, 0.016626147439510436],
  [998, 952, 0.07024774813594223],
  [998, 953, 0.2212622403680772],
  [998, 954, 0.36621398307130515],
  [998, 955, 0.2523140266095425],
  [998, 956, 0.10329850546808812],
  [999, 955, 0.13345393361930616],
  [999, 956, 0.2868146645965228],
  [999, 957, 0.3438149621043634],
  [999, 958, 0.19052159754051476],
  [999, 959, 0.038598535306774456],
  [1e3, 957, 0.04874340776161587],
  [1e3, 958, 0.20027433884645776],
  [1e3, 959, 0.35045072214288214],
  [1e3, 960, 0.2752172040116266],
  [1e3, 961, 0.1246081801436533],
  [1001, 960, 0.11153410463061227],
  [1001, 961, 0.25968030157128735],
  [1001, 962, 0.3589611456155988],
  [1001, 963, 0.21376355164890676],
  [1001, 964, 0.06462574300561937],
  [1002, 962, 0.024112239164856285],
  [1002, 963, 0.1744379670887302],
  [1002, 964, 0.32884307142135794],
  [1002, 965, 0.3038963549633426],
  [1002, 966, 0.14989396525089382],
  [1002, 967, 0.002787631885767016],
  [1003, 965, 0.08652179776851913],
  [1003, 966, 0.23158274748299973],
  [1003, 967, 0.37014802862444746],
  [1003, 968, 0.23660182809114255],
  [1003, 969, 0.09233857620429504],
  [1004, 968, 0.14320871996140178],
  [1004, 969, 0.2949268298641504],
  [1004, 970, 0.33370967770704096],
  [1004, 971, 0.1821563205430922],
  [1004, 972, 0.03341416685633306],
  [1005, 970, 0.05691996613850173],
  [1005, 971, 0.2048164607341282],
  [1005, 972, 0.34996958396767003],
  [1005, 973, 0.26846185022737096],
  [1005, 974, 0.12203613352843197],
  [1006, 973, 0.11270360292617912],
  [1006, 974, 0.2573174820670815],
  [1006, 975, 0.35551075517876596],
  [1006, 976, 0.21342439841857963],
  [1006, 977, 0.06808655521031844],
  [1007, 975, 0.02300584415020569],
  [1007, 976, 0.1693741701851818],
  [1007, 977, 0.31909197071849676],
  [1007, 978, 0.3064750144925845],
  [1007, 979, 0.1569666027177789],
  [1007, 980, 0.01237576860780718],
  [1008, 978, 0.07918600624195261],
  [1008, 979, 0.22224585329482],
  [1008, 980, 0.36060022658704466],
  [1008, 981, 0.24542280629144228],
  [1008, 982, 0.10372340547250797],
  [1009, 981, 0.13025049048804305],
  [1009, 982, 0.2755544084078468],
  [1009, 983, 0.34173289952302016],
  [1009, 984, 0.19757209548510224],
  [1009, 985, 0.052414383405106256],
  [1010, 983, 0.04055057399599624],
  [1010, 984, 0.18602861646793578],
  [1010, 985, 0.3325126760154172],
  [1010, 986, 0.28836807114447566],
  [1010, 987, 0.1417402962688462],
  [1010, 988, 7268068329768394e-19],
  [1011, 986, 0.0921230324039655],
  [1011, 987, 0.23132424535108578],
  [1011, 988, 0.3651955312519228],
  [1011, 989, 0.23251096307120944],
  [1011, 990, 0.09383068210249161],
  [1012, 989, 0.1395300348660987],
  [1012, 990, 0.2846106560560243],
  [1012, 991, 0.33325384799782276],
  [1012, 992, 0.18901293891606955],
  [1012, 993, 0.045352651706964286],
  [1013, 991, 0.0492531143811913],
  [1013, 992, 0.19272260635298227],
  [1013, 993, 0.33561458168523745],
  [1013, 994, 0.27986377343343843],
  [1013, 995, 0.13637852619084528],
  [1014, 994, 0.09650852938196901],
  [1014, 995, 0.2338020594070448],
  [1014, 996, 0.36193613166585775],
  [1014, 997, 0.22898317334607854],
  [1014, 998, 0.09193468643195023],
  [1015, 996, 0.002457496874436509],
  [1015, 997, 0.14093777570167637],
  [1015, 998, 0.28368384860268375],
  [1015, 999, 0.33027760738271117],
  [1015, 1e3, 0.1884400273628213],
  [1015, 1001, 0.046968846655108074],
  [1016, 999, 0.04899295849310335],
  [1016, 1e3, 0.19034003312195327],
  [1016, 1001, 0.3313219755276299],
  [1016, 1002, 0.28105052006571385],
  [1016, 1003, 0.13948843868730657],
  [1016, 1004, 0.0023949943264103815],
  [1017, 1002, 0.09296476581718328],
  [1017, 1003, 0.22852898102309294],
  [1017, 1004, 0.35981389159869226],
  [1017, 1005, 0.23289594529521537],
  [1017, 1006, 0.09793041579114306],
  [1018, 1005, 0.13381394889325862],
  [1018, 1006, 0.27358691892030107],
  [1018, 1007, 0.33460745416509985],
  [1018, 1008, 0.1955825556102765],
  [1018, 1009, 0.05665143264068217],
  [1019, 1007, 0.040361378819567154],
  [1019, 1008, 0.17925977203170015],
  [1019, 1009, 0.31806447498945245],
  [1019, 1010, 0.2909077306146313],
  [1019, 1011, 0.1516962543781077],
  [1019, 1012, 0.01525050343287846],
  [1020, 1010, 0.08150854362929537],
  [1020, 1011, 0.21698349128246774],
  [1020, 1012, 0.3497669475500838],
  [1020, 1013, 0.24583808157633427],
  [1020, 1014, 0.11136370502634059],
  [1021, 1013, 0.1194990282921764],
  [1021, 1014, 0.25479878825131264],
  [1021, 1015, 0.34346022054644576],
  [1021, 1016, 0.20933239464254857],
  [1021, 1017, 0.07400664151417581],
  [1022, 1015, 0.023670383811016393],
  [1022, 1016, 0.1594303860158249],
  [1022, 1017, 0.29640289279632487],
  [1022, 1018, 0.3088876485347881],
  [1022, 1019, 0.17249814489158258],
  [1022, 1020, 0.03643709112995095],
  [1023, 1018, 0.062217701784737935],
  [1023, 1019, 0.19815982330648652],
  [1023, 1020, 0.3337745723213922],
  [1023, 1021, 0.3700921432339217],
  [1023, 1022, 0.3700921432339217]
];

// node_modules/@magenta/music/esm/gansynth/audio_utils.js
function melToLinearMatrix() {
  const m2l = buffer([1024, 1024]);
  for (let i = 0; i < MEL_SPARSE_COEFFS.length; i++) {
    const x = MEL_SPARSE_COEFFS[i];
    m2l.set(x[2], x[0], x[1]);
  }
  return m2l.toTensor();
}
function descale(data, a, b) {
  return div(sub(data, b), a);
}
function melToLinear(melLogPower) {
  return tidy(() => {
    const m2l = melToLinearMatrix().expandDims(0);
    const melLogPowerDb = descale(melLogPower, MAG_DESCALE_A, MAG_DESCALE_B);
    const melPower = exp(melLogPowerDb);
    const powerLin = matMul(melPower, m2l);
    const magLin = sqrt(powerLin);
    return magLin;
  });
}
function ifreqToPhase(ifreq) {
  return tidy(() => {
    const m2l = melToLinearMatrix().expandDims(0);
    const ifreqDescale = descale(ifreq, PHASE_DESCALE_A, PHASE_DESCALE_B);
    const phase = cumsum(mul(ifreqDescale, Math.PI), 1);
    const phaseLin = matMul(phase, m2l);
    return phaseLin;
  });
}
function interleaveReIm(real, imag) {
  const reImInterleave = tidy(() => {
    let reImBatch = concat([real, imag], 0).expandDims(3);
    reImBatch = pad(reImBatch, [[0, 0], [0, 0], [1, 0], [0, 0]]);
    const crops = [[0, 0], [0, 0]];
    const reImInterleave2 = batchToSpaceND(reImBatch, [1, 2], crops).reshape([128, 4096]);
    return reImInterleave2;
  });
  const reImArray = reImInterleave.dataSync();
  const reIm = [];
  for (let i = 0; i < 128; i++) {
    reIm[i] = reImArray.slice(i * 4096, (i + 1) * 4096);
  }
  reImInterleave.dispose();
  return reIm;
}
async function reImToAudio(reIm) {
  const ispecParams = {
    nFFt: N_FFT,
    winLength: N_FFT,
    hopLength: N_HOP,
    sampleRate: SAMPLE_RATE3,
    center: false
  };
  return istft(reIm, ispecParams);
}
async function specgramsToAudio(specgrams) {
  const reImArray = tidy(() => {
    const magSlice = slice(specgrams, [0, 0, 0, 0], [1, -1, -1, 1]).reshape([
      1,
      128,
      1024
    ]);
    const magMel = magSlice;
    const mag2 = melToLinear(magMel);
    const ifreqSlice = slice(specgrams, [0, 0, 0, 1], [
      1,
      -1,
      -1,
      1
    ]).reshape([1, 128, 1024]);
    const ifreq = ifreqSlice;
    const phase = ifreqToPhase(ifreq);
    let real = mag2.mul(cos(phase));
    const mirrorReal = reverse(real.slice([0, 0, 0], [1, 128, 1023]), 2);
    real = concat([real, mirrorReal], 2);
    let imag = mag2.mul(sin(phase));
    const mirrorImag = reverse(imag.slice([0, 0, 0], [1, 128, 1023]), 2);
    imag = concat([imag, mul(mirrorImag, -1)], 2);
    return [real, imag];
  });
  const reIm = await interleaveReIm(reImArray[0], reImArray[1]);
  const audio = await reImToAudio(reIm);
  reImArray.forEach((t) => t.dispose());
  return audio;
}
function ifft(reIm) {
  const nFFT = reIm.length / 2;
  const fft2 = new FFT3(nFFT);
  const recon = fft2.createComplexArray();
  fft2.inverseTransform(recon, reIm);
  const result = fft2.fromComplexArray(recon);
  return result;
}
function istft(reIm, params) {
  const nFrames = reIm.length;
  const nReIm = reIm[0].length;
  const nFft = nReIm / 2;
  const winLength = params.winLength || nFft;
  const hopLength = params.hopLength || Math.floor(winLength / 4);
  const center = params.center || false;
  let ifftWindow = hannWindow(winLength);
  for (let i = 0; i < ifftWindow.length; i++) {
    ifftWindow[i] = ifftWindow[i] / 1.5;
  }
  ifftWindow = padCenterToLength(ifftWindow, nFft);
  const expectedSignalLen = nFft + hopLength * (nFrames - 1);
  const y = new Float32Array(expectedSignalLen);
  for (let i = 0; i < nFrames; i++) {
    const sample = i * hopLength;
    let yTmp = ifft(reIm[i]);
    yTmp = applyWindow(yTmp, ifftWindow);
    yTmp = add2(yTmp, y.slice(sample, sample + nFft));
    y.set(yTmp, sample);
  }
  let sliceStart = 0;
  let sliceLength = expectedSignalLen;
  if (center) {
    sliceStart = nFft / 2;
    sliceLength = y.length - nFft / 2;
  } else {
    sliceStart = expectedSignalLen - SAMPLE_LENGTH;
    sliceLength = y.length - sliceStart;
  }
  const yTrimmed = y.slice(sliceStart, sliceLength);
  return yTrimmed;
}
function add2(arr0, arr1) {
  if (arr0.length !== arr1.length) {
    console.error(`Array lengths must be equal to add: ${arr0.length}, ${arr0.length}`);
    return null;
  }
  const out = new Float32Array(arr0.length);
  for (let i = 0; i < arr0.length; i++) {
    out[i] = arr0[i] + arr1[i];
  }
  return out;
}

// node_modules/@magenta/music/esm/gansynth/custom_layers.js
var PixelNorm = class extends exports_layers_exports.Layer {
  constructor(epsilon = 1e-8, layerConfig = {}) {
    super(layerConfig);
    this.epsilon = epsilon;
    this.layerConfig = layerConfig;
    this.supportsMasking = true;
  }
  computeOutputShape(inputShape) {
    return [inputShape[0], inputShape[1], inputShape[2], inputShape[3]];
  }
  call(inputs) {
    return tidy(() => {
      let input2 = inputs;
      if (Array.isArray(input2)) {
        input2 = input2[0];
      }
      const mean2 = mean(square(input2), [3], true);
      return mul(input2, rsqrt(add(mean2, this.epsilon)));
    });
  }
  getClassName() {
    return "PixelNorm";
  }
};
function pixelNorm(epsilon = 1e-8, layerConfig = {}) {
  return new PixelNorm(epsilon, layerConfig);
}
var InitialPad = class extends exports_layers_exports.Layer {
  constructor(kernelH = 2, kernelW = 16, layerConfig = {}) {
    super(layerConfig);
    this.kernelH = kernelH;
    this.kernelW = kernelW;
    this.layerConfig = layerConfig;
    this.supportsMasking = true;
  }
  computeOutputShape(inputShape) {
    return [
      inputShape[0],
      2 * (this.kernelH - 1) + inputShape[1],
      2 * (this.kernelW - 1) + inputShape[2],
      inputShape[3]
    ];
  }
  call(inputs) {
    let input2 = inputs;
    if (Array.isArray(input2)) {
      input2 = input2[0];
    }
    const padH = this.kernelH - 1;
    const padW = this.kernelW - 1;
    return pad(input2, [[0, 0], [padH, padH], [padW, padW], [0, 0]]);
  }
  getClassName() {
    return "InitialPad";
  }
};
function initialPad(kernelH = 2, kernelW = 16, layerConfig = {}) {
  return new InitialPad(kernelH, kernelW, layerConfig);
}
var BoxUpscale = class extends exports_layers_exports.Layer {
  constructor(scale = 2) {
    super({});
    this.scale = scale;
    this.supportsMasking = true;
  }
  computeOutputShape(inputShape) {
    return [
      inputShape[0],
      this.scale * inputShape[1],
      this.scale * inputShape[2],
      inputShape[3]
    ];
  }
  call(inputs) {
    return tidy(() => {
      let input2 = inputs;
      if (Array.isArray(input2)) {
        input2 = input2[0];
      }
      const tiledInput = tile(input2, [this.scale ** 2, 1, 1, 1]);
      return batchToSpaceND(tiledInput, [this.scale, this.scale], [[0, 0], [0, 0]]);
    });
  }
  getClassName() {
    return "BoxUpscale";
  }
};
function boxUpscale(scale = 2) {
  return new BoxUpscale(scale);
}

// node_modules/@magenta/music/esm/gansynth/model.js
var GANSynth = class {
  constructor(checkpointURL) {
    this.nn = sequential();
    this.nLatents = 256;
    this.nPitches = 61;
    this.minMidiPitch = 24;
    this.maxMidiPitch = 84;
    this.midiPitches = this.maxMidiPitch - this.minMidiPitch + 1;
    this.checkpointURL = checkpointURL;
  }
  async initialize() {
    const startTime = performance2.now();
    const vars = await fetch3(`${this.checkpointURL}/weights_manifest.json`).then((response) => response.json()).then((manifest) => io_exports.loadWeights(manifest, this.checkpointURL));
    tidy(() => {
      for (const v in vars) {
        if (v.includes("kernel")) {
          const fanIn2 = vars[v].shape[0] * vars[v].shape[1] * vars[v].shape[2];
          const tmp = vars[v];
          vars[v] = mul(tmp, sqrt(2 / fanIn2));
          tmp.dispose();
        }
      }
      this.build(vars);
      this.initialized = true;
      logWithDuration("Initialized model", startTime, "GANSynth");
    });
    Object.keys(vars).map((name) => vars[name].dispose());
  }
  dispose() {
    if (!this.initialized) {
      return;
    }
    this.nn.dispose();
    this.initialized = false;
  }
  isInitialized() {
    return this.initialized;
  }
  build(vars) {
    tidy(() => {
      const convConfig = {
        filters: 256,
        kernelSize: [2, 16],
        strides: [1, 1],
        activation: "linear",
        useBias: true,
        padding: "valid",
        dilationRate: [1, 1],
        trainable: false
      };
      const inputShape = { inputShape: [1, 1, this.nLatents + this.nPitches] };
      this.nn.add(pixelNorm(1e-8, inputShape));
      this.nn.add(initialPad(2, 16));
      this.nn.add(exports_layers_exports.conv2d(convConfig));
      this.nn.add(exports_layers_exports.leakyReLU({ alpha: 0.2 }));
      this.nn.add(pixelNorm());
      convConfig.padding = "same";
      convConfig.kernelSize = [3, 3];
      this.nn.add(exports_layers_exports.conv2d(convConfig));
      this.nn.add(exports_layers_exports.leakyReLU({ alpha: 0.2 }));
      this.nn.add(pixelNorm());
      const layerFilters = [256, 256, 256, 128, 64, 32];
      for (let i = 0; i < layerFilters.length; i++) {
        this.nn.add(boxUpscale(2));
        convConfig.filters = layerFilters[i];
        this.nn.add(exports_layers_exports.conv2d(convConfig));
        this.nn.add(exports_layers_exports.leakyReLU({ alpha: 0.2 }));
        this.nn.add(pixelNorm());
        this.nn.add(exports_layers_exports.conv2d(convConfig));
        this.nn.add(exports_layers_exports.leakyReLU({ alpha: 0.2 }));
        this.nn.add(pixelNorm());
      }
      convConfig.filters = 2;
      convConfig.kernelSize = [1, 1];
      convConfig.activation = "tanh";
      this.nn.add(exports_layers_exports.conv2d(convConfig));
      this.setWeights(vars);
    });
  }
  setWeights(vars) {
    function getVar(name) {
      const v = vars[name];
      if (v === void 0) {
        throw Error(`Variable not found: ${name}`);
      }
      return v;
    }
    const prefix = "Generator/progressive_gan_generator/progressive_gan_block_";
    const weights = [
      getVar(`${prefix}1/conv0/conv2d/kernel/ExponentialMovingAverage`),
      getVar(`${prefix}1/conv0/bias/ExponentialMovingAverage`),
      getVar(`${prefix}1/conv1/conv2d/kernel/ExponentialMovingAverage`),
      getVar(`${prefix}1/conv1/bias/ExponentialMovingAverage`),
      getVar(`${prefix}2/conv0/conv2d/kernel/ExponentialMovingAverage`),
      getVar(`${prefix}2/conv0/bias/ExponentialMovingAverage`),
      getVar(`${prefix}2/conv1/conv2d/kernel/ExponentialMovingAverage`),
      getVar(`${prefix}2/conv1/bias/ExponentialMovingAverage`),
      getVar(`${prefix}3/conv0/conv2d/kernel/ExponentialMovingAverage`),
      getVar(`${prefix}3/conv0/bias/ExponentialMovingAverage`),
      getVar(`${prefix}3/conv1/conv2d/kernel/ExponentialMovingAverage`),
      getVar(`${prefix}3/conv1/bias/ExponentialMovingAverage`),
      getVar(`${prefix}4/conv0/conv2d/kernel/ExponentialMovingAverage`),
      getVar(`${prefix}4/conv0/bias/ExponentialMovingAverage`),
      getVar(`${prefix}4/conv1/conv2d/kernel/ExponentialMovingAverage`),
      getVar(`${prefix}4/conv1/bias/ExponentialMovingAverage`),
      getVar(`${prefix}5/conv0/conv2d/kernel/ExponentialMovingAverage`),
      getVar(`${prefix}5/conv0/bias/ExponentialMovingAverage`),
      getVar(`${prefix}5/conv1/conv2d/kernel/ExponentialMovingAverage`),
      getVar(`${prefix}5/conv1/bias/ExponentialMovingAverage`),
      getVar(`${prefix}6/conv0/conv2d/kernel/ExponentialMovingAverage`),
      getVar(`${prefix}6/conv0/bias/ExponentialMovingAverage`),
      getVar(`${prefix}6/conv1/conv2d/kernel/ExponentialMovingAverage`),
      getVar(`${prefix}6/conv1/bias/ExponentialMovingAverage`),
      getVar(`${prefix}7/conv0/conv2d/kernel/ExponentialMovingAverage`),
      getVar(`${prefix}7/conv0/bias/ExponentialMovingAverage`),
      getVar(`${prefix}7/conv1/conv2d/kernel/ExponentialMovingAverage`),
      getVar(`${prefix}7/conv1/bias/ExponentialMovingAverage`),
      getVar(`${prefix}7/to_rgb/conv2d/kernel/ExponentialMovingAverage`),
      getVar(`${prefix}7/to_rgb/bias/ExponentialMovingAverage`)
    ];
    this.nn.setWeights(weights);
  }
  predict(inputs, batchSize) {
    return this.nn.predict(inputs, { batchSize });
  }
  randomSample(pitch) {
    return tidy(() => {
      const z = randomNormal([1, this.nLatents], 0, 1, "float32");
      const pitchIdx = tensor1d([pitch - this.minMidiPitch], "int32");
      const pitchOneHot = oneHot(pitchIdx, this.midiPitches);
      const cond = concat([z, pitchOneHot], 1).expandDims(1).expandDims(1);
      const specgrams = this.predict(cond, 1);
      return specgrams;
    });
  }
  specgramsToAudio(specgrams) {
    return specgramsToAudio(specgrams);
  }
};

// node_modules/@magenta/music/esm/spice/loudness_utils.js
async function computePower(audioChannelData) {
  const frameSize = 1024;
  const refDb = 20.7;
  const ldRange = 120;
  const hopSize = Math.floor(MODEL_SAMPLE_RATE / MODEL_FRAME_RATE);
  const audioTensor = tensor1d(audioChannelData, "float32");
  const newSamplesCount = audioChannelData.length;
  if (audioTensor === null) {
    return [];
  }
  const sq = audioTensor.mul(audioTensor).reshape([newSamplesCount, 1]);
  const rmsEnergy = conv1d(sq, ones([frameSize, 1, 1]).div(frameSize), hopSize, "same").sqrt().squeeze();
  const amin = 1e-20;
  const powerDb = mul(log(maximum(amin, rmsEnergy)).div(log(10)), 20);
  const powerDbShifted = powerDb.sub(refDb);
  const powerDbClipped = maximum(powerDbShifted, -ldRange);
  const output = await powerDbClipped.array();
  audioTensor.dispose();
  sq.dispose();
  rmsEnergy.dispose();
  powerDb.dispose();
  powerDbShifted.dispose();
  powerDbClipped.dispose();
  return output;
}

// node_modules/@magenta/music/esm/spice/pitch_utils.js
function shiftF0(f0Hz, f0OctaveShift = 0) {
  return tidy(() => {
    let tempF0 = mul(f0Hz, pow(2, f0OctaveShift));
    tempF0 = tempF0.clipByValue(0, midiToHz(110).dataSync()[0]);
    return tempF0;
  });
}
function upsample_linear(buffer2, newSampleRateLength) {
  const pitchedInput = [];
  const dupCountPitches = Math.floor(newSampleRateLength / buffer2.length);
  const modulos = newSampleRateLength % buffer2.length;
  for (let i = 0; i < buffer2.length; i++) {
    pitchedInput.push(buffer2[i]);
    for (let j = 1; j < dupCountPitches; j++) {
      pitchedInput.push(-1);
    }
    if (i < modulos) {
      pitchedInput.push(-1);
    }
  }
  let lastPitch = -1;
  for (let i = 0; i < pitchedInput.length; i++) {
    if (pitchedInput[i] !== -1) {
      let dif = pitchedInput[i];
      const lastValue = lastPitch >= 0 ? pitchedInput[lastPitch] : 0;
      if (lastPitch !== -1) {
        dif -= pitchedInput[lastPitch];
      }
      for (let j = lastPitch + 1; j < i; j++) {
        pitchedInput[j] = lastValue + dif * (j - lastPitch) / (i - lastPitch);
      }
      lastPitch = i;
    }
  }
  for (let i = lastPitch + 1; i < pitchedInput.length; i++) {
    pitchedInput[i] = lastPitch >= 0 ? pitchedInput[i - 1] : 0;
  }
  return pitchedInput;
}
function upsample_f0(buffer2, newSampleRateLength, modelMaxFrameLength) {
  buffer2.splice(modelMaxFrameLength);
  return upsample_linear(buffer2, newSampleRateLength);
}
function getPitchHz(modelPitch) {
  const fmin = 10;
  const binsPerOctave = 12;
  const cqtBin = modelPitch * PT_SLOPE + PT_OFFSET;
  return fmin * Math.pow(2, 1 * cqtBin / binsPerOctave);
}
async function getPitches(spiceModel, inputData, confidenceThreshold = CONF_THRESHOLD) {
  const SPICE_SAMPLE_RATE = 16e3;
  const SPICE_MODEL_MULTIPLE = 512;
  const spicePitchesOutput = [];
  const allConfidences = [];
  const audioChannelDataLength = inputData.length;
  const inputTensor = tensor(inputData);
  const inputSampleNum = Math.ceil(audioChannelDataLength / SPICE_MODEL_MULTIPLE) * SPICE_MODEL_MULTIPLE;
  const fullInputWithPadding = inputTensor.pad([
    [0, inputSampleNum - audioChannelDataLength]
  ]);
  const expectedDuration = fullInputWithPadding.size / SPICE_SAMPLE_RATE;
  const output = await spiceModel.execute({
    input_audio_samples: fullInputWithPadding
  });
  let uncertainties = await output[0].data();
  const pitches = await output[1].data();
  if ((pitches.length - 1) * 32 / 1e3 === expectedDuration) {
    let lastPitch = 20;
    for (let i = 0; i < pitches.length; ++i) {
      const confidence = 1 - uncertainties[i];
      allConfidences.push(confidence);
      if (confidence >= CONF_THRESHOLD) {
        lastPitch = getPitchHz(pitches[i]);
        spicePitchesOutput.push(lastPitch);
      } else {
        const noiseT = truncatedNormal([1], 0, PITCH_CONF_JITTER);
        const noise = await noiseT.array();
        const jitter = 1 - noise;
        spicePitchesOutput.push(lastPitch * jitter);
        noiseT.dispose();
      }
    }
  } else {
    const finalPitchesLength = inputSampleNum / SPICE_MODEL_MULTIPLE + 1;
    const stitchedPitches = new Float32Array(finalPitchesLength);
    uncertainties = new Float32Array(finalPitchesLength);
    for (let i = 0; i < inputSampleNum; i += inputSampleNum / 4) {
      const partialInput = fullInputWithPadding.slice([i], [inputSampleNum / 4]);
      const partialOutput = await spiceModel.execute({
        input_audio_samples: partialInput
      });
      const partialUncertainties = await partialOutput[0].data();
      const partialPitches = await partialOutput[1].data();
      const index = Math.floor(i / SPICE_MODEL_MULTIPLE);
      uncertainties.set(partialUncertainties, index);
      stitchedPitches.set(partialPitches, index);
      partialInput.dispose();
      partialOutput[0].dispose();
      partialOutput[1].dispose();
    }
    let lastPitch = 20;
    for (let i = 0; i < stitchedPitches.length; ++i) {
      const confidence = 1 - uncertainties[i];
      allConfidences.push(confidence);
      if (confidence >= confidenceThreshold) {
        lastPitch = getPitchHz(stitchedPitches[i]);
        spicePitchesOutput.push(lastPitch);
      } else {
        const noiseT = truncatedNormal([1], 0, PITCH_CONF_JITTER);
        const noise = await noiseT.array();
        const jitter = 1 - noise;
        spicePitchesOutput.push(lastPitch * jitter);
        noiseT.dispose();
      }
    }
  }
  output[0].dispose();
  output[1].dispose();
  inputTensor.dispose();
  fullInputWithPadding.dispose();
  return { pitches: spicePitchesOutput, confidences: allConfidences };
}

// node_modules/@magenta/music/esm/spice/spice.js
var MODEL_SAMPLE_RATE = 16e3;
var MODEL_FRAME_RATE = 250;
var PT_OFFSET = 25.58;
var PT_SLOPE = 63.07;
var PITCH_CONF_JITTER = 2e-3;
var CONF_THRESHOLD = 0.7;
async function startSpice(modelUrl) {
  let spiceModel;
  spiceModel = await loadGraphModel(modelUrl, {
    fromTFHub: true
  });
  return spiceModel;
}
async function getAudioFeatures(inputAudioBuffer, spiceModel, confidenceThreshold) {
  if (getBackend() !== "webgl") {
    throw new Error("Device does not support webgl.");
  }
  const audioData = await resampleAndMakeMono(inputAudioBuffer, MODEL_SAMPLE_RATE);
  const originalRecordedBufferLength = audioData.length;
  const powerTmp = await computePower(audioData);
  const { pitches, confidences } = await getPitches(spiceModel, audioData, confidenceThreshold);
  return {
    f0_hz: pitches,
    loudness_db: powerTmp,
    confidences,
    originalRecordedBufferLength
  };
}

// node_modules/@magenta/music/esm/spice/model.js
var TFHUB_SPICE_MODEL_URL = "https://tfhub.dev/google/tfjs-model/spice/2/default/1";
var SPICE = class {
  constructor(modelUrl) {
    if (modelUrl) {
      this.modelUrl = modelUrl;
    } else {
      this.modelUrl = TFHUB_SPICE_MODEL_URL;
    }
  }
  async initialize() {
    this.spiceModel = await startSpice(this.modelUrl);
    this.initialized = true;
  }
  async getAudioFeatures(inputAudioBuffer, confidenceThreshold) {
    return await getAudioFeatures(inputAudioBuffer, this.spiceModel, confidenceThreshold);
  }
  dispose() {
    if (!this.initialized) {
      return;
    }
    this.spiceModel.dispose();
    this.initialized = false;
  }
  isInitialized() {
    return this.initialized;
  }
};

// node_modules/@magenta/music/esm/ddsp/buffer_utils.js
var arrayBufferToAudioBuffer = (audioCtx, arrayBuffer, sampleRate) => {
  const newBuffer = audioCtx.createBuffer(1, arrayBuffer.length, sampleRate);
  newBuffer.copyToChannel(arrayBuffer, 0);
  return newBuffer;
};

// node_modules/@magenta/music/esm/ddsp/add_reverb.js
async function addReverb({ audioCtx, arrayBuffer, sampleRate }) {
  setContext(audioCtx);
  let bufferWithReverb;
  let resampledAudioBuffer = arrayBufferToAudioBuffer(audioCtx, arrayBuffer, sampleRate);
  const renderingPromise = Offline(() => {
    const limiter = new Compressor({
      attack: 1e-3,
      release: 1e-3,
      threshold: -6
    }).toDestination();
    const reverb = new Reverb({
      wet: 0.3,
      decay: 3
    }).connect(limiter);
    const filter = new Filter(8e3, "lowpass", -24).connect(reverb);
    const player = new Player({
      url: resampledAudioBuffer
    }).connect(filter);
    player.start();
    return reverb.ready;
  }, arrayBuffer.length / sampleRate);
  bufferWithReverb = await renderingPromise;
  const bufferWithReverbData = bufferWithReverb.getChannelData(0);
  resampledAudioBuffer = null;
  bufferWithReverb.dispose();
  bufferWithReverb = null;
  return bufferWithReverbData;
}

// node_modules/@magenta/music/esm/ddsp/audio_utils.js
function mixAndJoinAudioData(buffers, mixLength) {
  const finalFrameLength = buffers.reduce((acc, buffer2) => acc + buffer2.length, 0);
  const mixedAndJoinedBuffer = new Float32Array(finalFrameLength);
  const getCrossFadedValue = (a, b, _ratio) => {
    return a * (1 - _ratio) + b * _ratio;
  };
  let bufferLengthCount = 0;
  for (let bufferCount = 0; bufferCount < buffers.length; bufferCount++) {
    const currentBuffer = buffers[bufferCount];
    const hasNextBuffer = bufferCount < buffers.length - 1;
    if (bufferCount === 0) {
      mixedAndJoinedBuffer.set(currentBuffer, bufferLengthCount);
      bufferLengthCount += currentBuffer.length;
    }
    if (hasNextBuffer) {
      const nextBuffer = buffers[bufferCount + 1];
      const offset = bufferLengthCount - mixLength;
      for (let i = offset, j = 0, currentBufferCounter = currentBuffer.length - mixLength; i < bufferLengthCount && j < nextBuffer.length; i++, j++, currentBufferCounter++) {
        const ratioPercentage = (i - offset) / (bufferLengthCount - offset);
        mixedAndJoinedBuffer[i] = getCrossFadedValue(currentBuffer[currentBufferCounter], nextBuffer[j], ratioPercentage);
      }
      mixedAndJoinedBuffer.set(nextBuffer.slice(mixLength), bufferLengthCount);
      bufferLengthCount += nextBuffer.slice(mixLength).length;
    }
  }
  return mixedAndJoinedBuffer;
}

// node_modules/@magenta/music/esm/ddsp/constants.js
var MIN_VRAM = 50;
var LOWEST_LD = -120;
var CROSSFADE_DURATION = 1;
var OUTPUT_SAMPLE_RATE = 48e3;
var LD_CONF_REDUCTION = -25;
var CONF_SMOOTH_SIZE = 100;
var CONF_THRESHOLD2 = 0.7;

// node_modules/@magenta/music/esm/ddsp/ddsp.js
async function memCheck() {
  const bytesPerMB = 1024 * 1024;
  const screenResToVRAMFactor = 600;
  const screenSize = window.screen.availWidth * window.screen.availHeight;
  const DPI = window.devicePixelRatio;
  const vramSize = Math.round(screenSize * DPI * screenResToVRAMFactor / bytesPerMB);
  if (!isNaN(vramSize) && vramSize < MIN_VRAM) {
    throw new Error(`Insufficient memory! Your device has ${vramSize} and recommended memory is ${MIN_VRAM}`);
  }
  try {
    await ready();
    if (getBackend() !== "webgl") {
      throw new Error("It looks like your browser does not support webgl.");
    }
  } catch (err) {
    throw new Error(`insufficient memory - ${err}`);
  }
  return true;
}
async function getModel(url) {
  const model2 = await loadGraphModel(url);
  return model2;
}
function resizeAudioFeatures(audioFeatures, startingFrame, endingFrame, isLastChunks, resizedLength) {
  return new Promise((resolve) => {
    const resizedAudioFeatures = {
      loudness_db: [0],
      f0_hz: [0]
    };
    let counter = 0;
    for (let i = startingFrame; i < endingFrame; i++) {
      if (isLastChunks && i >= resizedLength) {
        resizedAudioFeatures.loudness_db[counter] = LOWEST_LD;
        resizedAudioFeatures.f0_hz[counter] = -1;
      } else {
        resizedAudioFeatures.loudness_db[counter] = audioFeatures.loudness_db[i];
        resizedAudioFeatures.f0_hz[counter] = audioFeatures.f0_hz[i];
      }
      counter += 1;
    }
    resolve(resizedAudioFeatures);
  });
}
async function normalizeAudioFeatures(af, model2) {
  const SELECTED_LD_AVG_MAX = model2.averageMaxLoudness;
  const SELECTED_LD_MEAN = model2.meanLoudness;
  const SELECTED_LD_THRESH = model2.loudnessThreshold;
  const SELECTED_P_MEAN = model2.meanPitch;
  let loudness_db = [];
  let maskedPower;
  if (af.loudness_db.length > 0) {
    const ldShifted = tidy(() => {
      const inputLoudnessTensor = tensor1d(af.loudness_db, "float32");
      const ldMax = inputLoudnessTensor.max();
      const ldDiffMax = sub(SELECTED_LD_AVG_MAX, ldMax);
      const final = add(inputLoudnessTensor, ldDiffMax);
      inputLoudnessTensor.dispose();
      ldMax.dispose();
      ldDiffMax.dispose();
      return final;
    });
    const ldShiftedGreater = ldShifted.greater(SELECTED_LD_THRESH);
    const ldGreater = await booleanMaskAsync(ldShifted, ldShiftedGreater);
    const ldGreaterVal = await ldGreater.array();
    const ldFinal = tidy(() => {
      const ldMean = ldGreaterVal > 0 ? ldGreater.mean() : ldShifted.mean();
      const ldDiffMean = sub(SELECTED_LD_MEAN, ldMean);
      const ldDiffMeanAdded = ldShifted.add(ldDiffMean);
      const loudnessAdjustment = 0;
      const ldAdjusted = ldDiffMeanAdded.add(loudnessAdjustment);
      const ldClipped = ldAdjusted.clipByValue(LOWEST_LD, SELECTED_LD_AVG_MAX);
      const oldMin = ldClipped.min();
      const subOldMin = ldMean.sub(oldMin);
      return ldClipped.sub(oldMin).div(subOldMin).mul(SELECTED_LD_MEAN - LOWEST_LD).add(LOWEST_LD);
    });
    const reshapedConf = reshape(af.confidences, [-1, 1, 1]);
    const smoothConf = pool(reshapedConf, [CONF_SMOOTH_SIZE, 1], "avg", "same");
    const smoothConfReshaped = smoothConf.reshape([-1]);
    const confMask = lessEqual(smoothConfReshaped, CONF_THRESHOLD2);
    maskedPower = tidy(() => {
      const confReduction = confMask.mul(LD_CONF_REDUCTION);
      const loudnessReduced = ldFinal.add(confReduction);
      const finalMaskedPower = maximum(loudnessReduced, LOWEST_LD);
      confReduction.dispose();
      loudnessReduced.dispose();
      return finalMaskedPower;
    });
    loudness_db = await maskedPower.array();
    ldShiftedGreater.dispose();
    ldShifted.dispose();
    ldFinal.dispose();
    ldGreater.dispose();
    smoothConf.dispose();
    smoothConfReshaped.dispose();
    reshapedConf.dispose();
    confMask.dispose();
  }
  let f0_hz = [];
  if (af.f0_hz.length > 0) {
    const _p = await hzToMidi(af.f0_hz);
    const p = tidy(() => {
      for (let i = 0, n = _p.length; i < n; ++i) {
        if (_p[i] === -Infinity) {
          _p[i] = 0;
        }
      }
      return _p;
    });
    const confMask = lessEqual(af.confidences, CONF_THRESHOLD2);
    const maskedPowerThreshold = maskedPower.greater(SELECTED_LD_THRESH);
    const mask = logicalOr(confMask, maskedPowerThreshold);
    const pMask = await booleanMaskAsync(p, mask);
    const pMean = pMask.mean();
    const pDiff = await sub(SELECTED_P_MEAN, pMean);
    const pDiffVal = await pDiff.array();
    const finalf0 = tidy(() => {
      let pDiffOctave = pDiffVal / 12;
      pDiffOctave = Math.round(pDiffOctave);
      const shiftedF0WithOctave = shiftF0(af.f0_hz, pDiffOctave);
      return shiftedF0WithOctave;
    });
    f0_hz = await finalf0.array();
    maskedPower.dispose();
    pMean.dispose();
    pMask.dispose();
    pDiff.dispose();
    finalf0.dispose();
    maskedPowerThreshold.dispose();
    mask.dispose();
    confMask.dispose();
  }
  return { f0_hz, loudness_db };
}
function convertSecsToFrame(secs) {
  return secs * MODEL_FRAME_RATE;
}
function convertFrameToSecs(frameLength) {
  return frameLength / MODEL_FRAME_RATE;
}

// node_modules/@magenta/music/esm/ddsp/model.js
var DDSP = class {
  constructor(checkpointUrl, settings) {
    this.checkpointUrl = checkpointUrl;
    if (settings) {
      this.settings = settings;
    }
  }
  async initialize() {
    registerOp("Roll", (node) => {
      const tensors = split(node.inputs[0], 2, 2);
      const result = concat([tensors[1], tensors[0]], 2);
      tensors.forEach((tensor2) => tensor2.dispose());
      return result;
    });
    env().set("WEBGL_PACK", false);
    env().set("WEBGL_CONV_IM2COL", false);
    env().set("WEBGL_DELETE_TEXTURE_THRESHOLD", 100 * 1024 * 1024);
    this.model = await getModel(`${this.checkpointUrl}/model.json`);
    let settings;
    try {
      settings = await fetch(`${this.checkpointUrl}/settings.json`).then((res) => res.json());
    } finally {
      if (this.settings === null) {
        throw new Error("Passing settings is required if you do not have a settings.json file.");
      }
    }
    this.settings = {
      ...settings,
      ...this.settings
    };
    this.initialized = true;
  }
  dispose() {
    if (!this.initialized) {
      return;
    }
    this.model.dispose();
    this.checkpointUrl = null;
    this.initialized = false;
  }
  isInitialized() {
    return this.initialized;
  }
  async memCheck() {
    return await memCheck();
  }
  async synthesize(audioFeatures, settings) {
    if (settings !== null) {
      this.settings = { ...this.settings, ...settings };
    }
    const { f0_hz, loudness_db, confidences } = audioFeatures;
    const upsampledPitches = upsample_f0(f0_hz, loudness_db.length, this.settings.modelMaxFrameLength);
    const upsampledConfidences = upsample_f0(confidences, loudness_db.length, this.settings.modelMaxFrameLength);
    const normalizedAudioFeatures = await normalizeAudioFeatures({
      f0_hz: upsampledPitches,
      loudness_db,
      confidences: upsampledConfidences
    }, this.settings);
    const audioChunks = [];
    const inputFrameLength = normalizedAudioFeatures.loudness_db.length;
    const inputAudioLengthInSecs = convertFrameToSecs(inputFrameLength);
    let isLastChunks = false;
    const usableAudioDuration = convertFrameToSecs(this.settings.modelMaxFrameLength);
    let audioBuffer;
    const mixBufferLength = CROSSFADE_DURATION * MODEL_SAMPLE_RATE;
    for (let i = 0; i < inputAudioLengthInSecs; i += usableAudioDuration - CROSSFADE_DURATION) {
      const startFrameIndex = Math.floor(convertSecsToFrame(i));
      const endFrameIndex = convertSecsToFrame(i + usableAudioDuration);
      if (endFrameIndex > inputFrameLength) {
        isLastChunks = true;
      }
      const { f0_hz: f0_hz2, loudness_db: loudness_db2 } = await resizeAudioFeatures(normalizedAudioFeatures, startFrameIndex, endFrameIndex, isLastChunks, inputFrameLength);
      const f0hzTensor = tensor1d(f0_hz2, "float32");
      const loudnessTensor = tensor1d(loudness_db2, "float32");
      const result = await this.model.predict({
        f0_hz: f0hzTensor,
        loudness_db: loudnessTensor
      });
      const resultData = await result.data();
      audioChunks.push(resultData);
      result.dispose();
      f0hzTensor.dispose();
      loudnessTensor.dispose();
    }
    if (inputAudioLengthInSecs <= usableAudioDuration) {
      audioBuffer = audioChunks[0];
    } else {
      const buffers = [];
      for (let i = 0; i < audioChunks.length; i++) {
        const ac = audioChunks[i];
        buffers.push(ac);
      }
      audioBuffer = mixAndJoinAudioData(buffers, mixBufferLength);
    }
    const trimmedAudioChannelData = audioBuffer.slice(0, audioFeatures.originalRecordedBufferLength);
    const trimmedACModified = trimmedAudioChannelData.map((val) => val * (this.settings.postGain || 1));
    const audioCtx = new Context();
    const trimmedAudioBuffer = arrayBufferToAudioBuffer(audioCtx, trimmedACModified, MODEL_SAMPLE_RATE);
    const resampledAudio = await resampleAndMakeMono(trimmedAudioBuffer, OUTPUT_SAMPLE_RATE);
    const bufferWithReverbData = await addReverb({
      audioCtx,
      arrayBuffer: resampledAudio,
      sampleRate: OUTPUT_SAMPLE_RATE
    });
    return bufferWithReverbData;
  }
};
export {
  BasePlayer,
  BasePlayerCallback,
  BaseRecorderCallback,
  BaseSVGVisualizer,
  BaseVisualizer,
  Coconet,
  DDSP,
  Decoder,
  Encoder,
  GANSynth,
  MIDIPlayer,
  Metronome,
  MetronomeCallbackObject,
  MidiConversionError,
  MidiMe,
  MusicRNN,
  MusicVAE,
  NoteSequence,
  OnsetsAndFrames,
  PianoGenie,
  PianoGenieChord,
  PianoGenieKeysig,
  PianoGenieKeysigChord,
  PianoGenieKeysigChordFamily,
  PianoRollCanvasVisualizer,
  PianoRollSVGVisualizer,
  Player2 as Player,
  PlayerWithClick,
  Recorder2 as Recorder,
  SPICE,
  ScrollType,
  SoundFontPlayer,
  StaffSVGVisualizer,
  Visualizer,
  WaterfallSVGVisualizer,
  aux_inputs_exports as aux_inputs,
  blobToNoteSequence,
  chords_exports as chords,
  constants_exports as constants,
  data_exports as data,
  logging_exports as logging,
  melodies_exports as melodies,
  midiToSequenceProto,
  performance_exports as performance,
  sequenceProtoToMidi,
  sequences_exports as sequences,
  dist_exports as tf,
  urlToBlob,
  urlToNoteSequence
};
/*! Bundled license information:

is-buffer/index.js:
  (*!
   * Determine if an object is a Buffer
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

tone/build/esm/core/Tone.js:
  (**
   * Tone.js
   * @author Yotam Mann
   * @license http://opensource.org/licenses/MIT MIT License
   * @copyright 2014-2019 Yotam Mann
   *)
*/
//# sourceMappingURL=@magenta_music.js.map
